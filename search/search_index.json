{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to geoserver-py","text":""},{"location":"#about","title":"About","text":"<p><code>geoserver-py</code> is a Python client for the GeoServer REST API. It is designed to be simple and easy to use, while providing access to the full functionality of the GeoServer REST API.</p>"},{"location":"#installation","title":"Installation","text":"<p>The <code>geoserver-py</code> package only requires the <code>requests</code> package as a dependency. To install it, simply run:</p> <pre><code>pip install geoserver-py\n</code></pre>"},{"location":"#quickstart","title":"Quickstart","text":""},{"location":"#connecting-to-geoserver","title":"Connecting to GeoServer","text":"<p>To get started with <code>geoserver-py</code>, you need to create a <code>GeoServer</code> object and provide the base URL of your GeoServer instance:</p> <pre><code>from geoserver import GeoServer\n\ngeoserver = GeoServer(\n    \"http://localhost:8080/geoserver\", \n    username=\"admin\", \n    password=\"geoserver\"\n)\n</code></pre> <p>You can then use the <code>geoserver</code> object to interact with your GeoServer instance. For example, to list all workspaces:</p> <pre><code>workspaces = geoserver.get_workspaces()\n</code></pre>"},{"location":"#using-xml-or-json-requests","title":"Using XML or JSON requests","text":"<p>The API supports both XML and JSON requests. All methods are fully type-hinted, so you can use your IDE's autocompletion to see the available parameters and return types, based on the requested format.</p> <p>For <code>POST</code> and <code>PUT</code> requests, you can specify the request body as either a dictionary (for JSON) or a string (for XML).</p> Using JSONUsing XML <pre><code>geoserver.create_workspace(\n    body={\"workspace\": {\"name\": \"new_workspace\"}}\n)\n</code></pre> <pre><code>geoserver.create_workspace(\n    body=\"&lt;workspace&gt;&lt;name&gt;new_workspace&lt;/name&gt;&lt;/workspace&gt;\"\n)\n</code></pre> <p>Similarly, you can specify the returned format for <code>GET</code> requests using the <code>format</code> parameter:</p> Using JSONUsing XML <pre><code>workspaces = geoserver.get_workspaces(format=\"json\")\n</code></pre> <pre><code>workspaces = geoserver.get_workspaces(format=\"xml\")\n</code></pre>"},{"location":"#error-handling","title":"Error handling","text":"<p>The API will raise exceptions for any HTTP error responses. You can catch these exceptions and handle them as needed.</p> <pre><code>from geoserver.exceptions import GeoServerError\n\n\ntry:\n    # Already exists\n    geoserver.create_workspace( \n        body={\"workspace\": {\"name\": \"new_workspace\"}}\n    )\nexcept GeoServerError as e:\n    print(f\"Status Code: {e.status_code}\")\n    print(f\"Error: {e.message}\")\n</code></pre>"},{"location":"#contributing-supporting","title":"Contributing &amp; Supporting","text":"<p>We welcome any contributions, from bug reports to new features! If you want to contribute to the package, please read the For Developers section.</p> <p>If you simply find the package useful, please consider giving it a star \u2b50\ufe0f on GitHub.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details.</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#020-2025-01-27","title":"0.2.0 (2025-01-27)","text":""},{"location":"changelog/#whats-changed","title":"What's Changed","text":""},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Fix resource calls endpoints (#16).</li> </ul>"},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Added CI/CD pipeline for pre-commit, tests, publishing to PyPI. Run tests and linter on PRs.</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Lowered the minimum required Python version to 3.8 and updated <code>pre-commit</code> minimum dependency.</li> <li>Added more tests for MacOS, Windows and Linux and various Python versions.</li> <li>Upgraded minimum python version from 3.8 to 3.9, to facilitate the use with numpy 2.x.y in development. Updated associated CI/CD pipeline.</li> </ul>"},{"location":"changelog/#removed","title":"Removed","text":"<ul> <li>Removed the TODOS.md file and added the tasks to the issues.</li> <li>Removed dev dependencies for black and isort.</li> </ul>"},{"location":"changelog/#new-contributors","title":"New Contributors","text":"<ul> <li>@mcebria-hg</li> <li>@lkpanganiban</li> </ul>"},{"location":"changelog/#010-2024-06-12","title":"0.1.0 (2024-06-12)","text":""},{"location":"changelog/#whats-changed_1","title":"What's Changed","text":""},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Updated version to 0.0.1 to 0.1.0 for PyPI release.</li> </ul>"},{"location":"changelog/#added_1","title":"Added","text":""},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>Renamed and restructured some endpoints / methods to share a similar structure.   (e.g. <code>get_workspace(workspace: str)</code> -&gt; <code>get_workspace(name: str)</code>, <code>get_layer(layer: str)</code> -&gt; <code>get_layer(name: str)</code>)</li> <li>Updated documentation and examples to reflect the changes.</li> </ul>"},{"location":"changelog/#removed_1","title":"Removed","text":""},{"location":"changelog/#new-contributors_1","title":"New Contributors","text":""},{"location":"changelog/#001-2024-06-06","title":"0.0.1 (2024-06-06)","text":""},{"location":"changelog/#whats-changed_2","title":"What's Changed","text":""},{"location":"changelog/#fixed_2","title":"Fixed","text":""},{"location":"changelog/#added_2","title":"Added","text":"<p>Initial release.</p>"},{"location":"changelog/#changed_2","title":"Changed","text":""},{"location":"changelog/#removed_2","title":"Removed","text":""},{"location":"changelog/#new-contributors_2","title":"New Contributors","text":""},{"location":"api/geoserver/","title":"GeoServer","text":"<p>               Bases: <code>Base</code></p> <p>GeoServer Client for Python. Use this class to interact with a GeoServer instance.</p> Note <p>This class implements most of the GeoServer REST API endpoints. You can follow the official GeoServer REST API documentation here.</p> <p>Parameters:</p> Name Type Description Default <code>service_url</code> <code>str</code> <p>The URL of the GeoServer instance.</p> <code>'http://localhost:8080/geoserver'</code> <code>username</code> <code>Optional[str]</code> <p>The username to authenticate with the GeoServer instance.</p> <code>None</code> <code>password</code> <code>Optional[str]</code> <p>The password to authenticate with the GeoServer instance.</p> <code>None</code> <code>headers</code> <code>Optional[Dict[str, Any]]</code> <p>The headers to be included in the requests.</p> <code>None</code> <code>cookies</code> <code>Optional[Dict[str, Any]]</code> <p>The cookies to be included in the requests.</p> <code>None</code> <code>auth</code> <code>Optional[AuthBase]</code> <p>The authentication to be included in the requests.</p> <code>None</code> <code>allow_redirects</code> <code>bool</code> <p>A boolean indicating whether or not the requests should follow redirects.</p> <code>True</code> <code>proxies</code> <code>Any</code> <p>The proxies to be included in the requests.</p> <code>None</code> <code>verify</code> <code>bool</code> <p>A boolean indicating whether or not the SSL certificates should be verified.</p> <code>True</code> <code>cert</code> <code>Optional[str]</code> <p>The certificate to be included in the requests.</p> <code>None</code> Example <pre><code>from geoserver import GeoServer\n\ngeoserver = GeoServer(\n    service_url=\"http://localhost:8080/geoserver\",\n    username=\"admin\",\n    password=\"geoserver\"\n)\n</code></pre> Source code in <code>geoserver/base.py</code> <pre><code>def __init__(\n    self,\n    service_url: str = \"http://localhost:8080/geoserver\",\n    username: Optional[str] = None,\n    password: Optional[str] = None,\n    headers: Optional[Dict[str, Any]] = None,\n    cookies: Optional[Dict[str, Any]] = None,\n    auth: Optional[AuthBase] = None,\n    allow_redirects: bool = True,\n    proxies: Any = None,\n    verify: bool = True,\n    cert: Optional[str] = None,\n):\n    if auth is None and username is not None and password is not None:\n        auth = HTTPBasicAuth(username, password)\n\n    self.service_url = service_url.rstrip(\"/\")\n    self.auth = auth\n    self.headers = headers or {}\n    self.cookies = cookies or {}\n    self.allow_redirects = allow_redirects\n    self.proxies = proxies or {}\n    self.verify = verify\n    self.cert = cert\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.get_manifest","title":"get_manifest","text":"<pre><code>get_manifest(*, manifest: Optional[str] = None, key: Optional[str] = None, value: Optional[str] = None, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_manifest(*, manifest: Optional[str] = None, key: Optional[str] = None, value: Optional[str] = None, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_manifest(*, manifest: Optional[str] = None, key: Optional[str] = None, value: Optional[str] = None, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>Retrieves the manifest of the GeoServer instance, in JSON format.</p> <p>Parameters:</p> Name Type Description Default <code>manifest</code> <code>Optional[str]</code> <p>Optional. The manifest parameter is used to filter over resulting resource (manifest) names attribute using Java regular expressions. Defaults to None.</p> <code>None</code> <code>key</code> <code>Optional[str]</code> <p>Optional. Only return manifest entries with this key in their properties. It can be optionally combined with the value parameter. Defaults to None.</p> <code>None</code> <code>value</code> <code>Optional[str]</code> <p>Optional. Only return manifest entries that have this value for the provided key parameter. Defaults to None.</p> <code>None</code> <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The manifest of the GeoServer instance.</p> Example <p>To get the manifest of the GeoServer instance, use the following code:</p> <pre><code>geoserver.get_manifest()\n</code></pre> Source code in <code>geoserver/geoserver.py</code> <pre><code>def get_manifest(\n    self,\n    *,\n    manifest: Optional[str] = None,\n    key: Optional[str] = None,\n    value: Optional[str] = None,\n    format: Literal[\"json\", \"xml\"] = \"json\",\n) -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"Retrieves the manifest of the GeoServer instance, in JSON format.\n\n    Args:\n        manifest: Optional. The manifest parameter is used to filter over resulting resource (manifest) names attribute using Java regular expressions. Defaults to None.\n        key: Optional. Only return manifest entries with this key in their properties. It can be optionally combined with the value parameter. Defaults to None.\n        value: Optional. Only return manifest entries that have this value for the provided key parameter. Defaults to None.\n        format: Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".\n\n    Returns:\n        The manifest of the GeoServer instance.\n\n    Example:\n        To get the manifest of the GeoServer instance, use the following code:\n\n        ```python\n        geoserver.get_manifest()\n        ```\n\n    \"\"\"\n    url = f\"{self.service_url}/rest/about/manifest.{format}\"\n    params = dict(manifest=manifest, key=key, value=value)\n    response = self._request(method=\"get\", url=url, params=params)\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.get_version","title":"get_version","text":"<pre><code>get_version(*, manifest: Optional[str] = None, key: Optional[str] = None, value: Optional[str] = None, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_version(*, manifest: Optional[str] = None, key: Optional[str] = None, value: Optional[str] = None, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_version(*, manifest: Optional[str] = None, key: Optional[str] = None, value: Optional[str] = None, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>Shows only the details for the high-level components: GeoServer, GeoTools, and GeoWebCache</p> <p>Parameters:</p> Name Type Description Default <code>manifest</code> <code>Optional[str]</code> <p>Optional. The manifest parameter is used to filter over resulting resource (manifest) names attribute using Java regular expressions. Defaults to None.</p> <code>None</code> <code>key</code> <code>Optional[str]</code> <p>Optional. Only return manifest entries with this key in their properties. It can be optionally combined with the value parameter. Defaults to None.</p> <code>None</code> <code>value</code> <code>Optional[str]</code> <p>Optional. Only return manifest entries that have this value for the provided key parameter. Defaults to None.</p> <code>None</code> <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The version of the GeoServer instance.</p> Example <p>To get the version of the GeoServer instance, use the following code:</p> <pre><code>geoserver.get_version()\n</code></pre> Source code in <code>geoserver/geoserver.py</code> <pre><code>def get_version(\n    self,\n    *,\n    manifest: Optional[str] = None,\n    key: Optional[str] = None,\n    value: Optional[str] = None,\n    format: Literal[\"json\", \"xml\"] = \"json\",\n) -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"Shows only the details for the high-level components: GeoServer, GeoTools, and GeoWebCache\n\n    Args:\n        manifest: Optional. The manifest parameter is used to filter over resulting resource (manifest) names attribute using Java regular expressions. Defaults to None.\n        key: Optional. Only return manifest entries with this key in their properties. It can be optionally combined with the value parameter. Defaults to None.\n        value: Optional. Only return manifest entries that have this value for the provided key parameter. Defaults to None.\n        format: Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".\n\n    Returns:\n        The version of the GeoServer instance.\n\n    Example:\n        To get the version of the GeoServer instance, use the following code:\n\n        ```python\n        geoserver.get_version()\n        ```\n    \"\"\"\n    url = f\"{self.service_url}/rest/about/version.{format}\"\n    params = dict(manifest=manifest, key=key, value=value)\n    response = self._request(method=\"get\", url=url, params=params)\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.get_status","title":"get_status","text":"<pre><code>get_status(*, manifest: Optional[str] = None, key: Optional[str] = None, value: Optional[str] = None, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_status(*, manifest: Optional[str] = None, key: Optional[str] = None, value: Optional[str] = None, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_status(*, manifest: Optional[str] = None, key: Optional[str] = None, value: Optional[str] = None, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>Shows the status details of all installed and configured modules. Status details always include human readable name, and module name. Optional details include version, availability, status message, and links to documentation.</p> <p>Parameters:</p> Name Type Description Default <code>manifest</code> <code>Optional[str]</code> <p>Optional. The manifest parameter is used to filter over resulting resource (manifest) names attribute using Java regular expressions. Defaults to None.</p> <code>None</code> <code>key</code> <code>Optional[str]</code> <p>Optional. Only return manifest entries with this key in their properties. It can be optionally combined with the value parameter. Defaults to None.</p> <code>None</code> <code>value</code> <code>Optional[str]</code> <p>Optional. Only return manifest entries that have this value for the provided key parameter. Defaults to None.</p> <code>None</code> <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The version of the GeoServer instance.</p> Example <p>To get the status of the GeoServer instance, use the following code:</p> <pre><code>geoserver.get_status()\n</code></pre> Source code in <code>geoserver/geoserver.py</code> <pre><code>def get_status(\n    self,\n    *,\n    manifest: Optional[str] = None,\n    key: Optional[str] = None,\n    value: Optional[str] = None,\n    format: Literal[\"json\", \"xml\"] = \"json\",\n) -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"Shows the status details of all installed and configured modules. Status details always include human readable name, and module name. Optional details include version, availability, status message, and links to documentation.\n\n    Args:\n        manifest: Optional. The manifest parameter is used to filter over resulting resource (manifest) names attribute using Java regular expressions. Defaults to None.\n        key: Optional. Only return manifest entries with this key in their properties. It can be optionally combined with the value parameter. Defaults to None.\n        value: Optional. Only return manifest entries that have this value for the provided key parameter. Defaults to None.\n        format: Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".\n\n    Returns:\n        The version of the GeoServer instance.\n\n    Example:\n        To get the status of the GeoServer instance, use the following code:\n\n        ```python\n        geoserver.get_status()\n        ```\n    \"\"\"\n    url = f\"{self.service_url}/rest/about/status.{format}\"\n    params = dict(manifest=manifest, key=key, value=value)\n    response = self._request(method=\"get\", url=url, params=params)\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.get_system_status","title":"get_system_status","text":"<pre><code>get_system_status(*, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_system_status(*, format: Literal['xml']) -&gt; str\n</code></pre><pre><code>get_system_status(*, format: Literal['html']) -&gt; str\n</code></pre> <pre><code>get_system_status(*, format: Literal['json', 'xml', 'html'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>Returns a list of system-level information. Major operating systems (Linux, Windows and MacOX) are supported out of the box.</p> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The system status of the GeoServer instance.</p> Example <p>To get the system status of the GeoServer instance, use the following code:</p> <pre><code>geoserver.get_system_status()\n</code></pre> Source code in <code>geoserver/geoserver.py</code> <pre><code>def get_system_status(self, *, format: Literal[\"json\", \"xml\", \"html\"] = \"json\") -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"Returns a list of system-level information. Major operating systems (Linux, Windows and MacOX) are supported out of the box.\n\n    Returns:\n        The system status of the GeoServer instance.\n\n    Example:\n        To get the system status of the GeoServer instance, use the following code:\n\n        ```python\n        geoserver.get_system_status()\n        ```\n    \"\"\"\n    url = f\"{self.service_url}/rest/about/system-status.{format}\"\n    response = self._request(method=\"get\", url=url)\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.get_data_stores","title":"get_data_stores","text":"<pre><code>get_data_stores(*, workspace: str, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_data_stores(*, workspace: str, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_data_stores(*, workspace: str, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>List all data stores in workspace ws.</p> <p>Parameters:</p> Name Type Description Default <code>workspace</code> <code>str</code> <p>The name of the workspace containing the data stores.</p> required <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response. It can be either \"json\" or \"xml\".</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The list of all datastores in the workspace.</p> Example <p>To get the list of all data stores in the workspace, use the following code:</p> <pre><code>geoserver.get_data_stores(workspace=\"my_workspace\")\n</code></pre> Source code in <code>geoserver/geoserver.py</code> <pre><code>def get_data_stores(self, *, workspace: str, format: Literal[\"json\", \"xml\"] = \"json\") -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"List all data stores in workspace ws.\n\n    Args:\n        workspace: The name of the workspace containing the data stores.\n        format: Optional. The format of the response. It can be either \"json\" or \"xml\".\n\n    Returns:\n        The list of all datastores in the workspace.\n\n    Example:\n        To get the list of all data stores in the workspace, use the following code:\n\n        ```python\n        geoserver.get_data_stores(workspace=\"my_workspace\")\n        ```\n    \"\"\"\n    url = f\"{self.service_url}/rest/workspaces/{workspace}/datastores.{format}\"\n    response = self._request(method=\"get\", url=url)\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.data_store_exists","title":"data_store_exists","text":"<pre><code>data_store_exists(name: str, *, workspace: str) -&gt; bool\n</code></pre> <p>Check if a data store exists in a workspace.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the data store.</p> required <code>workspace</code> <code>str</code> <p>The name of the workspace containing the data stores.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the data store exists, False otherwise.</p> Example <p>To check if a data store exists in a workspace, use the following code:</p> <pre><code>geoserver.data_store_exists(\"my_data_store\", workspace=\"my_workspace\")\n</code></pre> Source code in <code>geoserver/geoserver.py</code> <pre><code>def data_store_exists(self, name: str, *, workspace: str) -&gt; bool:\n    \"\"\"Check if a data store exists in a workspace.\n\n    Args:\n        name: The name of the data store.\n        workspace: The name of the workspace containing the data stores.\n\n    Returns:\n        True if the data store exists, False otherwise.\n\n    Example:\n        To check if a data store exists in a workspace, use the following code:\n\n        ```python\n        geoserver.data_store_exists(\"my_data_store\", workspace=\"my_workspace\")\n        ```\n    \"\"\"\n    url = f\"{self.service_url}/rest/workspaces/{workspace}/datastores/{name}.xml\"\n    response = self._request(method=\"head\", url=url, ignore=[404])\n    return response.status_code == 200\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.create_data_store","title":"create_data_store","text":"<pre><code>create_data_store(body: Union[str, Dict[str, Any]], *, workspace: str) -&gt; str\n</code></pre> <p>Adds a new data store to the workspace.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>Union[str, Dict[str, Any]]</code> <p>The body of the request used to create the data store.</p> required <code>workspace</code> <code>str</code> <p>The name of the workspace containing the data stores.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The data store created.</p> Example <p>To create a new data store in a workspace, use the following code:</p> <pre><code>body = \"\"\"\n&lt;dataStore&gt;\n    &lt;name&gt;my_data_store&lt;/name&gt;\n    &lt;connectionParameters&gt;\n        &lt;entry key=\"host\"&gt;localhost&lt;/entry&gt;\n        &lt;entry key=\"port\"&gt;5432&lt;/entry&gt;\n        &lt;entry key=\"database\"&gt;my_database&lt;/entry&gt;\n        &lt;entry key=\"user\"&gt;my_user&lt;/entry&gt;\n        &lt;entry key=\"passwd\"&gt;my_password&lt;/entry&gt;\n        &lt;entry key=\"dbtype\"&gt;postgis&lt;/entry&gt;\n    &lt;/connectionParameters&gt;\n&lt;/dataStore&gt;\n\"\"\"\n\ngeoserver.create_data_store(body, workspace=\"my_workspace\")\n</code></pre> Source code in <code>geoserver/geoserver.py</code> <pre><code>def create_data_store(self, body: Union[str, Dict[str, Any]], *, workspace: str) -&gt; str:\n    \"\"\"Adds a new data store to the workspace.\n\n    Args:\n        body: The body of the request used to create the data store.\n        workspace: The name of the workspace containing the data stores.\n\n    Returns:\n        The data store created.\n\n    Example:\n        To create a new data store in a workspace, use the following code:\n\n        ```python\n        body = \\\"\\\"\\\"\n        &lt;dataStore&gt;\n            &lt;name&gt;my_data_store&lt;/name&gt;\n            &lt;connectionParameters&gt;\n                &lt;entry key=\"host\"&gt;localhost&lt;/entry&gt;\n                &lt;entry key=\"port\"&gt;5432&lt;/entry&gt;\n                &lt;entry key=\"database\"&gt;my_database&lt;/entry&gt;\n                &lt;entry key=\"user\"&gt;my_user&lt;/entry&gt;\n                &lt;entry key=\"passwd\"&gt;my_password&lt;/entry&gt;\n                &lt;entry key=\"dbtype\"&gt;postgis&lt;/entry&gt;\n            &lt;/connectionParameters&gt;\n        &lt;/dataStore&gt;\n        \\\"\\\"\\\"\n\n        geoserver.create_data_store(body, workspace=\"my_workspace\")\n        ```\n    \"\"\"\n    url = f\"{self.service_url}/rest/workspaces/{workspace}/datastores\"\n    self._request(method=\"post\", url=url, body=body)\n    return CREATED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.upload_data_store","title":"upload_data_store","text":"<pre><code>upload_data_store(file: Union[str, Path, BufferedReader], *, workspace: str, name: Optional[str] = None, filename: Optional[str] = None, format: str = 'shp', configure: Literal['none', 'all'] = 'all', overwrite: bool = False) -&gt; str\n</code></pre> <p>Uploads a new or update an existing data store from a local file.</p> Note <p>The <code>store</code> parameter is automatically inferred from the file, if not provided. In case the file is a buffer, the <code>store</code> parameter is required.</p> Note <p>The file name of the resource can be overwritten by: - Providing the <code>filename</code> parameter. - Using the <code>name</code> parameter. In this case, if the <code>filename</code> is not provided,     the file name will be the same as the store name.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Union[str, Path, BufferedReader]</code> <p>The file to upload.</p> required <code>workspace</code> <code>str</code> <p>The name of the workspace.</p> required <code>name</code> <code>Optional[str]</code> <p>Optional. The name of the data store.</p> <code>None</code> <code>filename</code> <code>Optional[str]</code> <p>Optional. The filename parameter specifies the target file name for a file that needs to be harvested as part of a mosaic. This is important to avoid clashes and to make sure the right dimension values are available in the name for multidimensional mosaics to work. Only used if method=\"file\".</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Example <p>To upload a new data store from a local file, use the following code:</p> <pre><code>geoserver.upload_data_store(\"my_shapefile.zip\", workspace=\"my_workspace\", name=\"my_data_store\")\n</code></pre> <p>Or, using a buffer:</p> <pre><code>with open(\"my_shapefile.zip\", \"rb\") as f:\n    geoserver.upload_data_store(f, workspace=\"my_workspace\", name=\"my_data_store\")\n</code></pre> Source code in <code>geoserver/geoserver.py</code> <pre><code>def upload_data_store(\n    self,\n    file: Union[str, Path, BufferedReader],\n    *,\n    workspace: str,\n    name: Optional[str] = None,\n    filename: Optional[str] = None,\n    format: str = \"shp\",\n    configure: Literal[\"none\", \"all\"] = \"all\",\n    overwrite: bool = False,\n) -&gt; str:\n    \"\"\"Uploads a new or update an existing data store from a local file.\n\n    Note:\n        The `store` parameter is automatically inferred from the file, if not provided.\n        In case the file is a buffer, the `store` parameter is required.\n\n    Note:\n        The file name of the resource can be overwritten by:\n        - Providing the `filename` parameter.\n        - Using the `name` parameter. In this case, if the `filename` is not provided,\n            the file name will be the same as the store name.\n\n    Args:\n        file: The file to upload.\n        workspace: The name of the workspace.\n        name: Optional. The name of the data store.\n        filename:  Optional. The filename parameter specifies the target file name for a file that needs to be harvested as part of a mosaic.\n            This is important to avoid clashes and to make sure the right dimension values are available in the name for multidimensional mosaics to work.\n            Only used if method=\"file\".\n\n    Returns:\n        Success message.\n\n    Example:\n        To upload a new data store from a local file, use the following code:\n\n        ```python\n        geoserver.upload_data_store(\"my_shapefile.zip\", workspace=\"my_workspace\", name=\"my_data_store\")\n        ```\n\n        Or, using a buffer:\n\n        ```python\n        with open(\"my_shapefile.zip\", \"rb\") as f:\n            geoserver.upload_data_store(f, workspace=\"my_workspace\", name=\"my_data_store\")\n        ```\n    \"\"\"\n    if isinstance(file, Path):\n        file = file.as_posix()\n    if isinstance(file, str):\n        name = name or Path(file).stem\n        filename = filename or f\"{name}.{Path(file).suffix[1:]}\"\n    if name is None:\n        raise ValueError(\"The `store` parameter is required.\")\n\n    headers = {}\n    if zipfile.is_zipfile(file):\n        headers[\"Content-Type\"] = \"application/zip\"\n\n    params = dict(filename=filename, configure=configure)\n    if overwrite:\n        params[\"update\"] = \"overwrite\"\n\n    if isinstance(file, str) and file.startswith((\"file:\", \"http://\", \"https://\")):\n        headers[\"Content-Type\"] = \"text/plain\"\n        url = f\"{self.service_url}/rest/workspaces/{workspace}/datastores/{name}/external.{format}\"\n        self._request(method=\"put\", url=url, data=file, params=params, headers=headers)\n        return CREATED_MESSAGE\n\n    url = f\"{self.service_url}/rest/workspaces/{workspace}/datastores/{name}/file.{format}\"\n    self._request(method=\"put\", url=url, file=file, params=params, headers=headers)\n    return CREATED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.get_data_store","title":"get_data_store","text":"<pre><code>get_data_store(name: str, *, workspace: str, quiet_on_not_found: bool = False, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_data_store(name: str, *, workspace: str, quiet_on_not_found: bool = False, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_data_store(name: str, *, workspace: str, quiet_on_not_found: bool = False, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>Controls a particular data store in a given workspace.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the data store.</p> required <code>workspace</code> <code>str</code> <p>The name of the workspace containing the data stores.</p> required <code>quiet_on_not_found</code> <code>bool</code> <p>Optional. If true, the server will not report an error if the data store is not found.</p> <code>False</code> <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response. It can be either \"json\" or \"xml\".</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The requested data store.</p> Example <p>To get the data store, use the following code:</p> <pre><code>geoserver.get_data_store(\"my_data_store\", workspace=\"my_workspace\")\n</code></pre> Source code in <code>geoserver/geoserver.py</code> <pre><code>def get_data_store(\n    self, name: str, *, workspace: str, quiet_on_not_found: bool = False, format: Literal[\"json\", \"xml\"] = \"json\"\n) -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"Controls a particular data store in a given workspace.\n\n    Args:\n        name: The name of the data store.\n        workspace: The name of the workspace containing the data stores.\n        quiet_on_not_found: Optional. If true, the server will not report an error if the data store is not found.\n        format: Optional. The format of the response. It can be either \"json\" or \"xml\".\n\n    Returns:\n        The requested data store.\n\n    Example:\n        To get the data store, use the following code:\n\n        ```python\n        geoserver.get_data_store(\"my_data_store\", workspace=\"my_workspace\")\n        ```\n    \"\"\"\n    url = f\"{self.service_url}/rest/workspaces/{workspace}/datastores/{name}.{format}\"\n    params = dict(quietOnNotFound=quiet_on_not_found)\n    response = self._request(method=\"get\", url=url, params=params)\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.update_data_store","title":"update_data_store","text":"<pre><code>update_data_store(name: str, body: Union[str, Dict[str, Any]], *, workspace: str) -&gt; str\n</code></pre> <p>Modify a data store from a workspace.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the data store to modify.</p> required <code>workspace</code> <code>str</code> <p>The name of the workspace containing the data stores.</p> required <code>body</code> <code>Union[str, Dict[str, Any]]</code> <p>The body of the request used to modify the data store.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Example <p>To update a data store, use the following code:</p> <pre><code>body = \"\"\"\n&lt;dataStore&gt;\n    &lt;name&gt;my_new_data_store&lt;/name&gt;\n&lt;/dataStore&gt;\n\"\"\"\n\ngeoserver.update_data_store(\"my_data_store\", body, workspace=\"my_workspace\")\n</code></pre> Source code in <code>geoserver/geoserver.py</code> <pre><code>def update_data_store(self, name: str, body: Union[str, Dict[str, Any]], *, workspace: str) -&gt; str:\n    \"\"\"Modify a data store from a workspace.\n\n    Args:\n        name: The name of the data store to modify.\n        workspace: The name of the workspace containing the data stores.\n        body: The body of the request used to modify the data store.\n\n    Returns:\n        Success message.\n\n    Example:\n        To update a data store, use the following code:\n\n        ```python\n        body = \\\"\\\"\\\"\n        &lt;dataStore&gt;\n            &lt;name&gt;my_new_data_store&lt;/name&gt;\n        &lt;/dataStore&gt;\n        \\\"\\\"\\\"\n\n        geoserver.update_data_store(\"my_data_store\", body, workspace=\"my_workspace\")\n        ```\n    \"\"\"\n    url = f\"{self.service_url}/rest/workspaces/{workspace}/datastores/{name}\"\n    self._request(method=\"put\", url=url, body=body)\n    return UPDATED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.delete_data_store","title":"delete_data_store","text":"<pre><code>delete_data_store(name: str, *, workspace: str, recurse: bool = False) -&gt; str\n</code></pre> <p>Remove data store from workspace ws.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the data store to remove.</p> required <code>workspace</code> <code>str</code> <p>The name of the workspace containing the data stores.</p> required <code>recurse</code> <code>bool</code> <p>Optional. If true, all resources contained in the store are also removed. Defaults to <code>False</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Example <p>To delete a data store, use the following code:</p> <pre><code>geoserver.delete_data_store(\"my_data_store\", workspace=\"my_workspace\")\n</code></pre> Source code in <code>geoserver/geoserver.py</code> <pre><code>def delete_data_store(self, name: str, *, workspace: str, recurse: bool = False) -&gt; str:\n    \"\"\"Remove data store from workspace ws.\n\n    Args:\n        name: The name of the data store to remove.\n        workspace: The name of the workspace containing the data stores.\n        recurse: Optional. If true, all resources contained in the store are also removed. Defaults to `False`.\n\n    Returns:\n        Success message.\n\n    Example:\n        To delete a data store, use the following code:\n\n        ```python\n        geoserver.delete_data_store(\"my_data_store\", workspace=\"my_workspace\")\n        ```\n    \"\"\"\n    url = f\"{self.service_url}/rest/workspaces/{workspace}/datastores/{name}\"\n    params = dict(recurse=recurse)\n    self._request(method=\"delete\", url=url, params=params)\n    return DELETED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.reset_data_store_caches","title":"reset_data_store_caches","text":"<pre><code>reset_data_store_caches(name: str, *, workspace: str) -&gt; str\n</code></pre> <p>Resets caches for this data store. This operation is used to force GeoServer to drop caches associated to this data store, and reconnect to the vector source the next time it is needed by a request. This is useful as the store can keep state, such as a connection pool, and the structure of the feature types it's serving.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the data store.</p> required <code>workspace</code> <code>str</code> <p>The name of the workspace containing the data stores.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Example <p>To reset the caches of a data store, use the following code:</p> <pre><code>geoserver.reset_data_store_caches(\"my_data_store\", workspace=\"my_workspace\")\n</code></pre> Source code in <code>geoserver/geoserver.py</code> <pre><code>def reset_data_store_caches(self, name: str, *, workspace: str) -&gt; str:\n    \"\"\"Resets caches for this data store.\n    This operation is used to force GeoServer to drop caches associated to this data store,\n    and reconnect to the vector source the next time it is needed by a request.\n    This is useful as the store can keep state, such as a connection pool,\n    and the structure of the feature types it's serving.\n\n    Args:\n        name: The name of the data store.\n        workspace: The name of the workspace containing the data stores.\n\n    Returns:\n        Success message.\n\n    Example:\n        To reset the caches of a data store, use the following code:\n\n        ```python\n        geoserver.reset_data_store_caches(\"my_data_store\", workspace=\"my_workspace\")\n        ```\n    \"\"\"\n    url = f\"{self.service_url}/rest/workspaces/{workspace}/datastores/{name}/reset\"\n    self._request(method=\"put\", url=url)  # NOTE: Can also be a POST\n    return OK_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.get_coverages","title":"get_coverages","text":"<pre><code>get_coverages(*, workspace: str, store: Optional[str] = None, list: Optional[str] = None, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_coverages(*, workspace: str, store: Optional[str] = None, list: Optional[str] = None, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_coverages(*, workspace: str, store: Optional[str] = None, list: Optional[str] = None, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>List the coverages available for the provided workspace and data store.</p> <p>Parameters:</p> Name Type Description Default <code>workspace</code> <code>str</code> <p>The name of the workspace containing the data stores.</p> required <code>store</code> <code>Optional[str]</code> <p>Optional. The name of the data store.</p> <code>None</code> <code>list</code> <code>Optional[str]</code> <p>Optional. The list parameter is used to filter over resulting resource names attribute using Java regular expressions.</p> <code>None</code> <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response. It can be either \"json\" or \"xml\".</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The list of all coverages in the workspace and data store.</p> Example <p>To get the list of all coverages in a workspace, use the following code:</p> <pre><code>geoserver.get_coverages(workspace=\"my_workspace\")\n</code></pre> <p>To specify a coverage store, use the following code:</p> <pre><code>geoserver.get_coverages(workspace=\"my_workspace\", store=\"my_coverage_store\")\n</code></pre> Source code in <code>geoserver/geoserver.py</code> <pre><code>def get_coverages(\n    self,\n    *,\n    workspace: str,\n    store: Optional[str] = None,\n    list: Optional[str] = None,\n    format: Literal[\"json\", \"xml\"] = \"json\",\n) -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"List the coverages available for the provided workspace and data store.\n\n    Args:\n        workspace: The name of the workspace containing the data stores.\n        store: Optional. The name of the data store.\n        list: Optional. The list parameter is used to filter over resulting resource names attribute using Java regular expressions.\n        format: Optional. The format of the response. It can be either \"json\" or \"xml\".\n\n    Returns:\n        The list of all coverages in the workspace and data store.\n\n    Example:\n        To get the list of all coverages in a workspace, use the following code:\n\n        ```python\n        geoserver.get_coverages(workspace=\"my_workspace\")\n        ```\n\n        To specify a coverage store, use the following code:\n\n        ```python\n        geoserver.get_coverages(workspace=\"my_workspace\", store=\"my_coverage_store\")\n        ```\n    \"\"\"\n    url = f\"{self.service_url}/rest/workspaces/{workspace}/coverages.{format}\"\n    if store is not None:\n        url = f\"{self.service_url}/rest/workspaces/{workspace}/coveragestores/{store}/coverages.{format}\"\n\n    response = self._request(method=\"get\", url=url, params=dict(list=list))\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.create_coverage","title":"create_coverage","text":"<pre><code>create_coverage(body: Union[str, Dict[str, Any]], *, workspace: str, store: Optional[str] = None) -&gt; str\n</code></pre> <p>Creates a new coverage, the underlying data store must exist.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>Union[str, Dict[str, Any]]</code> <p>The body the coverage to be created.</p> required <code>workspace</code> <code>str</code> <p>The name of the workspace.</p> required <code>store</code> <code>Optional[str]</code> <p>Optional. The name of the coverage store.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The created coverage.</p> Example <p>To create a new coverage, use the following code:</p> <pre><code># Check the GeoServer official documentation for the body structure\nbody = \"...\"\n\ngeoserver.create_coverage(body, workspace=\"my_workspace\", store=\"my_coverage_store\")\n</code></pre> Source code in <code>geoserver/geoserver.py</code> <pre><code>def create_coverage(self, body: Union[str, Dict[str, Any]], *, workspace: str, store: Optional[str] = None) -&gt; str:\n    \"\"\"Creates a new coverage, the underlying data store must exist.\n\n    Args:\n        body: The body the coverage to be created.\n        workspace: The name of the workspace.\n        store: Optional. The name of the coverage store.\n\n    Returns:\n        The created coverage.\n\n    Example:\n        To create a new coverage, use the following code:\n\n        ```python\n        # Check the GeoServer official documentation for the body structure\n        body = \"...\"\n\n        geoserver.create_coverage(body, workspace=\"my_workspace\", store=\"my_coverage_store\")\n        ```\n    \"\"\"\n    url = f\"{self.service_url}/rest/workspaces/{workspace}/coverages\"\n    if store is not None:\n        url = f\"{self.service_url}/rest/workspaces/{workspace}/coveragestores/{store}/coverages\"\n\n    self._request(method=\"post\", url=url, body=body)\n    return CREATED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.get_coverage","title":"get_coverage","text":"<pre><code>get_coverage(name: str, *, workspace: str, store: Optional[str] = None, quiet_on_not_found: bool = False, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_coverage(name: str, *, workspace: str, store: Optional[str] = None, quiet_on_not_found: bool = False, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_coverage(name: str, *, workspace: str, store: Optional[str] = None, quiet_on_not_found: bool = False, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>Get an individual coverage.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the coverage.</p> required <code>workspace</code> <code>str</code> <p>The name of the workspace.</p> required <code>store</code> <code>Optional[str]</code> <p>Optional. The name of the coverage datastore. Defaults to None.</p> <code>None</code> <code>quiet_on_not_found</code> <code>bool</code> <p>Optional. If true, the server will not report an error if the coverage is not found.</p> <code>False</code> <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The requested coverage.</p> Example <p>To get a coverage, use the following code:</p> <pre><code>geoserver.get_coverage(\"my_coverage\", workspace=\"my_workspace\")\n</code></pre> <p>To specify a coverage store, use the following code:</p> <pre><code>geoserver.get_coverage(\"my_coverage\", workspace=\"my_workspace\", store=\"my_coverage_store\")\n</code></pre> Source code in <code>geoserver/geoserver.py</code> <pre><code>def get_coverage(\n    self,\n    name: str,\n    *,\n    workspace: str,\n    store: Optional[str] = None,\n    quiet_on_not_found: bool = False,\n    format: Literal[\"json\", \"xml\"] = \"json\",\n) -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"Get an individual coverage.\n\n    Args:\n        name: The name of the coverage.\n        workspace: The name of the workspace.\n        store: Optional. The name of the coverage datastore. Defaults to None.\n        quiet_on_not_found: Optional. If true, the server will not report an error if the coverage is not found.\n        format: Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".\n\n    Returns:\n        The requested coverage.\n\n    Example:\n        To get a coverage, use the following code:\n\n        ```python\n        geoserver.get_coverage(\"my_coverage\", workspace=\"my_workspace\")\n        ```\n\n        To specify a coverage store, use the following code:\n\n        ```python\n        geoserver.get_coverage(\"my_coverage\", workspace=\"my_workspace\", store=\"my_coverage_store\")\n        ```\n    \"\"\"\n    url = f\"{self.service_url}/rest/workspaces/{workspace}/coverages/{name}.{format}\"\n    if store is not None:\n        url = f\"{self.service_url}/rest/workspaces/{workspace}/coveragestores/{store}/coverages/{name}.{format}\"\n\n    response = self._request(method=\"get\", url=url, params=dict(quietOnNotFound=quiet_on_not_found))\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.get_coverage_index","title":"get_coverage_index","text":"<pre><code>get_coverage_index(name: str, *, workspace: str, store: Optional[str] = None, quiet_on_not_found: bool = False, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_coverage_index(name: str, *, workspace: str, store: Optional[str] = None, quiet_on_not_found: bool = False, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_coverage_index(name: str, *, workspace: str, store: Optional[str] = None, quiet_on_not_found: bool = False, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>Get an individual coverage index structure.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the coverage.</p> required <code>workspace</code> <code>str</code> <p>The name of the workspace.</p> required <code>store</code> <code>Optional[str]</code> <p>Optional. The name of the coverage datastore. Defaults to None.</p> <code>None</code> <code>quiet_on_not_found</code> <code>bool</code> <p>Optional. If true, the server will not report an error if the coverage is not found.</p> <code>False</code> <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The requested coverage.</p> Example <p>To get a coverage index, use the following code:</p> <pre><code>geoserver.get_coverage_index(\"my_coverage\", workspace=\"my_workspace\")\n</code></pre> <p>To specify a coverage store, use the following code:</p> <pre><code>geoserver.get_coverage_index(\"my_coverage\", workspace=\"my_workspace\", store=\"my_coverage_store\")\n</code></pre> Source code in <code>geoserver/geoserver.py</code> <pre><code>def get_coverage_index(\n    self,\n    name: str,\n    *,\n    workspace: str,\n    store: Optional[str] = None,\n    quiet_on_not_found: bool = False,\n    format: Literal[\"json\", \"xml\"] = \"json\",\n) -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"Get an individual coverage index structure.\n\n    Args:\n        name: The name of the coverage.\n        workspace: The name of the workspace.\n        store: Optional. The name of the coverage datastore. Defaults to None.\n        quiet_on_not_found: Optional. If true, the server will not report an error if the coverage is not found.\n        format: Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".\n\n    Returns:\n        The requested coverage.\n\n    Example:\n        To get a coverage index, use the following code:\n\n        ```python\n        geoserver.get_coverage_index(\"my_coverage\", workspace=\"my_workspace\")\n        ```\n\n        To specify a coverage store, use the following code:\n\n        ```python\n        geoserver.get_coverage_index(\"my_coverage\", workspace=\"my_workspace\", store=\"my_coverage_store\")\n        ```\n    \"\"\"\n    url = f\"{self.service_url}/rest/workspaces/{workspace}/coverages/{name}/index.{format}\"\n    if store is not None:\n        url = (\n            f\"{self.service_url}/rest/workspaces/{workspace}/coveragestores/{store}/coverages/{name}/index.{format}\"\n        )\n\n    response = self._request(method=\"get\", url=url, params=dict(quietOnNotFound=quiet_on_not_found))\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.update_coverage","title":"update_coverage","text":"<pre><code>update_coverage(name: str, body: Union[str, Dict[str, Any]], *, workspace: str, store: str) -&gt; str\n</code></pre> <p>Update an individual coverage</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the coverage.</p> required <code>body</code> <code>Union[str, Dict[str, Any]]</code> <p>The body of the request used to update the coverage.</p> required <code>workspace</code> <code>str</code> <p>The name of the workspace.</p> required <code>store</code> <code>str</code> <p>The name of the coverage datastore</p> required <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Example <p>To update a coverage, use the following code:</p> <pre><code># Check the GeoServer official documentation for the body structure\nbody = \"...\"\n\ngeoserver.update_coverage(\"my_coverage\", body, workspace=\"my_workspace\", store=\"my_coverage_store\")\n</code></pre> Source code in <code>geoserver/geoserver.py</code> <pre><code>def update_coverage(self, name: str, body: Union[str, Dict[str, Any]], *, workspace: str, store: str) -&gt; str:\n    \"\"\"Update an individual coverage\n\n    Args:\n        name: The name of the coverage.\n        body: The body of the request used to update the coverage.\n        workspace: The name of the workspace.\n        store: The name of the coverage datastore\n\n    Returns:\n        Success message.\n\n    Example:\n        To update a coverage, use the following code:\n\n        ```python\n        # Check the GeoServer official documentation for the body structure\n        body = \"...\"\n\n        geoserver.update_coverage(\"my_coverage\", body, workspace=\"my_workspace\", store=\"my_coverage_store\")\n        ```\n    \"\"\"\n    url = f\"{self.service_url}/rest/workspaces/{workspace}/coveragestores/{store}/coverages/{name}\"\n    self._request(method=\"put\", url=url, body=body)\n    return UPDATED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.delete_coverage","title":"delete_coverage","text":"<pre><code>delete_coverage(name: str, *, workspace: str, store: str, recurse: bool = False) -&gt; str\n</code></pre> <p>Delete a coverage (optionally recursively deleting layers).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the coverage.</p> required <code>workspace</code> <code>str</code> <p>The name of the workspace.</p> required <code>store</code> <code>str</code> <p>The name of the coverage datastore</p> required <code>recurse</code> <code>bool</code> <p>Optional. If true all stores containing the resource are also removed.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Example <p>To delete a coverage, use the following code:</p> <pre><code>geoserver.delete_coverage(\"my_coverage\", workspace=\"my_workspace\", store=\"my_coverage_store\")\n</code></pre> Source code in <code>geoserver/geoserver.py</code> <pre><code>def delete_coverage(self, name: str, *, workspace: str, store: str, recurse: bool = False) -&gt; str:\n    \"\"\"Delete a coverage (optionally recursively deleting layers).\n\n    Args:\n        name: The name of the coverage.\n        workspace: The name of the workspace.\n        store: The name of the coverage datastore\n        recurse: Optional. If true all stores containing the resource are also removed.\n\n    Returns:\n        Success message.\n\n    Example:\n        To delete a coverage, use the following code:\n\n        ```python\n        geoserver.delete_coverage(\"my_coverage\", workspace=\"my_workspace\", store=\"my_coverage_store\")\n        ```\n    \"\"\"\n    url = f\"{self.service_url}/rest/workspaces/{workspace}/coveragestores/{store}/coverages/{name}\"\n    params = dict(recurse=recurse)\n    self._request(method=\"delete\", url=url, params=params)\n    return DELETED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.reset_coverage_caches","title":"reset_coverage_caches","text":"<pre><code>reset_coverage_caches(name: str, *, workspace: str, store: str) -&gt; str\n</code></pre> <p>Resets raster caches for this coverage. This operation is used to force GeoServer to drop caches associated to this coverage, and reconnect to the raster source the next time it is needed by a request. This is useful as the readers often cache some information about the bounds, coordinate system and image structure that might have changed in the meantime. Warning, the band structure is stored as part of the coverage configuration and won't be modified by this call, in case of need it should be modified issuing a PUT request against the coverage resource itself.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the coverage.</p> required <code>workspace</code> <code>str</code> <p>The name of the workspace.</p> required <code>store</code> <code>str</code> <p>The name of the coverage datastore</p> required <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Example <p>To reset the caches of a coverage, use the following code:</p> <pre><code>geoserver.reset_coverage_caches(\"my_coverage\", workspace=\"my_workspace\", store=\"my_coverage_store\")\n</code></pre> Source code in <code>geoserver/geoserver.py</code> <pre><code>def reset_coverage_caches(self, name: str, *, workspace: str, store: str) -&gt; str:\n    \"\"\"Resets raster caches for this coverage.\n    This operation is used to force GeoServer to drop caches associated to this coverage,\n    and reconnect to the raster source the next time it is needed by a request.\n    This is useful as the readers often cache some information about the bounds,\n    coordinate system and image structure that might have changed in the meantime.\n    Warning, the band structure is stored as part of the coverage configuration and won't be modified by this call,\n    in case of need it should be modified issuing a PUT request against the coverage resource itself.\n\n    Args:\n        name: The name of the coverage.\n        workspace: The name of the workspace.\n        store: The name of the coverage datastore\n\n    Returns:\n        Success message.\n\n    Example:\n        To reset the caches of a coverage, use the following code:\n\n        ```python\n        geoserver.reset_coverage_caches(\"my_coverage\", workspace=\"my_workspace\", store=\"my_coverage_store\")\n        ```\n    \"\"\"\n    url = f\"{self.service_url}/rest/workspaces/{workspace}/coveragestores/{store}/coverages/{name}/reset\"\n    self._request(method=\"put\", url=url)  # NOTE: Can also be a POST\n    return OK_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.get_coverage_stores","title":"get_coverage_stores","text":"<pre><code>get_coverage_stores(*, workspace: str, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_coverage_stores(*, workspace: str, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_coverage_stores(*, workspace: str, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>Displays a list of all styles on the server.</p> <p>Parameters:</p> Name Type Description Default <code>workspace</code> <code>str</code> <p>The name of the workspace.</p> required <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The list of all coverage stores in the workspace.</p> Example <p>To get the list of all coverage stores in a workspace, use the following code:</p> <pre><code>geoserver.get_coverage_stores(workspace=\"my_workspace\")\n</code></pre> Source code in <code>geoserver/geoserver.py</code> <pre><code>def get_coverage_stores(\n    self, *, workspace: str, format: Literal[\"json\", \"xml\"] = \"json\"\n) -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"Displays a list of all styles on the server.\n\n    Args:\n        workspace: The name of the workspace.\n        format: Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".\n\n    Returns:\n        The list of all coverage stores in the workspace.\n\n    Example:\n        To get the list of all coverage stores in a workspace, use the following code:\n\n        ```python\n        geoserver.get_coverage_stores(workspace=\"my_workspace\")\n        ```\n    \"\"\"\n    url = f\"{self.service_url}/rest/workspaces/{workspace}/coveragestores.{format}\"\n    response = self._request(method=\"get\", url=url)\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.coveragestore_exists","title":"coveragestore_exists","text":"<pre><code>coveragestore_exists(name: str, *, workspace: str) -&gt; bool\n</code></pre> <p>Check if a coverage store exists in a workspace.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the coverage store.</p> required <code>workspace</code> <code>str</code> <p>The name of the workspace containing the coverage stores.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the coverage store exists, False otherwise.</p> Example <p>To check if a coverage store exists in a workspace, use the following code:</p> <pre><code>geoserver.coveragestore_exists(\"my_coverage_store\", workspace=\"my_workspace\")\n</code></pre> Source code in <code>geoserver/geoserver.py</code> <pre><code>def coveragestore_exists(self, name: str, *, workspace: str) -&gt; bool:\n    \"\"\"Check if a coverage store exists in a workspace.\n\n    Args:\n        name: The name of the coverage store.\n        workspace: The name of the workspace containing the coverage stores.\n\n    Returns:\n        True if the coverage store exists, False otherwise.\n\n    Example:\n        To check if a coverage store exists in a workspace, use the following code:\n\n        ```python\n        geoserver.coveragestore_exists(\"my_coverage_store\", workspace=\"my_workspace\")\n        ```\n    \"\"\"\n    url = f\"{self.service_url}/rest/workspaces/{workspace}/coveragestores/{name}.xml\"\n    response = self._request(method=\"head\", url=url, ignore=[404])\n    return response.status_code == 200\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.create_coverage_store","title":"create_coverage_store","text":"<pre><code>create_coverage_store(body: Union[str, Dict[str, Any]], *, workspace: str) -&gt; str\n</code></pre> <p>Adds a new coverage store.</p> Warning <p>It is preferred to use the <code>upload_coverage_store</code> method to upload a new coverage store.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>Union[str, Dict[str, Any]]</code> <p>The body of the request used to create the coverage store.</p> required <code>workspace</code> <code>str</code> <p>The name of the workspace.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Example <p>To create a new coverage store, use the following code:</p> <pre><code># Check the GeoServer official documentation for the body structure\nbody = \"...\"\n\ngeoserver.create_coverage_store(body, workspace=\"my_workspace\")\n</code></pre> Source code in <code>geoserver/geoserver.py</code> <pre><code>def create_coverage_store(self, body: Union[str, Dict[str, Any]], *, workspace: str) -&gt; str:\n    \"\"\"Adds a new coverage store.\n\n    Warning:\n        It is preferred to use the `upload_coverage_store` method to upload a new coverage store.\n\n    Args:\n        body: The body of the request used to create the coverage store.\n        workspace: The name of the workspace.\n\n    Returns:\n        Success message.\n\n    Example:\n        To create a new coverage store, use the following code:\n\n        ```python\n        # Check the GeoServer official documentation for the body structure\n        body = \"...\"\n\n        geoserver.create_coverage_store(body, workspace=\"my_workspace\")\n        ```\n    \"\"\"\n    url = f\"{self.service_url}/rest/workspaces/{workspace}/coveragestores\"\n    self._request(method=\"post\", url=url, body=body)\n    return CREATED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.upload_coverage_store","title":"upload_coverage_store","text":"<pre><code>upload_coverage_store(file: Union[str, Path, BufferedReader], *, workspace: str, name: Optional[str] = None, method: Literal['auto', 'file', 'external', 'url', 'remote'] = 'auto', format: Literal['geotiff', 'worldimage', 'imagemosaic'], update_bbox: bool = False, configure: Literal['none', 'all'] = 'all', use_jai_imageread: bool = False, coverage_name: Optional[str] = None, filename: Optional[str] = None) -&gt; str\n</code></pre> <p>Adds a new or update an existing coverage store from a local file.</p> Tip <p>This method is the preferred way to upload a new coverage store.</p> Note <p>The <code>store</code> parameter is automatically inferred from the file, if not provided. In case the file is a buffer, the <code>store</code> parameter is required.</p> Note <p>The file name of the resource can be overwritten by: - Providing the <code>filename</code> parameter. - Using the <code>store</code> parameter. In this case, if the <code>filename</code> is not provided,     the file name will be the same as the store name.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Union[str, Path, BufferedReader]</code> <p>The file to upload.</p> required <code>workspace</code> <code>str</code> <p>The name of the workspace.</p> required <code>name</code> <code>Optional[str]</code> <p>Optional. The name of the coverage store.</p> <code>None</code> <code>filename</code> <code>Optional[str]</code> <p>Optional. The filename parameter specifies the target file name for a file that needs to be harvested as part of a mosaic. This is important to avoid clashes and to make sure the right dimension values are available in the name for multidimensional mosaics to work. Only used if method=\"file\".</p> <code>None</code> <code>format</code> <code>Literal['geotiff', 'worldimage', 'imagemosaic']</code> <p>The type of the file. Must be one of \"geotiff\", \"worldimage\", or \"imagemosaic\".</p> required <code>update_bbox</code> <code>bool</code> <p>When set to <code>True</code>, triggers re-calculation of the layer native bbox. Defaults to <code>False</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Example <p>To upload a new coverage store from a local file, use the following code:</p> <pre><code>geoserver.upload_coverage_store(\"my_coverage_store.zip\", workspace=\"my_workspace\", name=\"my_coverage_store\", format=\"geotiff\")\n</code></pre> <p>Or, using a buffer:</p> <pre><code>with open(\"my_coverage_store.zip\", \"rb\") as f:\n    geoserver.upload_coverage_store(f, workspace=\"my_workspace\", name=\"my_coverage_store\", format=\"geotiff\")\n</code></pre> Source code in <code>geoserver/geoserver.py</code> <pre><code>def upload_coverage_store(\n    self,\n    file: Union[str, Path, BufferedReader],\n    *,\n    workspace: str,\n    name: Optional[str] = None,\n    method: Literal[\"auto\", \"file\", \"external\", \"url\", \"remote\"] = \"auto\",\n    format: Literal[\"geotiff\", \"worldimage\", \"imagemosaic\"],\n    update_bbox: bool = False,\n    configure: Literal[\"none\", \"all\"] = \"all\",\n    use_jai_imageread: bool = False,\n    coverage_name: Optional[str] = None,\n    filename: Optional[str] = None,\n) -&gt; str:\n    \"\"\"Adds a new or update an existing coverage store from a local file.\n\n    Tip:\n        This method is the preferred way to upload a new coverage store.\n\n    Note:\n        The `store` parameter is automatically inferred from the file, if not provided.\n        In case the file is a buffer, the `store` parameter is required.\n\n    Note:\n        The file name of the resource can be overwritten by:\n        - Providing the `filename` parameter.\n        - Using the `store` parameter. In this case, if the `filename` is not provided,\n            the file name will be the same as the store name.\n\n    Args:\n        file: The file to upload.\n        workspace: The name of the workspace.\n        name: Optional. The name of the coverage store.\n        filename:  Optional. The filename parameter specifies the target file name for a file that needs to be harvested as part of a mosaic.\n            This is important to avoid clashes and to make sure the right dimension values are available in the name for multidimensional mosaics to work.\n            Only used if method=\"file\".\n        format: The type of the file. Must be one of \"geotiff\", \"worldimage\", or \"imagemosaic\".\n        update_bbox: When set to `True`, triggers re-calculation of the layer native bbox. Defaults to `False`.\n\n    Returns:\n        Success message.\n\n    Example:\n        To upload a new coverage store from a local file, use the following code:\n\n        ```python\n        geoserver.upload_coverage_store(\"my_coverage_store.zip\", workspace=\"my_workspace\", name=\"my_coverage_store\", format=\"geotiff\")\n        ```\n\n        Or, using a buffer:\n\n        ```python\n        with open(\"my_coverage_store.zip\", \"rb\") as f:\n            geoserver.upload_coverage_store(f, workspace=\"my_workspace\", name=\"my_coverage_store\", format=\"geotiff\")\n        ```\n    \"\"\"\n    if isinstance(file, Path):\n        file = file.as_posix()\n    if isinstance(file, str):\n        name = name or Path(file).stem\n        filename = filename or f\"{name}.{Path(file).suffix[1:]}\"\n\n    if name is None:\n        raise ValueError(\"The `name` parameter is required\")\n\n    headers = {}\n    if zipfile.is_zipfile(file):\n        headers[\"Content-Type\"] = \"application/zip\"\n\n    params = dict(\n        update=update_bbox,\n        filename=filename,\n        configure=configure,\n        USE_JAI_IMAGEREAD=use_jai_imageread,\n        coverage_name=coverage_name,\n    )\n\n    if method == \"auto\":\n        if isinstance(file, str) and file.startswith((\"file:\")):\n            method = \"external\"\n        elif isinstance(file, str) and file.startswith((\"http://\", \"https://\")):\n            method = \"url\"\n\n    if isinstance(file, str) and method in [\"external\", \"url\", \"remote\"]:\n        headers[\"Content-Type\"] = \"text/plain\"\n        url = f\"{self.service_url}/rest/workspaces/{workspace}/coveragestores/{name}/{method}.{format}\"\n        self._request(method=\"put\", url=url, data=file, params=params, headers=headers)\n        return CREATED_MESSAGE\n\n    url = f\"{self.service_url}/rest/workspaces/{workspace}/coveragestores/{name}/file.{format}\"\n    self._request(method=\"put\", url=url, file=file, params=params, headers=headers)\n    return CREATED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.get_coverage_store","title":"get_coverage_store","text":"<pre><code>get_coverage_store(name: str, *, workspace: str, quiet_on_not_found: bool = False, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_coverage_store(name: str, *, workspace: str, quiet_on_not_found: bool = False, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_coverage_store(name: str, *, workspace: str, quiet_on_not_found: bool = False, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>Get an individual coverage store.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the coverage store.</p> required <code>workspace</code> <code>str</code> <p>The name of the workspace.</p> required <code>quiet_on_not_found</code> <code>bool</code> <p>Optional. If true, the server will not report an error if the coverage store is not found.</p> <code>False</code> <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The requested coverage store.</p> Example <p>To get a coverage store, use the following code:</p> <pre><code>geoserver.get_coverage_store(\"my_coverage_store\", workspace=\"my_workspace\")\n</code></pre> Source code in <code>geoserver/geoserver.py</code> <pre><code>def get_coverage_store(\n    self, name: str, *, workspace: str, quiet_on_not_found: bool = False, format: Literal[\"json\", \"xml\"] = \"json\"\n) -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"Get an individual coverage store.\n\n    Args:\n        name: The name of the coverage store.\n        workspace: The name of the workspace.\n        quiet_on_not_found: Optional. If true, the server will not report an error if the coverage store is not found.\n        format: Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".\n\n    Returns:\n        The requested coverage store.\n\n    Example:\n        To get a coverage store, use the following code:\n\n        ```python\n        geoserver.get_coverage_store(\"my_coverage_store\", workspace=\"my_workspace\")\n        ```\n    \"\"\"\n    url = f\"{self.service_url}/rest/workspaces/{workspace}/coveragestores/{name}.{format}\"\n    response = self._request(method=\"get\", url=url, params=dict(quietOnNotFound=quiet_on_not_found))\n    return response.json()\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.update_coverage_store","title":"update_coverage_store","text":"<pre><code>update_coverage_store(name: str, body: Union[str, Dict[str, Any]], *, workspace: str) -&gt; str\n</code></pre> <p>Modifies a single coverage store.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the coverage store.</p> required <code>body</code> <code>Union[str, Dict[str, Any]]</code> <p>The body of the request used to update the coverage store.</p> required <code>workspace</code> <code>str</code> <p>The name of the workspace.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Example <p>To update a coverage store, use the following code:</p> <pre><code># Check the GeoServer official documentation for the body structure\nbody = \"...\"\n\ngeoserver.update_coverage_store(\"my_coverage_store\", body, workspace=\"my_workspace\")\n</code></pre> Source code in <code>geoserver/geoserver.py</code> <pre><code>def update_coverage_store(self, name: str, body: Union[str, Dict[str, Any]], *, workspace: str) -&gt; str:\n    \"\"\"Modifies a single coverage store.\n\n    Args:\n        name: The name of the coverage store.\n        body: The body of the request used to update the coverage store.\n        workspace: The name of the workspace.\n\n    Returns:\n        Success message.\n\n    Example:\n        To update a coverage store, use the following code:\n\n        ```python\n        # Check the GeoServer official documentation for the body structure\n        body = \"...\"\n\n        geoserver.update_coverage_store(\"my_coverage_store\", body, workspace=\"my_workspace\")\n        ```\n    \"\"\"\n    url = f\"{self.service_url}/rest/workspaces/{workspace}/coveragestores/{name}\"\n    self._request(method=\"put\", url=url, body=body)\n    return UPDATED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.delete_coverage_store","title":"delete_coverage_store","text":"<pre><code>delete_coverage_store(name: str, *, workspace: str, purge: Literal['none', 'metadata', 'all'] = 'all', recurse: bool = False) -&gt; str\n</code></pre> <p>Deletes a coverage store.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the coverage store.</p> required <code>workspace</code> <code>str</code> <p>The name of the workspace.</p> required <code>purge</code> <code>Literal['none', 'metadata', 'all']</code> <p>Optional. The purge parameter specifies if and how the underlying raster data source is deleted. When set to \"none\" data and auxiliary files are preserved. When set to \"metadata\" delete only auxiliary files and metadata. It's recommended when data files (such as granules) should not be deleted from disk. Finally, when set to \"all both data and auxiliary files are removed. Defaults to \"none\".</p> <code>'all'</code> <code>recurse</code> <code>bool</code> <p>Optional. The recurse controls recursive deletion. When set to true all resources contained in the store are also removed. The default to false.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Example <p>To delete a coverage store, use the following code:</p> <pre><code>geoserver.delete_coverage_store(\"my_coverage_store\", workspace=\"my_workspace\")\n</code></pre> <p>To remove all resources contained in the store, use the following code:</p> <pre><code>geoserver.delete_coverage_store(\"my_coverage_store\", workspace=\"my_workspace\", recurse=True)\n</code></pre> Source code in <code>geoserver/geoserver.py</code> <pre><code>def delete_coverage_store(\n    self, name: str, *, workspace: str, purge: Literal[\"none\", \"metadata\", \"all\"] = \"all\", recurse: bool = False\n) -&gt; str:\n    \"\"\"Deletes a coverage store.\n\n    Args:\n        name: The name of the coverage store.\n        workspace: The name of the workspace.\n        purge: Optional. The purge parameter specifies if and how the underlying raster data source is deleted.\n            When set to \"none\" data and auxiliary files are preserved.\n            When set to \"metadata\" delete only auxiliary files and metadata.\n            It's recommended when data files (such as granules) should not be deleted from disk.\n            Finally, when set to \"all both data and auxiliary files are removed.\n            Defaults to \"none\".\n        recurse: Optional. The recurse controls recursive deletion.\n            When set to true all resources contained in the store are also removed.\n            The default to false.\n\n    Returns:\n        Success message.\n\n    Example:\n        To delete a coverage store, use the following code:\n\n        ```python\n        geoserver.delete_coverage_store(\"my_coverage_store\", workspace=\"my_workspace\")\n        ```\n\n        To remove all resources contained in the store, use the following code:\n\n        ```python\n        geoserver.delete_coverage_store(\"my_coverage_store\", workspace=\"my_workspace\", recurse=True)\n        ```\n    \"\"\"\n    url = f\"{self.service_url}/rest/workspaces/{workspace}/coveragestores/{name}\"\n    params = dict(purge=purge, recurse=recurse)\n    self._request(method=\"delete\", url=url, params=params)\n    return DELETED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.reset_coverage_store_caches","title":"reset_coverage_store_caches","text":"<pre><code>reset_coverage_store_caches(name: str, *, workspace: str) -&gt; str\n</code></pre> <p>Resets raster caches for this coverage store. This operation is used to force GeoServer to drop caches associated to this coverage store, and reconnect to the raster source the next time it is needed by a request. This is useful as the readers often cache some information about the bounds, coordinate system and image structure that might have changed in the meantime.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the coverage store.</p> required <code>workspace</code> <code>str</code> <p>The name of the workspace.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Example <p>To reset the caches of a coverage store, use the following code:</p> <pre><code>geoserver.reset_coverage_store_caches(\"my_coverage_store\", workspace=\"my_workspace\")\n</code></pre> Source code in <code>geoserver/geoserver.py</code> <pre><code>def reset_coverage_store_caches(self, name: str, *, workspace: str) -&gt; str:\n    \"\"\"Resets raster caches for this coverage store.\n    This operation is used to force GeoServer to drop caches associated to this coverage store,\n    and reconnect to the raster source the next time it is needed by a request.\n    This is useful as the readers often cache some information about the bounds,\n    coordinate system and image structure that might have changed in the meantime.\n\n    Args:\n        name: The name of the coverage store.\n        workspace: The name of the workspace.\n\n    Returns:\n        Success message.\n\n    Example:\n        To reset the caches of a coverage store, use the following code:\n\n        ```python\n        geoserver.reset_coverage_store_caches(\"my_coverage_store\", workspace=\"my_workspace\")\n        ```\n    \"\"\"\n    url = f\"{self.service_url}/rest/workspaces/{workspace}/coveragestores/{name}/reset\"\n    self._request(method=\"put\", url=url)\n    return OK_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.get_feature_types","title":"get_feature_types","text":"<pre><code>get_feature_types(*, workspace: str, store: Optional[str] = None, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_feature_types(*, workspace: str, store: Optional[str] = None, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_feature_types(*, workspace: str, store: Optional[str] = None, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>List all feature types in the workspace.</p> <p>Parameters:</p> Name Type Description Default <code>workspace</code> <code>str</code> <p>The name of the workspace.</p> required <code>store</code> <code>Optional[str]</code> <p>The name of the data store.</p> <code>None</code> <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The list of all feature types in the workspace.</p> Example <p>To get the list of all feature types in a workspace, use the following code:</p> <pre><code>geoserver.get_feature_types(workspace=\"my_workspace\")\n</code></pre> Source code in <code>geoserver/geoserver.py</code> <pre><code>def get_feature_types(\n    self, *, workspace: str, store: Optional[str] = None, format: Literal[\"json\", \"xml\"] = \"json\"\n) -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"List all feature types in the workspace.\n\n    Args:\n        workspace: The name of the workspace.\n        store: The name of the data store.\n        format: Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".\n\n    Returns:\n        The list of all feature types in the workspace.\n\n    Example:\n        To get the list of all feature types in a workspace, use the following code:\n\n        ```python\n        geoserver.get_feature_types(workspace=\"my_workspace\")\n        ```\n    \"\"\"\n    url = f\"{self.service_url}/rest/workspaces/{workspace}/featuretypes.{format}\"\n    if store is not None:\n        url = f\"{self.service_url}/rest/workspaces/{workspace}/datastores/{store}/featuretypes.{format}\"\n\n    response = self._request(method=\"get\", url=url)\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.create_feature_type","title":"create_feature_type","text":"<pre><code>create_feature_type(body: Union[str, Dict[str, Any]], *, workspace: str, store: Optional[str] = None) -&gt; str\n</code></pre> <p>Create a new feature type.</p> Note <p>When creating a new feature type via POST, if no underlying dataset with the specified name exists an attempt will be made to create it. This will work only in cases where the underlying data format supports the creation of new types (such as a database). When creating a feature type in this manner the client should include all attribute information in the feature type representation.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>Union[str, Dict[str, Any]]</code> <p>The body of the request used to create the feature type.</p> required <code>workspace</code> <code>str</code> <p>The name of the workspace.</p> required <code>store</code> <code>Optional[str]</code> <p>Optional. The name of the data store.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Example <p>To create a new feature type, use the following code:</p> <pre><code># Check the GeoServer official documentation for the body structure\nbody = \"...\"\n\ngeoserver.create_feature_type(body, workspace=\"my_workspace\", store=\"my_data_store\")\n</code></pre> Source code in <code>geoserver/geoserver.py</code> <pre><code>def create_feature_type(\n    self, body: Union[str, Dict[str, Any]], *, workspace: str, store: Optional[str] = None\n) -&gt; str:\n    \"\"\"Create a new feature type.\n\n    Note:\n        When creating a new feature type via POST, if no underlying dataset\n        with the specified name exists an attempt will be made to create it.\n        This will work only in cases where the underlying data format supports the creation of new types (such as a database).\n        When creating a feature type in this manner the client should include all attribute information\n        in the feature type representation.\n\n    Args:\n        body: The body of the request used to create the feature type.\n        workspace: The name of the workspace.\n        store: Optional. The name of the data store.\n\n    Returns:\n        Success message.\n\n    Example:\n        To create a new feature type, use the following code:\n\n        ```python\n        # Check the GeoServer official documentation for the body structure\n        body = \"...\"\n\n        geoserver.create_feature_type(body, workspace=\"my_workspace\", store=\"my_data_store\")\n        ```\n    \"\"\"\n    url = f\"{self.service_url}/rest/workspaces/{workspace}/featuretypes\"\n    if store is not None:\n        url = f\"{self.service_url}/rest/workspaces/{workspace}/datastores/{store}/featuretypes\"\n\n    self._request(method=\"post\", url=url, body=body)\n    return CREATED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.get_feature_type","title":"get_feature_type","text":"<pre><code>get_feature_type(name: str, *, workspace: str, store: Optional[str] = None, quiet_on_not_found: bool = False, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_feature_type(name: str, *, workspace: str, store: Optional[str] = None, quiet_on_not_found: bool = False, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_feature_type(name: str, *, workspace: str, store: Optional[str] = None, quiet_on_not_found: bool = False, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>Get an individual feature type.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the feature type.</p> required <code>workspace</code> <code>str</code> <p>The name of the workspace.</p> required <code>store</code> <code>Optional[str]</code> <p>Optional. The name of the data store.</p> <code>None</code> <code>quiet_on_not_found</code> <code>bool</code> <p>Optional. If true, the server will not report an error if the feature type is not found.</p> <code>False</code> <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The requested feature type.</p> Example <p>To get a feature type, use the following code:</p> <pre><code>geoserver.get_feature_type(\"my_feature_type\", workspace=\"my_workspace\")\n</code></pre> Source code in <code>geoserver/geoserver.py</code> <pre><code>def get_feature_type(\n    self,\n    name: str,\n    *,\n    workspace: str,\n    store: Optional[str] = None,\n    quiet_on_not_found: bool = False,\n    format: Literal[\"json\", \"xml\"] = \"json\",\n) -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"Get an individual feature type.\n\n    Args:\n        name: The name of the feature type.\n        workspace: The name of the workspace.\n        store: Optional. The name of the data store.\n        quiet_on_not_found: Optional. If true, the server will not report an error if the feature type is not found.\n        format: Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".\n\n    Returns:\n        The requested feature type.\n\n    Example:\n        To get a feature type, use the following code:\n\n        ```python\n        geoserver.get_feature_type(\"my_feature_type\", workspace=\"my_workspace\")\n        ```\n    \"\"\"\n    url = f\"{self.service_url}/rest/workspaces/{workspace}/featuretypes/{name}.{format}\"\n    if store is not None:\n        url = f\"{self.service_url}/rest/workspaces/{workspace}/datastores/{store}/featuretypes/{name}.{format}\"\n\n    response = self._request(method=\"get\", url=url, params=dict(quietOnNotFound=quiet_on_not_found))\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.update_feature_type","title":"update_feature_type","text":"<pre><code>update_feature_type(name: str, body: Union[str, Dict[str, Any]], *, workspace: str, store: Optional[str] = None, recalculate: Literal['', 'nativebbox', 'nativebbox,latlonbbox'] = '') -&gt; str\n</code></pre> <p>Update an individual feature type.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the feature type.</p> required <code>body</code> <code>Union[str, Dict[str, Any]]</code> <p>The body of the request used to modify the feature type.</p> required <code>workspace</code> <code>str</code> <p>The name of the workspace.</p> required <code>store</code> <code>Optional[str]</code> <p>Optional. The name of the data store.</p> <code>None</code> <code>recalculate</code> <code>Literal['', 'nativebbox', 'nativebbox,latlonbbox']</code> <p>Optional. Specifies whether to recalculate properties for a feature type. Some properties of feature types are automatically recalculated when necessary. In particular, the native bounding box is recalculated when the projection or projection policy are changed, and the lat/lon bounding box is recalculated when the native bounding box is recalculated, or when a new native bounding box is explicitly provided in the request. (The native and lat/lon bounding boxes are not automatically recalculated when they are explicitly included in the request.) In addition, the client may explicitly request a fixed set of fields to calculate, by including a comma-separated list of their names in the recalculate parameter. The empty parameter 'recalculate=' is useful avoid slow recalculation when operating against large datasets as 'recalculate=' avoids calculating any fields, regardless of any changes to projection, projection policy, etc. The nativebbox parameter 'recalculate=nativebbox' is used recalculates the native bounding box, while avoiding recalculating the lat/lon bounding box. Recalculate parameters can be used in together - 'recalculate=nativebbox,latlonbbox' can be used after a bulk import to recalculate both the native bounding box and the lat/lon bounding box. Finally, 'recalculate=attributes' can be used to reset the attributes and reload them from the original vector source. Pay attention to its usage, if attributes were explicitly configured to perform attribute selection, renaming, and other transformations, such configuration will be lost, resetting the feature type to the list of attributes found in the vector data source.</p> <code>''</code> <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Example <p>To update a feature type, use the following code:</p> <pre><code># Check the GeoServer official documentation for the body structure\nbody = \"...\"\n\ngeoserver.update_feature_type(\"my_feature_type\", body, workspace=\"my_workspace\")\n</code></pre> Source code in <code>geoserver/geoserver.py</code> <pre><code>def update_feature_type(\n    self,\n    name: str,\n    body: Union[str, Dict[str, Any]],\n    *,\n    workspace: str,\n    store: Optional[str] = None,\n    recalculate: Literal[\"\", \"nativebbox\", \"nativebbox,latlonbbox\"] = \"\",\n) -&gt; str:\n    \"\"\"Update an individual feature type.\n\n    Args:\n        name: The name of the feature type.\n        body: The body of the request used to modify the feature type.\n        workspace: The name of the workspace.\n        store: Optional. The name of the data store.\n        recalculate: Optional. Specifies whether to recalculate properties for a feature type.\n            Some properties of feature types are automatically recalculated when necessary.\n            In particular, the native bounding box is recalculated when the projection or projection policy are changed,\n            and the lat/lon bounding box is recalculated when the native bounding box is recalculated,\n            or when a new native bounding box is explicitly provided in the request.\n            (The native and lat/lon bounding boxes are not automatically recalculated when they are explicitly included in the request.)\n            In addition, the client may explicitly request a fixed set of fields to calculate, by including a comma-separated list of their names in the recalculate parameter.\n            The empty parameter 'recalculate=' is useful avoid slow recalculation when operating against large datasets as 'recalculate=' avoids calculating any fields,\n            regardless of any changes to projection, projection policy, etc. The nativebbox parameter 'recalculate=nativebbox'\n            is used recalculates the native bounding box, while avoiding recalculating the lat/lon bounding box. Recalculate parameters\n            can be used in together - 'recalculate=nativebbox,latlonbbox' can be used after a bulk import to recalculate both\n            the native bounding box and the lat/lon bounding box. Finally, 'recalculate=attributes' can be used to reset the attributes\n            and reload them from the original vector source. Pay attention to its usage, if attributes were explicitly configured to\n            perform attribute selection, renaming, and other transformations, such configuration will be lost, resetting the\n            feature type to the list of attributes found in the vector data source.\n\n    Returns:\n        Success message.\n\n    Example:\n        To update a feature type, use the following code:\n\n        ```python\n        # Check the GeoServer official documentation for the body structure\n        body = \"...\"\n\n        geoserver.update_feature_type(\"my_feature_type\", body, workspace=\"my_workspace\")\n        ```\n    \"\"\"\n    url = f\"{self.service_url}/rest/workspaces/{workspace}/featuretypes/{name}\"\n    if store is not None:\n        url = f\"{self.service_url}/rest/workspaces/{workspace}/datastores/{store}/featuretypes/{name}\"\n\n    params = dict(recalculate=recalculate)\n    self._request(method=\"put\", url=url, body=body, params=params)\n    return UPDATED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.delete_feature_type","title":"delete_feature_type","text":"<pre><code>delete_feature_type(name: str, *, workspace: str, store: Optional[str] = None, recurse: bool = False) -&gt; str\n</code></pre> <p>Delete an individual feature type.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the feature type.</p> required <code>workspace</code> <code>str</code> <p>The name of the workspace.</p> required <code>store</code> <code>Optional[str]</code> <p>Optional. The name of the data store.</p> <code>None</code> <code>recurse</code> <code>bool</code> <p>Optional. If true, all resources contained in the store are also removed.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Example <p>To delete a feature type, use the following code:</p> <pre><code>geoserver.delete_feature_type(\"my_feature_type\", workspace=\"my_workspace\")\n</code></pre> <p>To also remove all associated resources, use the following code:</p> <pre><code>geoserver.delete_feature_type(\"my_feature_type\", workspace=\"my_workspace\", recurse=True)\n</code></pre> Source code in <code>geoserver/geoserver.py</code> <pre><code>def delete_feature_type(\n    self, name: str, *, workspace: str, store: Optional[str] = None, recurse: bool = False\n) -&gt; str:\n    \"\"\"Delete an individual feature type.\n\n    Args:\n        name: The name of the feature type.\n        workspace: The name of the workspace.\n        store: Optional. The name of the data store.\n        recurse: Optional. If true, all resources contained in the store are also removed.\n\n    Returns:\n        Success message.\n\n    Example:\n        To delete a feature type, use the following code:\n\n        ```python\n        geoserver.delete_feature_type(\"my_feature_type\", workspace=\"my_workspace\")\n        ```\n\n        To also remove all associated resources, use the following code:\n\n        ```python\n        geoserver.delete_feature_type(\"my_feature_type\", workspace=\"my_workspace\", recurse=True)\n        ```\n    \"\"\"\n    url = f\"{self.service_url}/rest/workspaces/{workspace}/featuretypes/{name}\"\n    if store is not None:\n        url = f\"{self.service_url}/rest/workspaces/{workspace}/datastores/{store}/featuretypes/{name}\"\n\n    params = dict(recurse=recurse)\n    self._request(method=\"delete\", url=url, params=params)\n    return DELETED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.reset_feature_type_caches","title":"reset_feature_type_caches","text":"<pre><code>reset_feature_type_caches(name: str, *, workspace: str, store: Optional[str] = None) -&gt; str\n</code></pre> <p>Resets caches for this feature type. This operation is used to force GeoServer to drop caches associated to this feature type, and reconnect to the vector source the next time it is needed by a request. This is useful as the store can keep state, such as a connection pool, and the structure of the feature types it's serving.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the feature type.</p> required <code>workspace</code> <code>str</code> <p>The name of the workspace.</p> required <code>store</code> <code>Optional[str]</code> <p>Optional. The name of the data store.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Example <p>To reset the caches of a feature type, use the following code:</p> <pre><code>geoserver.reset_feature_type_caches(\"my_feature_type\", workspace=\"my_workspace\")\n</code></pre> <p>To specify a data store, use the following code:</p> <pre><code>geoserver.reset_feature_type_caches(\"my_feature_type\", workspace=\"my_workspace\", store=\"my_data_store\")\n</code></pre> Source code in <code>geoserver/geoserver.py</code> <pre><code>def reset_feature_type_caches(self, name: str, *, workspace: str, store: Optional[str] = None) -&gt; str:\n    \"\"\"Resets caches for this feature type.\n    This operation is used to force GeoServer to drop caches associated to this feature type,\n    and reconnect to the vector source the next time it is needed by a request.\n    This is useful as the store can keep state, such as a connection pool,\n    and the structure of the feature types it's serving.\n\n    Args:\n        name: The name of the feature type.\n        workspace: The name of the workspace.\n        store: Optional. The name of the data store.\n\n    Returns:\n        Success message.\n\n    Example:\n        To reset the caches of a feature type, use the following code:\n\n        ```python\n        geoserver.reset_feature_type_caches(\"my_feature_type\", workspace=\"my_workspace\")\n        ```\n\n        To specify a data store, use the following code:\n\n        ```python\n        geoserver.reset_feature_type_caches(\"my_feature_type\", workspace=\"my_workspace\", store=\"my_data_store\")\n        ```\n    \"\"\"\n    url = f\"{self.service_url}/rest/workspaces/{workspace}/featuretypes/{name}/reset\"\n    if store is not None:\n        url = f\"{self.service_url}/rest/workspaces/{workspace}/datastores/{store}/featuretypes/{name}/reset\"\n\n    self._request(method=\"put\", url=url)\n    return OK_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.get_fonts","title":"get_fonts","text":"<pre><code>get_fonts(*, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_fonts(*, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_fonts(*, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>List all fonts available to GeoServer.</p> <p>Parameters:</p> Name Type Description Default <code>format</code> <code>Literal['json', 'xml']</code> <p>The format of the response. It can be either \"json\" or \"xml\".</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The list of all fonts available to GeoServer.</p> Example <p>To get the list of all fonts available to GeoServer, use the following code:</p> <pre><code>geoserver.get_fonts()\n</code></pre> Source code in <code>geoserver/geoserver.py</code> <pre><code>def get_fonts(self, *, format: Literal[\"json\", \"xml\"] = \"json\") -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"List all fonts available to GeoServer.\n\n    Args:\n        format: The format of the response. It can be either \"json\" or \"xml\".\n\n    Returns:\n        The list of all fonts available to GeoServer.\n\n    Example:\n        To get the list of all fonts available to GeoServer, use the following code:\n\n        ```python\n        geoserver.get_fonts()\n        ```\n    \"\"\"\n    url = f\"{self.service_url}/rest/fonts.{format}\"\n    response = self._request(method=\"get\", url=url)\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.get_layer_groups","title":"get_layer_groups","text":"<pre><code>get_layer_groups(*, workspace: Optional[str] = None, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_layer_groups(*, workspace: Optional[str] = None, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_layer_groups(*, workspace: Optional[str] = None, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>List all layer groups in the workspace.</p> <p>Parameters:</p> Name Type Description Default <code>workspace</code> <code>Optional[str]</code> <p>Optional. The name of the workspace.</p> <code>None</code> <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response. It can be either \"json\" or \"xml\".</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The list of all layer groups in the workspace.</p> Example <p>To get the list of all layer groups, use the following code:</p> <pre><code>geoserver.get_layer_groups()\n</code></pre> Source code in <code>geoserver/geoserver.py</code> <pre><code>def get_layer_groups(\n    self, *, workspace: Optional[str] = None, format: Literal[\"json\", \"xml\"] = \"json\"\n) -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"List all layer groups in the workspace.\n\n    Args:\n        workspace: Optional. The name of the workspace.\n        format: Optional. The format of the response. It can be either \"json\" or \"xml\".\n\n    Returns:\n        The list of all layer groups in the workspace.\n\n    Example:\n        To get the list of all layer groups, use the following code:\n\n        ```python\n        geoserver.get_layer_groups()\n        ```\n    \"\"\"\n    url = f\"{self.service_url}/rest/layergroups.{format}\"\n    if workspace is not None:\n        url = f\"{self.service_url}/rest/workspaces/{workspace}/layergroups.{format}\"\n\n    response = self._request(method=\"get\", url=url)\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.layer_group_exists","title":"layer_group_exists","text":"<pre><code>layer_group_exists(name: str, *, workspace: Optional[str] = None) -&gt; bool\n</code></pre> <p>Check if a layer group exists.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the layer group.</p> required <code>workspace</code> <code>Optional[str]</code> <p>Optional. The name of the workspace.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the layer group exists, False otherwise.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def layer_group_exists(self, name: str, *, workspace: Optional[str] = None) -&gt; bool:\n    \"\"\"Check if a layer group exists.\n\n    Args:\n        name: The name of the layer group.\n        workspace: Optional. The name of the workspace.\n\n    Returns:\n        True if the layer group exists, False otherwise.\n    \"\"\"\n    url = f\"{self.service_url}/rest/layergroups/{name}.xml\"\n    if workspace is not None:\n        url = f\"{self.service_url}/rest/workspaces/{workspace}/layergroups/{name}.xml\"\n\n    response = self._request(method=\"head\", url=url, ignore=[404])\n    return response.status_code == 200\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.create_layer_group","title":"create_layer_group","text":"<pre><code>create_layer_group(body: Union[str, Dict[str, Any]], *, workspace: Optional[str] = None) -&gt; str\n</code></pre> <p>Create a new layer group.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>Union[str, Dict[str, Any]]</code> <p>The body of the request used to create the layer group.</p> required <code>workspace</code> <code>Optional[str]</code> <p>Optional. The name of the workspace.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The created layer group.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def create_layer_group(self, body: Union[str, Dict[str, Any]], *, workspace: Optional[str] = None) -&gt; str:\n    \"\"\"Create a new layer group.\n\n    Args:\n        body: The body of the request used to create the layer group.\n        workspace: Optional. The name of the workspace.\n\n    Returns:\n        The created layer group.\n    \"\"\"\n    url = f\"{self.service_url}/rest/layergroups\"\n    if workspace is not None:\n        url = f\"{self.service_url}/rest/workspaces/{workspace}/layergroups\"\n\n    self._request(method=\"post\", url=url, body=body)\n    return CREATED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.get_layer_group","title":"get_layer_group","text":"<pre><code>get_layer_group(name: str, *, workspace: Optional[str] = None, quiet_on_not_found: bool = False, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_layer_group(name: str, *, workspace: Optional[str] = None, quiet_on_not_found: bool = False, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_layer_group(name: str, *, workspace: Optional[str] = None, quiet_on_not_found: bool = False, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>Get an individual layer group.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the layer group.</p> required <code>workspace</code> <code>Optional[str]</code> <p>Optional. The name of the workspace.</p> <code>None</code> <code>quiet_on_not_found</code> <code>bool</code> <p>Optional. If true, the server will not report an error if the layer group is not found.</p> <code>False</code> <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response. It can be either \"json\" or \"xml\".</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The requested layer group.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def get_layer_group(\n    self,\n    name: str,\n    *,\n    workspace: Optional[str] = None,\n    quiet_on_not_found: bool = False,\n    format: Literal[\"json\", \"xml\"] = \"json\",\n) -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"Get an individual layer group.\n\n    Args:\n        name: The name of the layer group.\n        workspace: Optional. The name of the workspace.\n        quiet_on_not_found: Optional. If true, the server will not report an error if the layer group is not found.\n        format: Optional. The format of the response. It can be either \"json\" or \"xml\".\n\n    Returns:\n        The requested layer group.\n    \"\"\"\n    url = f\"{self.service_url}/rest/layergroups/{name}.{format}\"\n    if workspace is not None:\n        url = f\"{self.service_url}/rest/workspaces/{workspace}/layergroups/{name}.{format}\"\n\n    response = self._request(method=\"get\", url=url, params=dict(quietOnNotFound=quiet_on_not_found))\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.update_layer_group","title":"update_layer_group","text":"<pre><code>update_layer_group(name: str, body: Union[str, Dict[str, Any]], *, workspace: Optional[str] = None) -&gt; str\n</code></pre> <p>Update an individual layer group.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the layer group.</p> required <code>body</code> <code>Union[str, Dict[str, Any]]</code> <p>The body of the request used to modify the layer group.</p> required <code>workspace</code> <code>Optional[str]</code> <p>Optional. The name of the workspace.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def update_layer_group(\n    self, name: str, body: Union[str, Dict[str, Any]], *, workspace: Optional[str] = None\n) -&gt; str:\n    \"\"\"Update an individual layer group.\n\n    Args:\n        name: The name of the layer group.\n        body: The body of the request used to modify the layer group.\n        workspace: Optional. The name of the workspace.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/layergroups/{name}\"\n    if workspace is not None:\n        url = f\"{self.service_url}/rest/workspaces/{workspace}/layergroups/{name}\"\n\n    self._request(method=\"put\", url=url, body=body)\n    return UPDATED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.delete_layer_group","title":"delete_layer_group","text":"<pre><code>delete_layer_group(name: str, *, workspace: Optional[str] = None) -&gt; str\n</code></pre> <p>Delete an individual layer group.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the layer group.</p> required <code>workspace</code> <code>Optional[str]</code> <p>Optional. The name of the workspace.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def delete_layer_group(self, name: str, *, workspace: Optional[str] = None) -&gt; str:\n    \"\"\"Delete an individual layer group.\n\n    Args:\n        name: The name of the layer group.\n        workspace: Optional. The name of the workspace.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/layergroups/{name}\"\n    if workspace is not None:\n        url = f\"{self.service_url}/rest/workspaces/{workspace}/layergroups/{name}\"\n\n    self._request(method=\"delete\", url=url)\n    return DELETED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.get_layers","title":"get_layers","text":"<pre><code>get_layers(*, workspace: Optional[str] = None, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_layers(*, workspace: Optional[str] = None, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_layers(*, workspace: Optional[str] = None, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>List all layers in the workspace.</p> <p>Parameters:</p> Name Type Description Default <code>workspace</code> <code>Optional[str]</code> <p>Optional. The name of the workspace.</p> <code>None</code> <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response. It can be either \"json\" or \"xml\".</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The list of all layers in the workspace.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def get_layers(\n    self, *, workspace: Optional[str] = None, format: Literal[\"json\", \"xml\"] = \"json\"\n) -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"List all layers in the workspace.\n\n    Args:\n        workspace: Optional. The name of the workspace.\n        format: Optional. The format of the response. It can be either \"json\" or \"xml\".\n\n    Returns:\n        The list of all layers in the workspace.\n    \"\"\"\n    url = f\"{self.service_url}/rest/layers.{format}\"\n    if workspace is not None:\n        url = f\"{self.service_url}/rest/workspaces/{workspace}/layers.{format}\"\n\n    response = self._request(method=\"get\", url=url)\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.create_layer","title":"create_layer","text":"<pre><code>create_layer(body: Union[str, Dict[str, Any]], *, workspace: Optional[str] = None) -&gt; str\n</code></pre> <p>Creates a new layer.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>Union[str, Dict[str, Any]]</code> <p>The body of the request used to create the layer.</p> required <code>workspace</code> <code>Optional[str]</code> <p>Optional. The name of the workspace.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The created layer.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def create_layer(self, body: Union[str, Dict[str, Any]], *, workspace: Optional[str] = None) -&gt; str:\n    \"\"\"Creates a new layer.\n\n    Args:\n        body: The body of the request used to create the layer.\n        workspace: Optional. The name of the workspace.\n\n    Returns:\n        The created layer.\n    \"\"\"\n    url = f\"{self.service_url}/rest/layers\"\n    if workspace is not None:\n        url = f\"{self.service_url}/rest/workspaces/{workspace}/layers\"\n\n    self._request(method=\"post\", url=url, body=body)\n    return CREATED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.get_layer","title":"get_layer","text":"<pre><code>get_layer(name: str, *, workspace: Optional[str] = None, quiet_on_not_found: bool = False, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_layer(name: str, *, workspace: Optional[str] = None, quiet_on_not_found: bool = False, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_layer(name: str, *, workspace: Optional[str] = None, quiet_on_not_found: bool = False, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>Get an individual layer.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the layer.</p> required <code>workspace</code> <code>Optional[str]</code> <p>Optional. The name of the workspace.</p> <code>None</code> <code>quiet_on_not_found</code> <code>bool</code> <p>Optional. If true, the server will not report an error if the layer is not found.</p> <code>False</code> <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response. It can be either \"json\" or \"xml\".</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The requested layer.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def get_layer(\n    self,\n    name: str,\n    *,\n    workspace: Optional[str] = None,\n    quiet_on_not_found: bool = False,\n    format: Literal[\"json\", \"xml\"] = \"json\",\n) -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"Get an individual layer.\n\n    Args:\n        name: The name of the layer.\n        workspace: Optional. The name of the workspace.\n        quiet_on_not_found: Optional. If true, the server will not report an error if the layer is not found.\n        format: Optional. The format of the response. It can be either \"json\" or \"xml\".\n\n    Returns:\n        The requested layer.\n    \"\"\"\n    url = f\"{self.service_url}/rest/layers/{name}.{format}\"\n    if workspace is not None:\n        url = f\"{self.service_url}/rest/workspaces/{workspace}/layers/{name}.{format}\"\n\n    response = self._request(method=\"get\", url=url, params=dict(quietOnNotFound=quiet_on_not_found))\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.update_layer","title":"update_layer","text":"<pre><code>update_layer(name: str, body: Union[str, Dict[str, Any]], *, workspace: Optional[str] = None) -&gt; str\n</code></pre> <p>Update an individual layer.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the layer.</p> required <code>body</code> <code>Union[str, Dict[str, Any]]</code> <p>The body of the request used to modify the layer.</p> required <code>workspace</code> <code>Optional[str]</code> <p>The name of the workspace.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def update_layer(self, name: str, body: Union[str, Dict[str, Any]], *, workspace: Optional[str] = None) -&gt; str:\n    \"\"\"Update an individual layer.\n\n    Args:\n        name: The name of the layer.\n        body: The body of the request used to modify the layer.\n        workspace: The name of the workspace.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/layers/{name}\"\n    if workspace is not None:\n        url = f\"{self.service_url}/rest/workspaces/{workspace}/layers/{name}\"\n\n    self._request(method=\"put\", url=url, body=body)\n    return UPDATED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.delete_layer","title":"delete_layer","text":"<pre><code>delete_layer(name: str, *, workspace: Optional[str] = None) -&gt; str\n</code></pre> <p>Delete an individual layer.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the layer.</p> required <code>workspace</code> <code>Optional[str]</code> <p>The name of the workspace.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def delete_layer(self, name: str, *, workspace: Optional[str] = None) -&gt; str:\n    \"\"\"Delete an individual layer.\n\n    Args:\n        name: The name of the layer.\n        workspace: The name of the workspace.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/layers/{name}\"\n    if workspace is not None:\n        url = f\"{self.service_url}/rest/workspaces/{workspace}/layers/{name}\"\n\n    self._request(method=\"delete\", url=url)\n    return DELETED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.get_logging","title":"get_logging","text":"<pre><code>get_logging(*, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_logging(*, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_logging(*, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>Displays a list of all logging settings on the server.</p> <p>Parameters:</p> Name Type Description Default <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The logging settings.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def get_logging(self, *, format: Literal[\"json\", \"xml\"] = \"json\") -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"Displays a list of all logging settings on the server.\n\n    Args:\n        format: Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".\n\n    Returns:\n        The logging settings.\n    \"\"\"\n    url = f\"{self.service_url}/rest/logging.{format}\"\n    response = self._request(method=\"get\", url=url)\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.update_logging","title":"update_logging","text":"<pre><code>update_logging(body: Union[str, Dict[str, Any]]) -&gt; str\n</code></pre> <p>Modify the logging settings on the server.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>Union[str, Dict[str, Any]]</code> <p>The body of the request used to modify the logging settings.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def update_logging(self, body: Union[str, Dict[str, Any]]) -&gt; str:\n    \"\"\"Modify the logging settings on the server.\n\n    Args:\n        body: The body of the request used to modify the logging settings.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/logging\"\n    self._request(method=\"put\", url=url, body=body)\n    return UPDATED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.get_monitored_requests","title":"get_monitored_requests","text":"<pre><code>get_monitored_requests(*, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_monitored_requests(*, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_monitored_requests(*, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>Returns a list of all requests known to the monitoring system. If no list of fields is specified, the full list will be returned, with the exception of Class, Body and Error fields. The HTML format return a summary of the requests, and links to the single request to gather details.</p> <p>Parameters:</p> Name Type Description Default <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The monitoring requests.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def get_monitored_requests(self, *, format: Literal[\"json\", \"xml\"] = \"json\") -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"Returns a list of all requests known to the monitoring system.\n    If no list of fields is specified, the full list will be returned,\n    with the exception of Class, Body and Error fields.\n    The HTML format return a summary of the requests,\n    and links to the single request to gather details.\n\n    Args:\n        format: Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".\n\n    Returns:\n        The monitoring requests.\n    \"\"\"\n    url = f\"{self.service_url}/rest/monitor/requests.{format}\"\n    response = self._request(method=\"get\", url=url)\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.delete_monitored_requests","title":"delete_monitored_requests","text":"<pre><code>delete_monitored_requests() -&gt; str\n</code></pre> <p>Removes a request from the monitoring system.</p> <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def delete_monitored_requests(self) -&gt; str:\n    \"\"\"Removes a request from the monitoring system.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/monitor/requests\"\n    self._request(method=\"delete\", url=url)\n    return OK_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.get_monitored_request","title":"get_monitored_request","text":"<pre><code>get_monitored_request(id: str, *, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_monitored_request(id: str, *, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_monitored_request(id: str, *, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>Returns the details of a single request.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The id of the request to retrieve.</p> required <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The monitoring request.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def get_monitored_request(self, id: str, *, format: Literal[\"json\", \"xml\"] = \"json\") -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"Returns the details of a single request.\n\n    Args:\n        id: The id of the request to retrieve.\n        format: Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".\n\n    Returns:\n        The monitoring request.\n    \"\"\"\n    url = f\"{self.service_url}/rest/monitor/requests/{id}.{format}\"\n    response = self._request(method=\"get\", url=url)\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.get_namespaces","title":"get_namespaces","text":"<pre><code>get_namespaces(*, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_namespaces(*, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_namespaces(*, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>List all namespaces on the server.</p> <p>Parameters:</p> Name Type Description Default <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The list of all namespaces on the server.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def get_namespaces(self, *, format: Literal[\"json\", \"xml\"] = \"json\") -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"List all namespaces on the server.\n\n    Args:\n        format: Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".\n\n    Returns:\n        The list of all namespaces on the server.\n    \"\"\"\n    url = f\"{self.service_url}/rest/namespaces.{format}\"\n    response = self._request(method=\"get\", url=url)\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.create_namespace","title":"create_namespace","text":"<pre><code>create_namespace(body: Union[str, Dict[str, Any]]) -&gt; str\n</code></pre> <p>Create a new namespace.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>Union[str, Dict[str, Any]]</code> <p>The body of the request used to create the namespace.</p> required <p>Returns:</p> Type Description <code>str</code> <p>The created namespace.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def create_namespace(self, body: Union[str, Dict[str, Any]]) -&gt; str:\n    \"\"\"Create a new namespace.\n\n    Args:\n        body: The body of the request used to create the namespace.\n\n    Returns:\n        The created namespace.\n    \"\"\"\n    url = f\"{self.service_url}/rest/namespaces\"\n    self._request(method=\"post\", url=url, body=body)\n    return CREATED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.get_namespace","title":"get_namespace","text":"<pre><code>get_namespace(name: str, *, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_namespace(name: str, *, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_namespace(name: str, *, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>Get an individual namespace.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the namespace.</p> required <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The requested namespace.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def get_namespace(self, name: str, *, format: Literal[\"json\", \"xml\"] = \"json\") -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"Get an individual namespace.\n\n    Args:\n        name: The name of the namespace.\n        format: Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".\n\n    Returns:\n        The requested namespace.\n    \"\"\"\n    url = f\"{self.service_url}/rest/namespaces/{name}.{format}\"\n    response = self._request(method=\"get\", url=url)\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.update_namespace","title":"update_namespace","text":"<pre><code>update_namespace(name: str, body: Union[str, Dict[str, Any]]) -&gt; str\n</code></pre> <p>Update an individual namespace.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the namespace.</p> required <code>body</code> <code>Union[str, Dict[str, Any]]</code> <p>The body of the request used to modify the namespace.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def update_namespace(self, name: str, body: Union[str, Dict[str, Any]]) -&gt; str:\n    \"\"\"Update an individual namespace.\n\n    Args:\n        name: The name of the namespace.\n        body: The body of the request used to modify the namespace.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/namespaces/{name}\"\n    self._request(method=\"put\", url=url, body=body)\n    return UPDATED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.delete_namespace","title":"delete_namespace","text":"<pre><code>delete_namespace(name: str) -&gt; str\n</code></pre> <p>Delete an individual namespace.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the namespace.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def delete_namespace(self, name: str) -&gt; str:\n    \"\"\"Delete an individual namespace.\n\n    Args:\n        name: The name of the namespace.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/namespaces/{name}\"\n    self._request(method=\"delete\", url=url)\n    return DELETED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.get_wms_settings","title":"get_wms_settings","text":"<pre><code>get_wms_settings(*, workspace: Optional[str] = None, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_wms_settings(*, workspace: Optional[str] = None, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_wms_settings(*, workspace: Optional[str] = None, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>Get the WMS settings for the workspace.</p> <p>Parameters:</p> Name Type Description Default <code>workspace</code> <code>Optional[str]</code> <p>Optional. The name of the workspace.</p> <code>None</code> <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The WMS settings for the workspace.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def get_wms_settings(\n    self, *, workspace: Optional[str] = None, format: Literal[\"json\", \"xml\"] = \"json\"\n) -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"Get the WMS settings for the workspace.\n\n    Args:\n        workspace: Optional. The name of the workspace.\n        format: Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".\n\n    Returns:\n        The WMS settings for the workspace.\n    \"\"\"\n    url = f\"{self.service_url}/rest/services/wms/settings.{format}\"\n    if workspace is not None:\n        url = f\"{self.service_url}/rest/services/wms/workspaces/{workspace}/settings.{format}\"\n\n    response = self._request(method=\"get\", url=url)\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.update_wms_settings","title":"update_wms_settings","text":"<pre><code>update_wms_settings(body: Union[str, Dict[str, Any]], *, workspace: Optional[str] = None) -&gt; str\n</code></pre> <p>Update the WMS settings for the workspace.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>Union[str, Dict[str, Any]]</code> <p>The body of the request used to modify the WMS settings.</p> required <code>workspace</code> <code>Optional[str]</code> <p>The name of the workspace.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def update_wms_settings(self, body: Union[str, Dict[str, Any]], *, workspace: Optional[str] = None) -&gt; str:\n    \"\"\"Update the WMS settings for the workspace.\n\n    Args:\n        body: The body of the request used to modify the WMS settings.\n        workspace: The name of the workspace.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/services/wms/settings\"\n    if workspace is not None:\n        url = f\"{self.service_url}/rest/services/wms/workspaces/{workspace}/settings\"\n\n    self._request(method=\"put\", url=url, body=body)\n    return UPDATED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.delete_wms_settings","title":"delete_wms_settings","text":"<pre><code>delete_wms_settings(*, workspace: Optional[str] = None) -&gt; str\n</code></pre> <p>Delete the WMS settings for the workspace.</p> <p>Parameters:</p> Name Type Description Default <code>workspace</code> <code>Optional[str]</code> <p>Optional. The name of the workspace.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def delete_wms_settings(self, *, workspace: Optional[str] = None) -&gt; str:\n    \"\"\"Delete the WMS settings for the workspace.\n\n    Args:\n        workspace: Optional. The name of the workspace.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/services/wms/settings\"\n    if workspace is not None:\n        url = f\"{self.service_url}/rest/services/wms/workspaces/{workspace}/settings\"\n\n    self._request(method=\"delete\", url=url)\n    return DELETED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.get_wfs_settings","title":"get_wfs_settings","text":"<pre><code>get_wfs_settings(*, workspace: Optional[str] = None, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_wfs_settings(*, workspace: Optional[str] = None, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_wfs_settings(*, workspace: Optional[str] = None, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>Get the WFS settings for the workspace.</p> <p>Parameters:</p> Name Type Description Default <code>workspace</code> <code>Optional[str]</code> <p>Optional. The name of the workspace.</p> <code>None</code> <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The WFS settings for the workspace.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def get_wfs_settings(\n    self, *, workspace: Optional[str] = None, format: Literal[\"json\", \"xml\"] = \"json\"\n) -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"Get the WFS settings for the workspace.\n\n    Args:\n        workspace: Optional. The name of the workspace.\n        format: Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".\n\n    Returns:\n        The WFS settings for the workspace.\n    \"\"\"\n    url = f\"{self.service_url}/rest/services/wfs/settings.{format}\"\n    if workspace is not None:\n        url = f\"{self.service_url}/rest/services/wfs/workspaces/{workspace}/settings.{format}\"\n\n    response = self._request(method=\"get\", url=url)\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.update_wfs_settings","title":"update_wfs_settings","text":"<pre><code>update_wfs_settings(body: Union[str, Dict[str, Any]], *, workspace: Optional[str] = None) -&gt; str\n</code></pre> <p>Update the WFS settings for the workspace.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>Union[str, Dict[str, Any]]</code> <p>The body of the request used to modify the WFS settings.</p> required <code>workspace</code> <code>Optional[str]</code> <p>Optional. The name of the workspace.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def update_wfs_settings(self, body: Union[str, Dict[str, Any]], *, workspace: Optional[str] = None) -&gt; str:\n    \"\"\"Update the WFS settings for the workspace.\n\n    Args:\n        body: The body of the request used to modify the WFS settings.\n        workspace: Optional. The name of the workspace.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/services/wfs/settings\"\n    if workspace is not None:\n        url = f\"{self.service_url}/rest/services/wfs/workspaces/{workspace}/settings\"\n\n    self._request(method=\"put\", url=url, body=body)\n    return UPDATED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.delete_wfs_settings","title":"delete_wfs_settings","text":"<pre><code>delete_wfs_settings(*, workspace: Optional[str] = None) -&gt; str\n</code></pre> <p>Delete the WFS settings for the workspace.</p> <p>Parameters:</p> Name Type Description Default <code>workspace</code> <code>Optional[str]</code> <p>Optional. The name of the workspace.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def delete_wfs_settings(self, *, workspace: Optional[str] = None) -&gt; str:\n    \"\"\"Delete the WFS settings for the workspace.\n\n    Args:\n        workspace: Optional. The name of the workspace.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/services/wfs/settings\"\n    if workspace is not None:\n        url = f\"{self.service_url}/rest/services/wfs/workspaces/{workspace}/settings\"\n\n    self._request(method=\"delete\", url=url)\n    return DELETED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.get_wcs_settings","title":"get_wcs_settings","text":"<pre><code>get_wcs_settings(*, workspace: Optional[str] = None, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_wcs_settings(*, workspace: Optional[str] = None, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_wcs_settings(*, workspace: Optional[str] = None, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>Get the WCS settings for the workspace.</p> <p>Parameters:</p> Name Type Description Default <code>workspace</code> <code>Optional[str]</code> <p>Optional. The name of the workspace.</p> <code>None</code> <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The WCS settings for the workspace.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def get_wcs_settings(\n    self, *, workspace: Optional[str] = None, format: Literal[\"json\", \"xml\"] = \"json\"\n) -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"Get the WCS settings for the workspace.\n\n    Args:\n        workspace: Optional. The name of the workspace.\n        format: Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".\n\n    Returns:\n        The WCS settings for the workspace.\n    \"\"\"\n    url = f\"{self.service_url}/rest/services/wcs/settings.{format}\"\n    if workspace is not None:\n        url = f\"{self.service_url}/rest/services/wcs/workspaces/{workspace}/settings.{format}\"\n\n    response = self._request(method=\"get\", url=url)\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.update_wcs_settings","title":"update_wcs_settings","text":"<pre><code>update_wcs_settings(body: Union[str, Dict[str, Any]], *, workspace: Optional[str] = None) -&gt; str\n</code></pre> <p>Update the WCS settings for the workspace.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>Union[str, Dict[str, Any]]</code> <p>The body of the request used to modify the WCS settings.</p> required <code>workspace</code> <code>Optional[str]</code> <p>Optional. The name of the workspace.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def update_wcs_settings(self, body: Union[str, Dict[str, Any]], *, workspace: Optional[str] = None) -&gt; str:\n    \"\"\"Update the WCS settings for the workspace.\n\n    Args:\n        body: The body of the request used to modify the WCS settings.\n        workspace: Optional. The name of the workspace.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/services/wcs/settings\"\n    if workspace is not None:\n        url = f\"{self.service_url}/rest/services/wcs/workspaces/{workspace}/settings\"\n\n    self._request(method=\"put\", url=url, body=body)\n    return UPDATED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.delete_wcs_settings","title":"delete_wcs_settings","text":"<pre><code>delete_wcs_settings(*, workspace: Optional[str] = None) -&gt; str\n</code></pre> <p>Delete the WCS settings for the workspace.</p> <p>Parameters:</p> Name Type Description Default <code>workspace</code> <code>Optional[str]</code> <p>Optional. The name of the workspace.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def delete_wcs_settings(self, *, workspace: Optional[str] = None) -&gt; str:\n    \"\"\"Delete the WCS settings for the workspace.\n\n    Args:\n        workspace: Optional. The name of the workspace.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/services/wcs/settings\"\n    if workspace is not None:\n        url = f\"{self.service_url}/rest/services/wcs/workspaces/{workspace}/settings\"\n\n    self._request(method=\"delete\", url=url)\n    return DELETED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.get_wmts_settings","title":"get_wmts_settings","text":"<pre><code>get_wmts_settings(*, workspace: Optional[str] = None, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_wmts_settings(*, workspace: Optional[str] = None, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_wmts_settings(*, workspace: Optional[str] = None, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>Get the WMTS settings for the workspace.</p> <p>Parameters:</p> Name Type Description Default <code>workspace</code> <code>Optional[str]</code> <p>Optional. The name of the workspace.</p> <code>None</code> <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The WMTS settings for the workspace.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def get_wmts_settings(\n    self, *, workspace: Optional[str] = None, format: Literal[\"json\", \"xml\"] = \"json\"\n) -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"Get the WMTS settings for the workspace.\n\n    Args:\n        workspace: Optional. The name of the workspace.\n        format: Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".\n\n    Returns:\n        The WMTS settings for the workspace.\n    \"\"\"\n    url = f\"{self.service_url}/rest/services/wmts/settings.{format}\"\n    if workspace is not None:\n        url = f\"{self.service_url}/rest/services/wmts/workspaces/{workspace}/settings.{format}\"\n\n    response = self._request(method=\"get\", url=url)\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.update_wmts_settings","title":"update_wmts_settings","text":"<pre><code>update_wmts_settings(body: Union[str, Dict[str, Any]], *, workspace: Optional[str] = None) -&gt; str\n</code></pre> <p>Update the WMTS settings for the workspace.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>Union[str, Dict[str, Any]]</code> <p>The body of the request used to modify the WMTS settings.</p> required <code>workspace</code> <code>Optional[str]</code> <p>Optional. The name of the workspace.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def update_wmts_settings(self, body: Union[str, Dict[str, Any]], *, workspace: Optional[str] = None) -&gt; str:\n    \"\"\"Update the WMTS settings for the workspace.\n\n    Args:\n        body: The body of the request used to modify the WMTS settings.\n        workspace: Optional. The name of the workspace.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/services/wmts/settings\"\n    if workspace is not None:\n        url = f\"{self.service_url}/rest/services/wmts/workspaces/{workspace}/settings\"\n\n    self._request(method=\"put\", url=url, body=body)\n    return UPDATED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.delete_wmts_settings","title":"delete_wmts_settings","text":"<pre><code>delete_wmts_settings(*, workspace: Optional[str] = None) -&gt; str\n</code></pre> <p>Delete the WMTS settings for the workspace.</p> <p>Parameters:</p> Name Type Description Default <code>workspace</code> <code>Optional[str]</code> <p>Optional. The name of the workspace.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def delete_wmts_settings(self, *, workspace: Optional[str] = None) -&gt; str:\n    \"\"\"Delete the WMTS settings for the workspace.\n\n    Args:\n        workspace: Optional. The name of the workspace.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/services/wmts/settings\"\n    if workspace is not None:\n        url = f\"{self.service_url}/rest/services/wmts/workspaces/{workspace}/settings\"\n\n    self._request(method=\"delete\", url=url)\n    return DELETED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.get_oseo_settings","title":"get_oseo_settings","text":"<pre><code>get_oseo_settings(*, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_oseo_settings(*, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_oseo_settings(*, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>Retrieves Open Search for Earth Observation Service settings globally for the server.</p> <p>Parameters:</p> Name Type Description Default <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The OSEO settings for the workspace.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def get_oseo_settings(self, *, format: Literal[\"json\", \"xml\"] = \"json\") -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"Retrieves Open Search for Earth Observation Service settings globally for the server.\n\n    Args:\n        format: Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".\n\n    Returns:\n        The OSEO settings for the workspace.\n    \"\"\"\n    url = f\"{self.service_url}/rest/services/oseo/settings.{format}\"\n    response = self._request(method=\"get\", url=url)\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.update_oseo_settings","title":"update_oseo_settings","text":"<pre><code>update_oseo_settings(body: Union[str, Dict[str, Any]]) -&gt; str\n</code></pre> <p>Update the Open Search for Earth Observation Service settings globally for the server.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>Union[str, Dict[str, Any]]</code> <p>The body of the request used to modify the OSEO settings.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def update_oseo_settings(self, body: Union[str, Dict[str, Any]]) -&gt; str:\n    \"\"\"Update the Open Search for Earth Observation Service settings globally for the server.\n\n    Args:\n        body: The body of the request used to modify the OSEO settings.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/services/oseo/settings\"\n    self._request(method=\"put\", url=url, body=body)\n    return UPDATED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.reset","title":"reset","text":"<pre><code>reset() -&gt; str\n</code></pre> <p>Resets all store, raster, and schema caches. This operation is used to force GeoServer to drop all caches and store connections and reconnect to each of them the next time they are needed by a request. This is useful in case the stores themselves cache some information about the data structures they manage that may have changed in the meantime.</p> <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def reset(self) -&gt; str:\n    \"\"\"Resets all store, raster, and schema caches.\n    This operation is used to force GeoServer to drop all caches and store connections and reconnect\n    to each of them the next time they are needed by a request.\n    This is useful in case the stores themselves cache some information about the data structures\n    they manage that may have changed in the meantime.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/reset\"\n    self._request(method=\"put\", url=url)\n    return OK_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.reload","title":"reload","text":"<pre><code>reload() -&gt; str\n</code></pre> <p>Reloads the GeoServer catalog and configuration from disk. This operation is used in cases where an external tool has modified the on-disk configuration. This operation will also force GeoServer to drop any internal caches and reconnect to all data stores.</p> <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def reload(self) -&gt; str:\n    \"\"\"Reloads the GeoServer catalog and configuration from disk.\n    This operation is used in cases where an external tool has modified the on-disk configuration.\n    This operation will also force GeoServer to drop any internal caches and reconnect to all data stores.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/reload\"\n    self._request(method=\"put\", url=url)\n    return OK_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.get_resource","title":"get_resource","text":"<pre><code>get_resource(path: str, *, operation: Literal['default', 'metadata'] = 'default', format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_resource(path: str, *, operation: Literal['default', 'metadata'] = 'default', format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_resource(path: str, *, operation: Literal['default', 'metadata'] = 'default', format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>Download a resource, list contents of directory, or show formatted resource metadata. Response content depends upon parameters. With operation=default, if the request is made against a non-directory resource, the content of the resource is returned.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the resource.</p> required <code>operation</code> <code>Literal['default', 'metadata']</code> <p>Optional. The type of resource to get. It can be either \"default\" or \"metadata\". Defaults to \"default\".</p> <code>'default'</code> <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The requested resource.</p> Example <pre><code>geoserver.get_resource(resource=\"styles/default_point.sld\", operation=\"default\")\n</code></pre> Source code in <code>geoserver/geoserver.py</code> <pre><code>def get_resource(\n    self,\n    path: str,\n    *,\n    operation: Literal[\"default\", \"metadata\"] = \"default\",\n    format: Literal[\"json\", \"xml\"] = \"json\",\n) -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"Download a resource, list contents of directory, or show formatted resource metadata.\n    Response content depends upon parameters.\n    With operation=default, if the request is made against a non-directory resource, the content of the resource is returned.\n\n    Args:\n        path: The path to the resource.\n        operation: Optional. The type of resource to get. It can be either \"default\" or \"metadata\". Defaults to \"default\".\n        format: Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".\n\n    Returns:\n        The requested resource.\n\n    Example:\n        ```python\n        geoserver.get_resource(resource=\"styles/default_point.sld\", operation=\"default\")\n        ```\n    \"\"\"\n    url = f\"{self.service_url}/rest/resource/{path}\"\n    params = dict(operation=operation, format=\"json\")\n    response = self._request(method=\"get\", url=url, params=params)\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.update_resource","title":"update_resource","text":"<pre><code>update_resource(path: str, body: Union[str, Dict[str, Any]]) -&gt; str\n</code></pre> <p>Upload/move/copy a resource, create directories on the fly (overwrite if exists). For move/copy operations, place source path in body. Copying is not supported for directories.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The path to the resource.</p> required <code>body</code> <code>Union[str, Dict[str, Any]]</code> <p>The content of the resource to upload. In the case of a move or copy operation, this is instead the path to the source resource to move/copy from.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def update_resource(self, path: str, body: Union[str, Dict[str, Any]]) -&gt; str:\n    \"\"\"Upload/move/copy a resource, create directories on the fly (overwrite if exists). For move/copy operations, place source path in body. Copying is not supported for directories.\n\n    Args:\n        path: The path to the resource.\n        body: The content of the resource to upload. In the case of a move or copy operation,\n            this is instead the path to the source resource to move/copy from.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/resource/{path}\"\n    self._request(method=\"put\", url=url, body=body)\n    return UPDATED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.delete_resource","title":"delete_resource","text":"<pre><code>delete_resource(path: str) -&gt; str\n</code></pre> <p>Delete a resource (recursively if directory)</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The full path to the resource. Required, but may be empty; a request to /resource references the top level resource directory.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def delete_resource(self, path: str) -&gt; str:\n    \"\"\"Delete a resource (recursively if directory)\n\n    Args:\n        path: The full path to the resource. Required, but may be empty; a request to /resource references the top level resource directory.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/resource/{path}\"\n    self._request(method=\"delete\", url=url)\n    return DELETED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.resource_exists","title":"resource_exists","text":"<pre><code>resource_exists(path: str) -&gt; bool\n</code></pre> <p>Check if a resource exists.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>The full path to the resource.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def resource_exists(self, path: str) -&gt; bool:\n    \"\"\"Check if a resource exists.\n\n    Args:\n        path: The full path to the resource.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/resource/{path}\"\n    response = self._request(method=\"head\", url=url, ignore=[404])\n    return response.status_code == 200\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.get_master_password","title":"get_master_password","text":"<pre><code>get_master_password(*, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_master_password(*, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_master_password(*, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>Displays the keystore password. HTTPS is strongly suggested, otherwise password will be sent in plain text.</p> <p>Parameters:</p> Name Type Description Default <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The master password.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def get_master_password(self, *, format: Literal[\"json\", \"xml\"] = \"json\") -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"Displays the keystore password. HTTPS is strongly suggested, otherwise password will be sent in plain text.\n\n    Args:\n        format: Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".\n\n    Returns:\n        The master password.\n    \"\"\"\n    url = f\"{self.service_url}/rest/security/masterpw.{format}\"\n    response = self._request(method=\"get\", url=url)\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.update_master_password","title":"update_master_password","text":"<pre><code>update_master_password(body: Union[str, Dict[str, Any]]) -&gt; str\n</code></pre> <p>Changes keystore password. Must supply current keystore password. HTTPS is strongly suggested, otherwise password will be sent in plain text.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>Union[str, Dict[str, Any]]</code> <p>The body of the request used to set the master password.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def update_master_password(self, body: Union[str, Dict[str, Any]]) -&gt; str:\n    \"\"\"Changes keystore password. Must supply current keystore password. HTTPS is strongly suggested, otherwise password will be sent in plain text.\n\n    Args:\n        body: The body of the request used to set the master password.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/security/masterpw\"\n    self._request(method=\"put\", url=url, body=body)\n    return UPDATED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.update_password","title":"update_password","text":"<pre><code>update_password(body: Union[str, Dict[str, Any]]) -&gt; str\n</code></pre> <p>Updates the password for the account used to issue the request.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>Union[str, Dict[str, Any]]</code> <p>The body of the request used to set the password.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def update_password(self, body: Union[str, Dict[str, Any]]) -&gt; str:\n    \"\"\"Updates the password for the account used to issue the request.\n\n    Args:\n        body: The body of the request used to set the password.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/security/self/password\"\n    self._request(method=\"put\", url=url, body=body)\n    return UPDATED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.get_catalog_mode","title":"get_catalog_mode","text":"<pre><code>get_catalog_mode(*, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_catalog_mode(*, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_catalog_mode(*, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>Gets the catalog mode, which specifies how GeoServer will advertise secured layers and behave when a secured layer is accessed without the necessary privileges.</p> <p>Parameters:</p> Name Type Description Default <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The catalog mode.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def get_catalog_mode(self, *, format: Literal[\"json\", \"xml\"] = \"json\") -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"Gets the catalog mode, which specifies how GeoServer will advertise secured layers\n    and behave when a secured layer is accessed without the necessary privileges.\n\n    Args:\n        format: Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".\n\n    Returns:\n        The catalog mode.\n    \"\"\"\n    url = f\"{self.service_url}/rest/security/acl/catalog.{format}\"\n    response = self._request(method=\"get\", url=url)\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.update_catalog_mode","title":"update_catalog_mode","text":"<pre><code>update_catalog_mode(body: Union[str, Dict[str, Any]]) -&gt; str\n</code></pre> <p>Changes catalog mode. The mode must be one of HIDE, MIXED, or CHALLENGE.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>Union[str, Dict[str, Any]]</code> <p>The catalog mode information to upload.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def update_catalog_mode(self, body: Union[str, Dict[str, Any]]) -&gt; str:\n    \"\"\"Changes catalog mode. The mode must be one of HIDE, MIXED, or CHALLENGE.\n\n    Args:\n        body: The catalog mode information to upload.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/security/acl/catalog\"\n    self._request(method=\"put\", url=url, body=body)\n    return UPDATED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.get_security_layers","title":"get_security_layers","text":"<pre><code>get_security_layers(*, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_security_layers(*, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_security_layers(*, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>Displays the current layer-based security rules.</p> <p>Parameters:</p> Name Type Description Default <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The security layers.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def get_security_layers(self, *, format: Literal[\"json\", \"xml\"] = \"json\") -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"Displays the current layer-based security rules.\n\n    Args:\n        format: Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".\n\n    Returns:\n        The security layers.\n    \"\"\"\n    url = f\"{self.service_url}/rest/security/acl/layers.{format}\"\n    response = self._request(method=\"get\", url=url)\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.security_layer_exists","title":"security_layer_exists","text":"<pre><code>security_layer_exists(rule: str) -&gt; bool\n</code></pre> <p>Check if a security layer exists.</p> <p>Parameters:</p> Name Type Description Default <code>rule</code> <code>str</code> <p>The specified rule, as the last part in the URI, e.g. /security/acl/layers/..r</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def security_layer_exists(self, rule: str) -&gt; bool:\n    \"\"\"Check if a security layer exists.\n\n    Args:\n        rule: The specified rule, as the last part in the URI, e.g. /security/acl/layers/*.*.r\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/security/acl/layers/{rule}\"\n    response = self._request(method=\"head\", url=url, ignore=[404, 405])\n    return response.status_code == 200\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.create_security_layers","title":"create_security_layers","text":"<pre><code>create_security_layers(body: Union[str, Dict[str, Any]]) -&gt; str\n</code></pre> <p>Adds one or more new layer-based rules to the list of security rules.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>Union[str, Dict[str, Any]]</code> <p>The body of the request used to create the security layer.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def create_security_layers(self, body: Union[str, Dict[str, Any]]) -&gt; str:\n    \"\"\"Adds one or more new layer-based rules to the list of security rules.\n\n    Args:\n        body: The body of the request used to create the security layer.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/security/acl/layers\"\n    self._request(method=\"post\", url=url, body=body)\n    return CREATED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.update_security_layers","title":"update_security_layers","text":"<pre><code>update_security_layers(body: Union[str, Dict[str, Any]]) -&gt; str\n</code></pre> <p>Updates one or more layer-based security rules.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>Union[str, Dict[str, Any]]</code> <p>The body of the request used to modify the security layer.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def update_security_layers(self, body: Union[str, Dict[str, Any]]) -&gt; str:\n    \"\"\"Updates one or more layer-based security rules.\n\n    Args:\n        body: The body of the request used to modify the security layer.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/security/acl/layers\"\n    self._request(method=\"put\", url=url, body=body)\n    return UPDATED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.delete_security_layer","title":"delete_security_layer","text":"<pre><code>delete_security_layer(rule: Optional[str] = None) -&gt; str\n</code></pre> <p>Removes one or more layer-based security rules from the list of security rules. The <code>rule</code> must specified in the last part of the URL and of the form ..[r|w|a] <p>Parameters:</p> Name Type Description Default <code>rule</code> <code>Optional[str]</code> <p>Optional. The specified rule, as the last part in the URI, e.g. /security/acl/layers/..r</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def delete_security_layer(self, rule: Optional[str] = None) -&gt; str:\n    \"\"\"Removes one or more layer-based security rules from the list of security rules.\n    The `rule` must specified in the last part of the URL and of the form &lt;workspace&gt;.&lt;layer&gt;.[r|w|a]\n\n    Args:\n        rule: Optional. The specified rule, as the last part in the URI, e.g. /security/acl/layers/*.*.r\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/security/acl/layers\"\n    if rule is not None:\n        url = f\"{self.service_url}/rest/security/acl/layers/{rule}\"\n\n    self._request(method=\"delete\", url=url)\n    return DELETED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.get_security_services","title":"get_security_services","text":"<pre><code>get_security_services(*, rule: Optional[str] = None, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_security_services(*, rule: Optional[str] = None, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_security_services(*, rule: Optional[str] = None, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>Displays the current service-based security rules.</p> <p>Parameters:</p> Name Type Description Default <code>rule</code> <code>Optional[str]</code> <p>Optional. The specified rule, as the last part in the URI, e.g. /security/acl/layers/..r</p> <code>None</code> <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The security services.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def get_security_services(\n    self, *, rule: Optional[str] = None, format: Literal[\"json\", \"xml\"] = \"json\"\n) -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"Displays the current service-based security rules.\n\n    Args:\n        rule: Optional. The specified rule, as the last part in the URI, e.g. /security/acl/layers/*.*.r\n        format: Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".\n\n    Returns:\n        The security services.\n    \"\"\"\n    url = f\"{self.service_url}/rest/security/acl/services.{format}\"\n    if rule is not None:\n        url = f\"{self.service_url}/rest/security/acl/services/{rule}.{format}\"\n\n    response = self._request(method=\"get\", url=url)\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.update_security_services","title":"update_security_services","text":"<pre><code>update_security_services(body: Union[str, Dict[str, Any]], *, rule: Optional[str] = None) -&gt; str\n</code></pre> <p>Adds one or more new service-based rules to the list of security rules.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>Union[str, Dict[str, Any]]</code> <p>The body of the request used to create the security services.</p> required <code>rule</code> <code>Optional[str]</code> <p>Optional. The specified rule, as the last part in the URI, e.g. /security/acl/layers/..r</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def update_security_services(self, body: Union[str, Dict[str, Any]], *, rule: Optional[str] = None) -&gt; str:\n    \"\"\"Adds one or more new service-based rules to the list of security rules.\n\n    Args:\n        body: The body of the request used to create the security services.\n        rule: Optional. The specified rule, as the last part in the URI, e.g. /security/acl/layers/*.*.r\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/security/acl/services\"\n    if rule is not None:\n        url = f\"{self.service_url}/rest/security/acl/services/{rule}\"\n\n    self._request(method=\"post\", url=url, body=body)\n    return UPDATED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.delete_security_services","title":"delete_security_services","text":"<pre><code>delete_security_services(*, rule: Optional[str] = None) -&gt; str\n</code></pre> <p>Removes one or more service-based security rules from the list of security rules.</p> <p>Parameters:</p> Name Type Description Default <code>rule</code> <code>Optional[str]</code> <p>Optional. The specified rule, as the last part in the URI, e.g. /security/acl/layers/..r</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def delete_security_services(self, *, rule: Optional[str] = None) -&gt; str:\n    \"\"\"Removes one or more service-based security rules from the list of security rules.\n\n    Args:\n        rule: Optional. The specified rule, as the last part in the URI, e.g. /security/acl/layers/*.*.r\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/security/acl/services\"\n    if rule is not None:\n        url = f\"{self.service_url}/rest/security/acl/services/{rule}\"\n\n    self._request(method=\"delete\", url=url)\n    return DELETED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.get_security_access","title":"get_security_access","text":"<pre><code>get_security_access(*, rule: Optional[str] = None, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_security_access(*, rule: Optional[str] = None, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_security_access(*, rule: Optional[str] = None, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>Displays the current REST access rules.</p> <p>Parameters:</p> Name Type Description Default <code>rule</code> <code>Optional[str]</code> <p>Optional. The specified rule, as the last part in the URI, e.g. /security/acl/layers/..r</p> <code>None</code> <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The security REST.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def get_security_access(\n    self, *, rule: Optional[str] = None, format: Literal[\"json\", \"xml\"] = \"json\"\n) -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"Displays the current REST access rules.\n\n    Args:\n        rule: Optional. The specified rule, as the last part in the URI, e.g. /security/acl/layers/*.*.r\n        format: Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".\n\n    Returns:\n        The security REST.\n    \"\"\"\n    url = f\"{self.service_url}/rest/security/acl/rest.{format}\"\n    if rule is not None:\n        url = f\"{self.service_url}/rest/security/acl/{rule}.{format}\"\n\n    response = self._request(method=\"get\", url=url)\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.create_security_access","title":"create_security_access","text":"<pre><code>create_security_access(body: Union[str, Dict[str, Any]], *, rule: Optional[str] = None) -&gt; str\n</code></pre> <p>Adds one or more new REST access rules.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>Union[str, Dict[str, Any]]</code> <p>The body of the request used to create the security access.</p> required <code>rule</code> <code>Optional[str]</code> <p>Optional. The specified rule, as the last part in the URI, e.g. /security/acl/layers/..r</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def create_security_access(self, body: Union[str, Dict[str, Any]], *, rule: Optional[str] = None) -&gt; str:\n    \"\"\"Adds one or more new REST access rules.\n\n    Args:\n        body: The body of the request used to create the security access.\n        rule: Optional. The specified rule, as the last part in the URI, e.g. /security/acl/layers/*.*.r\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/security/acl/rest\"\n    if rule is not None:\n        url = f\"{self.service_url}/rest/security/acl/{rule}\"\n\n    self._request(method=\"post\", url=url, body=body)\n    return CREATED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.update_security_access","title":"update_security_access","text":"<pre><code>update_security_access(body: Union[str, Dict[str, Any]], *, rule: Optional[str] = None) -&gt; str\n</code></pre> <p>Updates one or more REST access rules.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>Union[str, Dict[str, Any]]</code> <p>The body of the request used to modify the security access.</p> required <code>rule</code> <code>Optional[str]</code> <p>Optional. The specified rule, as the last part in the URI, e.g. /security/acl/layers/..r</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def update_security_access(self, body: Union[str, Dict[str, Any]], *, rule: Optional[str] = None) -&gt; str:\n    \"\"\"Updates one or more REST access rules.\n\n    Args:\n        body: The body of the request used to modify the security access.\n        rule: Optional. The specified rule, as the last part in the URI, e.g. /security/acl/layers/*.*.r\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/security/acl/rest\"\n    if rule is not None:\n        url = f\"{self.service_url}/rest/security/acl/{rule}\"\n\n    self._request(method=\"put\", url=url, body=body)\n    return UPDATED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.delete_security_access","title":"delete_security_access","text":"<pre><code>delete_security_access(body: Union[str, Dict[str, Any]], *, rule: Optional[str] = None) -&gt; str\n</code></pre> <p>Removes one or more REST access rules.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>Union[str, Dict[str, Any]]</code> <p>The body of the request used to delete the security access.</p> required <code>rule</code> <code>Optional[str]</code> <p>Optional. The specified rule, as the last part in the URI, e.g. /security/acl/layers/..r</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def delete_security_access(self, body: Union[str, Dict[str, Any]], *, rule: Optional[str] = None) -&gt; str:\n    \"\"\"Removes one or more REST access rules.\n\n    Args:\n        body: The body of the request used to delete the security access.\n        rule: Optional. The specified rule, as the last part in the URI, e.g. /security/acl/layers/*.*.r\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/security/acl/rest\"\n    if rule is not None:\n        url = f\"{self.service_url}/rest/security/acl/{rule}\"\n\n    self._request(method=\"delete\", url=url, body=body)\n    return DELETED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.get_settings","title":"get_settings","text":"<pre><code>get_settings(*, workspace: Optional[str] = None, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_settings(*, workspace: Optional[str] = None, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_settings(*, workspace: Optional[str] = None, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>Displays a list of all global or workspace settings on the server.</p> <p>Parameters:</p> Name Type Description Default <code>workspace</code> <code>Optional[str]</code> <p>Optional. The name of the workspace.</p> <code>None</code> <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The settings for the workspace.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def get_settings(\n    self, *, workspace: Optional[str] = None, format: Literal[\"json\", \"xml\"] = \"json\"\n) -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"Displays a list of all global or workspace settings on the server.\n\n    Args:\n        workspace: Optional. The name of the workspace.\n        format: Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".\n\n    Returns:\n        The settings for the workspace.\n    \"\"\"\n    url = f\"{self.service_url}/rest/settings.{format}\"\n    if workspace is not None:\n        url = f\"{self.service_url}/rest/workspaces/{workspace}/settings.{format}\"\n\n    response = self._request(method=\"get\", url=url)\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.update_settings","title":"update_settings","text":"<pre><code>update_settings(body: Union[str, Dict[str, Any]], *, workspace: Optional[str] = None) -&gt; str\n</code></pre> <p>Updates global or workspace settings on the server.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>Union[str, Dict[str, Any]]</code> <p>The body of the request used to modify the settings.</p> required <code>workspace</code> <code>Optional[str]</code> <p>Optional. The name of the workspace.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def update_settings(self, body: Union[str, Dict[str, Any]], *, workspace: Optional[str] = None) -&gt; str:\n    \"\"\"Updates global or workspace settings on the server.\n\n    Args:\n        body: The body of the request used to modify the settings.\n        workspace: Optional. The name of the workspace.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/settings\"\n    if workspace is not None:\n        url = f\"{self.service_url}/rest/workspaces/{workspace}/settings\"\n\n    self._request(method=\"put\", url=url, body=body)\n    return UPDATED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.delete_settings","title":"delete_settings","text":"<pre><code>delete_settings(*, workspace: str) -&gt; str\n</code></pre> <p>Deletes workspace settings on the server.</p> <p>Parameters:</p> Name Type Description Default <code>workspace</code> <code>str</code> <p>Optional. The name of the workspace.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def delete_settings(self, *, workspace: str) -&gt; str:\n    \"\"\"Deletes workspace settings on the server.\n\n    Args:\n        workspace: Optional. The name of the workspace.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/workspaces/{workspace}/settings\"\n    response = self._request(method=\"delete\", url=url)\n    return response.text\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.get_contact_settings","title":"get_contact_settings","text":"<pre><code>get_contact_settings(*, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>Displays a list of all global contact settings on the server. This is a subset of what is available at the /settings endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The contact settings.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def get_contact_settings(self, *, format: Literal[\"json\", \"xml\"] = \"json\") -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"Displays a list of all global contact settings on the server.\n    This is a subset of what is available at the /settings endpoint.\n\n    Args:\n        format: Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".\n\n    Returns:\n        The contact settings.\n    \"\"\"\n    url = f\"{self.service_url}/rest/settings/contact.{format}\"\n    response = self._request(method=\"get\", url=url)\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.update_contact_settings","title":"update_contact_settings","text":"<pre><code>update_contact_settings() -&gt; str\n</code></pre> <p>Updates global contact settings on the server.</p> <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def update_contact_settings(self) -&gt; str:\n    \"\"\"Updates global contact settings on the server.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/settings/contact\"\n    self._request(method=\"put\", url=url)\n    return UPDATED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.get_coverage_granules","title":"get_coverage_granules","text":"<pre><code>get_coverage_granules(name: str, *, workspace: str, store: str, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_coverage_granules(name: str, *, workspace: str, store: str, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_coverage_granules(name: str, *, workspace: str, store: str, limit: int = -1, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>Displays a list of all the attributes associated to a particular coverage's granules</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the coverage.</p> required <code>workspace</code> <code>str</code> <p>The name of the workspace containing the coverage stores.</p> required <code>store</code> <code>str</code> <p>The name of the store.</p> required <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The granules in the structured coverage store.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def get_coverage_granules(\n    self, name: str, *, workspace: str, store: str, limit: int = -1, format: Literal[\"json\", \"xml\"] = \"json\"\n) -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"Displays a list of all the attributes associated to a particular coverage's granules\n\n    Args:\n        name: The name of the coverage.\n        workspace: The name of the workspace containing the coverage stores.\n        store: The name of the store.\n        format: Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".\n\n    Returns:\n        The granules in the structured coverage store.\n    \"\"\"\n    url = f\"{self.service_url}/rest/workspaces/{workspace}/coveragestores/{store}/coverages/{name}/index/granules.{format}\"\n    params = dict(limit=limit) if limit &gt;= 0 else {}\n    response = self._request(method=\"get\", url=url, params=params)\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.delete_coverage_granules","title":"delete_coverage_granules","text":"<pre><code>delete_coverage_granules(name: str, *, workspace: str, store: str, filter: str = '', purge: Literal['none', 'metadata', 'all'] = 'none', update_bbox: bool = False) -&gt; str\n</code></pre> <p>Allows removing one or more granules from the index.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the coverage.</p> required <code>workspace</code> <code>str</code> <p>The name of the workspace containing the coverage stores.</p> required <code>store</code> <code>str</code> <p>The name of the store.</p> required <code>filter</code> <code>str</code> <p>Optional. A CQL filter to reduce the returned granules.</p> <code>''</code> <code>purge</code> <code>Literal['none', 'metadata', 'all']</code> <p>Optional. The purge parameter specifies if and how the underlying raster data source is deleted. Allowable values for this parameter are <code>none</code>, <code>metadata</code> and <code>all</code>. When set to <code>none</code> data and auxiliary files are preserved, only the registration in the mosaic is removed When set to <code>metadata</code> delete only auxiliary files and metadata (e.g. NetCDF sidecar indexes). It's recommended when data files (such as granules) should not be deleted from disk. Finally, when set to <code>all</code> both data and auxiliary files are removed.</p> <code>'none'</code> <code>update_bbox</code> <code>bool</code> <p>Optional. When set to True, triggers re-calculation of the layer native bbox. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def delete_coverage_granules(\n    self,\n    name: str,\n    *,\n    workspace: str,\n    store: str,\n    filter: str = \"\",\n    purge: Literal[\"none\", \"metadata\", \"all\"] = \"none\",\n    update_bbox: bool = False,\n) -&gt; str:\n    \"\"\"Allows removing one or more granules from the index.\n\n    Args:\n        name: The name of the coverage.\n        workspace: The name of the workspace containing the coverage stores.\n        store: The name of the store.\n        filter: Optional. A CQL filter to reduce the returned granules.\n        purge: Optional. The purge parameter specifies if and how the underlying raster data source is deleted.\n            Allowable values for this parameter are `none`, `metadata` and `all`. When set to `none` data and auxiliary files are preserved,\n            only the registration in the mosaic is removed When set to `metadata` delete only auxiliary files and metadata\n            (e.g. NetCDF sidecar indexes). It's recommended when data files (such as granules) should not be deleted from disk.\n            Finally, when set to `all` both data and auxiliary files are removed.\n        update_bbox: Optional. When set to True, triggers re-calculation of the layer native bbox. Defaults to False.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/workspaces/{workspace}/coveragestores/{store}/coverages/{name}/index/granules\"\n    params = dict(filter=filter, purge=purge, updateBBox=update_bbox)\n    self._request(method=\"delete\", url=url, params=params)\n    return DELETED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.get_coverages_granule","title":"get_coverages_granule","text":"<pre><code>get_coverages_granule(name: str, *, workspace: str, store: str, coverage: str, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_coverages_granule(name: str, *, workspace: str, store: str, coverage: str, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_coverages_granule(name: str, *, workspace: str, store: str, coverage: str, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>Displays a list of all the attributes associated to a particular coverage's granule</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The ID of the granule.</p> required <code>workspace</code> <code>str</code> <p>The name of the workspace containing the coverage stores.</p> required <code>store</code> <code>str</code> <p>The name of the store.</p> required <code>coverage</code> <code>str</code> <p>The name of the coverage.</p> required <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The granule in the structured coverage store.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def get_coverages_granule(\n    self, name: str, *, workspace: str, store: str, coverage: str, format: Literal[\"json\", \"xml\"] = \"json\"\n) -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"Displays a list of all the attributes associated to a particular coverage's granule\n\n    Args:\n        name: The ID of the granule.\n        workspace: The name of the workspace containing the coverage stores.\n        store: The name of the store.\n        coverage: The name of the coverage.\n        format: Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".\n\n    Returns:\n        The granule in the structured coverage store.\n    \"\"\"\n    url = f\"{self.service_url}/rest/workspaces/{workspace}/coveragestores/{store}/coverages/{coverage}/granules/index/{name}.{format}\"\n    response = self._request(method=\"get\", url=url)\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.delete_coverage_granule","title":"delete_coverage_granule","text":"<pre><code>delete_coverage_granule(name: str, *, workspace: str, store: str, coverage: str, purge: bool = False, update_bbox: bool = False) -&gt; str\n</code></pre> <p>Allows removing the specified granule.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The ID of the granule.</p> required <code>workspace</code> <code>str</code> <p>The name of the workspace containing the coverage stores.</p> required <code>store</code> <code>str</code> <p>The name of the store.</p> required <code>coverage</code> <code>str</code> <p>The name of the coverage.</p> required <code>purge</code> <code>bool</code> <p>Optional. The purge parameter specifies if and how the underlying raster data source is deleted. Allowable values for this parameter are <code>none</code>, <code>metadata</code> and <code>all</code>. When set to <code>none</code> data and auxiliary files are preserved, only the registration in the mosaic is removed When set to <code>metadata</code> delete only auxiliary files and metadata (e.g. NetCDF sidecar indexes). It's recommended when data files (such as granules) should not be deleted from disk. Finally, when set to <code>all</code> both data and auxiliary files are removed.</p> <code>False</code> <code>update_bbox</code> <code>bool</code> <p>Optional. When set to True, triggers re-calculation of the layer native bbox. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def delete_coverage_granule(\n    self, name: str, *, workspace: str, store: str, coverage: str, purge: bool = False, update_bbox: bool = False\n) -&gt; str:\n    \"\"\"Allows removing the specified granule.\n\n    Args:\n        name: The ID of the granule.\n        workspace: The name of the workspace containing the coverage stores.\n        store: The name of the store.\n        coverage: The name of the coverage.\n        purge: Optional. The purge parameter specifies if and how the underlying raster data source is deleted.\n            Allowable values for this parameter are `none`, `metadata` and `all`. When set to `none` data and auxiliary files are preserved,\n            only the registration in the mosaic is removed When set to `metadata` delete only auxiliary files and metadata\n            (e.g. NetCDF sidecar indexes). It's recommended when data files (such as granules) should not be deleted from disk.\n            Finally, when set to `all` both data and auxiliary files are removed.\n        update_bbox: Optional. When set to True, triggers re-calculation of the layer native bbox. Defaults to False.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/workspaces/{workspace}/coveragestores/{store}/coverages/{coverage}/granules/index/{name}\"\n    params = dict(purge=purge, updateBBox=update_bbox)\n    self._request(method=\"delete\", url=url, params=params)\n    return DELETED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.get_styles","title":"get_styles","text":"<pre><code>get_styles(*, workspace: Optional[str] = None, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_styles(*, workspace: Optional[str] = None, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_styles(*, workspace: Optional[str] = None, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>Displays a list of all styles on the server.</p> <p>Parameters:</p> Name Type Description Default <code>workspace</code> <code>Optional[str]</code> <p>Optional. The name of the workspace.</p> <code>None</code> <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The styles.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def get_styles(\n    self, *, workspace: Optional[str] = None, format: Literal[\"json\", \"xml\"] = \"json\"\n) -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"Displays a list of all styles on the server.\n\n    Args:\n        workspace: Optional. The name of the workspace.\n        format: Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".\n\n    Returns:\n        The styles.\n    \"\"\"\n    url = f\"{self.service_url}/rest/styles.{format}\"\n    if workspace is not None:\n        url = f\"{self.service_url}/rest/workspaces/{workspace}/styles.{format}\"\n\n    response = self._request(method=\"get\", url=url)\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.style_exists","title":"style_exists","text":"<pre><code>style_exists(name: str, *, workspace: Optional[str] = None) -&gt; bool\n</code></pre> <p>Check if a style exists.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the style.</p> required <code>workspace</code> <code>Optional[str]</code> <p>Optional. The name of the workspace.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def style_exists(self, name: str, *, workspace: Optional[str] = None) -&gt; bool:\n    \"\"\"Check if a style exists.\n\n    Args:\n        name: The name of the style.\n        workspace: Optional. The name of the workspace.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/styles/{name}.xml\"\n    if workspace is not None:\n        url = f\"{self.service_url}/rest/workspaces/{workspace}/styles/{name}.xml\"\n\n    response = self._request(method=\"head\", url=url, ignore=[404])\n    return response.status_code == 200\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.get_style","title":"get_style","text":"<pre><code>get_style(name: str, *, workspace: Optional[str] = None, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_style(name: str, *, workspace: Optional[str] = None, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_style(name: str, *, workspace: Optional[str] = None, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>Retrieves a single style.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the style.</p> required <code>workspace</code> <code>Optional[str]</code> <p>Optional. The name of the workspace.</p> <code>None</code> <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def get_style(\n    self, name: str, *, workspace: Optional[str] = None, format: Literal[\"json\", \"xml\"] = \"json\"\n) -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"Retrieves a single style.\n\n    Args:\n        name: The name of the style.\n        workspace: Optional. The name of the workspace.\n        format: Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/styles/{name}.{format}\"\n    if workspace is not None:\n        url = f\"{self.service_url}/rest/workspaces/{workspace}/styles/{name}.{format}\"\n\n    response = self._request(method=\"get\", url=url)\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.create_style","title":"create_style","text":"<pre><code>create_style(body: str, *, workspace: Optional[str] = None) -&gt; str\n</code></pre> <p>Creates a new style.</p> Warning <p>This method only supports body in XML format.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>str</code> <p>The body of the request used to create the style.</p> required <code>workspace</code> <code>Optional[str]</code> <p>Optional. The name of the workspace.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Example <pre><code>geoserver.create_style(body=\"&lt;sld&gt;...&lt;/sld&gt;\")\n</code></pre> Source code in <code>geoserver/geoserver.py</code> <pre><code>def create_style(self, body: str, *, workspace: Optional[str] = None) -&gt; str:\n    \"\"\"Creates a new style.\n\n    Warning:\n        This method only supports body in XML format.\n\n    Args:\n        body: The body of the request used to create the style.\n        workspace: Optional. The name of the workspace.\n\n    Returns:\n        Success message.\n\n    Example:\n        ```python\n        geoserver.create_style(body=\"&lt;sld&gt;...&lt;/sld&gt;\")\n        ```\n    \"\"\"\n    url = f\"{self.service_url}/rest/styles\"\n    if workspace is not None:\n        url = f\"{self.service_url}/rest/workspaces/{workspace}/styles\"\n\n    self._request(method=\"post\", url=url, body=body)\n    return CREATED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.upload_style","title":"upload_style","text":"<pre><code>upload_style(file: Union[str, Path, BufferedReader], *, name: str, workspace: Optional[str] = None, overwrite: Literal[True]) -&gt; str\n</code></pre><pre><code>upload_style(file: Union[str, Path, BufferedReader], *, name: Optional[str] = None, workspace: Optional[str] = None, overwrite: Literal[False] = False) -&gt; str\n</code></pre> <pre><code>upload_style(file: Union[str, Path, BufferedReader], *, name: Optional[str] = None, workspace: Optional[str] = None, overwrite: bool = False) -&gt; str\n</code></pre> <p>Uploads a style.</p> Note <p>The <code>name</code> parameter must be provided if the <code>file</code> argument is not a file path.</p> Note <p>If overwriting a style, you must provide the <code>style</code> name.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Union[str, Path, BufferedReader]</code> <p>The path to the file to upload.</p> required <code>name</code> <code>Optional[str]</code> <p>Optional. The name of the style. If not provided, it will be inferred from the filename.</p> <code>None</code> <code>workspace</code> <code>Optional[str]</code> <p>Optional. The name of the workspace.</p> <code>None</code> <code>overwrite</code> <code>bool</code> <p>Optional. Whether to overwrite the style if it already exists. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Example <p>To upload a style from a local SLD file:</p> <pre><code>file_path = \"path/to/my_style.sld\" # Or \"path/to/my_style.zip\"\ngeoserver.upload_style(file=file_path, workspace=\"demo\")\n\n# Open the file yourself\nwith open(file_path, \"rb\") as f:\n    geoserver.upload_style(file=f, workspace=\"demo\")\n</code></pre> <p>To overwrite an existing style with a new SLD file (or ZIP file):</p> <pre><code>file_path = \"path/to/my_style.sld\" # Or \"path/to/my_style.zip\"\ngeoserver.upload_style(file=file_path, style=\"my_style\", workspace=\"demo\", overwrite=True)\n\n# Open the file yourself\nwith open(file_path, \"rb\") as f:\n    geoserver.upload_style(file=f, style=\"my_style\", workspace=\"demo\", overwrite=True)\n</code></pre> Source code in <code>geoserver/geoserver.py</code> <pre><code>def upload_style(\n    self,\n    file: Union[str, Path, BufferedReader],\n    *,\n    name: Optional[str] = None,\n    workspace: Optional[str] = None,\n    overwrite: bool = False,\n) -&gt; str:\n    \"\"\"Uploads a style.\n\n    Note:\n        The `name` parameter must be provided if the `file` argument is not a file path.\n\n    Note:\n        If overwriting a style, you must provide the `style` name.\n\n    Args:\n        file: The path to the file to upload.\n        name: Optional. The name of the style. If not provided, it will be inferred from the filename.\n        workspace: Optional. The name of the workspace.\n        overwrite: Optional. Whether to overwrite the style if it already exists. Defaults to False.\n\n    Returns:\n        Success message.\n\n    Example:\n        To upload a style from a local SLD file:\n\n        ```python\n        file_path = \"path/to/my_style.sld\" # Or \"path/to/my_style.zip\"\n        geoserver.upload_style(file=file_path, workspace=\"demo\")\n\n        # Open the file yourself\n        with open(file_path, \"rb\") as f:\n            geoserver.upload_style(file=f, workspace=\"demo\")\n        ```\n\n        To overwrite an existing style with a new SLD file (or ZIP file):\n\n        ```python\n        file_path = \"path/to/my_style.sld\" # Or \"path/to/my_style.zip\"\n        geoserver.upload_style(file=file_path, style=\"my_style\", workspace=\"demo\", overwrite=True)\n\n        # Open the file yourself\n        with open(file_path, \"rb\") as f:\n            geoserver.upload_style(file=f, style=\"my_style\", workspace=\"demo\", overwrite=True)\n        ```\n\n    \"\"\"\n    method: Literal[\"post\", \"put\"] = \"put\" if overwrite else \"post\"\n    if overwrite and name is None:\n        raise ValueError(\"The `style` argument must be provided when overwrite is `True`\")\n\n    # Upload from a zip file\n    if zipfile.is_zipfile(file):\n        headers = {\"Content-Type\": \"application/zip\"}\n        url = f\"{self.service_url}/rest/styles\"\n        if overwrite:\n            url = f\"{self.service_url}/rest/styles/{name}.zip\"\n\n        _ = self._request(method=method, url=url, file=file, headers=headers)\n        return CREATED_MESSAGE\n\n    # Upload from a single SLD file\n    if name is None and isinstance(file, (str, Path)):\n        name = Path(file).stem\n    if name is None:\n        raise ValueError(\"The `style` name must be provided, either as an argument or as the filename.\")\n\n    if not overwrite:\n        body = f\"&lt;style&gt;&lt;name&gt;{name}&lt;/name&gt;&lt;filename&gt;{name}.sld&lt;/filename&gt;&lt;/style&gt;\"\n        _ = self.create_style(body=body, workspace=workspace)\n\n    body = file.read().decode(\"utf-8\") if isinstance(file, BufferedReader) else Path(file).read_text()\n    _ = self.update_style(name=name, body=body, workspace=workspace)\n    return CREATED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.update_style","title":"update_style","text":"<pre><code>update_style(name: str, body: str, *, workspace: Optional[str] = None) -&gt; str\n</code></pre> <p>Updates a single style.</p> Warning <p>This method only supports body in XML format.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the style.</p> required <code>body</code> <code>str</code> <p>The content of the updated style, in XML format.</p> required <code>workspace</code> <code>Optional[str]</code> <p>Optional. The name of the workspace.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def update_style(self, name: str, body: str, *, workspace: Optional[str] = None) -&gt; str:\n    \"\"\"Updates a single style.\n\n    Warning:\n        This method only supports body in XML format.\n\n    Args:\n        name: The name of the style.\n        body: The content of the updated style, in XML format.\n        workspace: Optional. The name of the workspace.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/styles/{name}\"\n    if workspace is not None:\n        url = f\"{self.service_url}/rest/workspaces/{workspace}/styles/{name}\"\n\n    # Automatically determine the content type based on the SLD version\n    pattern = r'StyledLayerDescriptor[^&gt;]*version=\"([^\"]*)\"'\n    match = re.search(pattern, body)\n    if not match:\n        raise ValueError(\"The SLD version could not be determined.\")\n\n    sld_version = match.group(1)\n\n    content_type = \"application/vnd.ogc.sld+xml\"\n    if sld_version == \"1.1.0\" or sld_version == \"1.1\":\n        content_type = \"application/vnd.ogc.se+xml\"\n\n    self._request(method=\"put\", url=url, body=body, headers={\"Content-Type\": content_type})\n    return UPDATED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.download_style","title":"download_style","text":"<pre><code>download_style(name: str, *, workspace: Optional[str] = None) -&gt; str\n</code></pre> <p>Downloads a single style.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the style.</p> required <code>workspace</code> <code>Optional[str]</code> <p>Optional. The name of the workspace.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The style content.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def download_style(self, name: str, *, workspace: Optional[str] = None) -&gt; str:\n    \"\"\"Downloads a single style.\n\n    Args:\n        name: The name of the style.\n        workspace: Optional. The name of the workspace.\n\n    Returns:\n        The style content.\n    \"\"\"\n    url = f\"{self.service_url}/rest/styles/{name}.sld\"\n    if workspace is not None:\n        url = f\"{self.service_url}/rest/workspaces/{workspace}/styles/{name}.sld\"\n\n    response = self._request(method=\"get\", url=url)\n    return response.text\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.publish_style","title":"publish_style","text":"<pre><code>publish_style(layer: str, style: str, *, workspace: Optional[str] = None) -&gt; str\n</code></pre> <p>Publishes a style to a layer. This is equivalent to setting the default style for a layer, which will apply the style to the layer when it is rendered.</p> Note <p>This method is equivalent to updating the layer with the default style.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>str</code> <p>The name of the layer.</p> required <code>style</code> <code>str</code> <p>The name of the style.</p> required <code>workspace</code> <code>Optional[str]</code> <p>Optional. The name of the workspace.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Example <p>First, make sure the layer and style exist. Then, publish the style to the layer:</p> <pre><code>geoserver.publish_style(layer=\"my_layer\", style=\"my_style\", workspace=\"demo\")\n</code></pre> Source code in <code>geoserver/geoserver.py</code> <pre><code>def publish_style(self, layer: str, style: str, *, workspace: Optional[str] = None) -&gt; str:\n    \"\"\"Publishes a style to a layer. This is equivalent to setting the default style for a layer,\n    which will apply the style to the layer when it is rendered.\n\n    Note:\n        This method is equivalent to updating the layer with the default style.\n\n    Args:\n        layer: The name of the layer.\n        style: The name of the style.\n        workspace: Optional. The name of the workspace.\n\n    Returns:\n        Success message.\n\n    Example:\n        First, make sure the layer and style exist.\n        Then, publish the style to the layer:\n\n        ```python\n        geoserver.publish_style(layer=\"my_layer\", style=\"my_style\", workspace=\"demo\")\n        ```\n\n    \"\"\"\n    url = f\"{self.service_url}/rest/layers/{layer}\"\n    if workspace is not None:\n        url = f\"{self.service_url}/rest/workspaces/{workspace}/layers/{layer}\"\n\n    body = f\"&lt;layer&gt;&lt;defaultStyle&gt;&lt;name&gt;{style}&lt;/name&gt;&lt;/defaultStyle&gt;&lt;/layer&gt;\"\n    self._request(method=\"put\", url=url, body=body)\n    return UPDATED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.delete_style","title":"delete_style","text":"<pre><code>delete_style(name: str, *, workspace: Optional[str] = None, purge: bool = False, recurse: bool = False) -&gt; str\n</code></pre> <p>Deletes a single style.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the style.</p> required <code>workspace</code> <code>Optional[str]</code> <p>Optional. The name of the workspace.</p> <code>None</code> <code>purge</code> <code>bool</code> <p>Optional. Whether to purge the style from the catalog. Defaults to False.</p> <code>False</code> <code>recurse</code> <code>bool</code> <p>Optional. Whether to delete references to the style. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def delete_style(\n    self, name: str, *, workspace: Optional[str] = None, purge: bool = False, recurse: bool = False\n) -&gt; str:\n    \"\"\"Deletes a single style.\n\n    Args:\n        name: The name of the style.\n        workspace: Optional. The name of the workspace.\n        purge: Optional. Whether to purge the style from the catalog. Defaults to False.\n        recurse: Optional. Whether to delete references to the style. Defaults to False.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/styles/{name}\"\n    if workspace is not None:\n        url = f\"{self.service_url}/rest/workspaces/{workspace}/styles/{name}\"\n\n    params = dict(purge=purge, recurse=recurse)\n    self._request(method=\"delete\", url=url, params=params)\n    return DELETED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.get_templates","title":"get_templates","text":"<pre><code>get_templates(*, workspace: Optional[str] = None, store: Optional[str] = None, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_templates(*, workspace: Optional[str] = None, store: Optional[str] = None, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_templates(*, workspace: Optional[str] = None, store: Optional[str] = None, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>Displays a list of all templates on the server.</p> <p>Parameters:</p> Name Type Description Default <code>workspace</code> <code>Optional[str]</code> <p>Optional. The name of the workspace.</p> <code>None</code> <code>store</code> <code>Optional[str]</code> <p>Optional. The name of the store.</p> <code>None</code> <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The templates.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def get_templates(\n    self, *, workspace: Optional[str] = None, store: Optional[str] = None, format: Literal[\"json\", \"xml\"] = \"json\"\n) -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"Displays a list of all templates on the server.\n\n    Args:\n        workspace: Optional. The name of the workspace.\n        store: Optional. The name of the store.\n        format: Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".\n\n    Returns:\n        The templates.\n    \"\"\"\n    if workspace is None and store is None:\n        url = f\"{self.service_url}/rest/templates.{format}\"\n    elif workspace is not None and store is None:\n        url = f\"{self.service_url}/rest/workspaces/{workspace}/templates.{format}\"\n    elif workspace is not None and store is not None:\n        url = f\"{self.service_url}/rest/workspaces/{workspace}/datastores/{store}/templates.{format}\"\n    else:\n        raise ValueError(\"A workspace must be provided if a store is provided.\")\n\n    response = self._request(method=\"get\", url=url)\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.get_template","title":"get_template","text":"<pre><code>get_template(name: str, *, workspace: Optional[str] = None, data_store: Optional[str] = None, feature_type: Optional[str] = None, coverage_store: Optional[str] = None, coverage: Optional[str] = None) -&gt; str\n</code></pre> <p>Displays a list of all templates on the server.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the template.</p> required <code>workspace</code> <code>Optional[str]</code> <p>Optional. The name of the workspace.</p> <code>None</code> <code>data_store</code> <code>Optional[str]</code> <p>Optional. The name of the datastore.</p> <code>None</code> <code>feature_type</code> <code>Optional[str]</code> <p>Optional. The name of the featuretype.</p> <code>None</code> <code>coverage_store</code> <code>Optional[str]</code> <p>Optional. The name of the coveragestore.</p> <code>None</code> <code>coverage</code> <code>Optional[str]</code> <p>Optional. The name of the coverage.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>The templates.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def get_template(\n    self,\n    name: str,\n    *,\n    workspace: Optional[str] = None,\n    data_store: Optional[str] = None,\n    feature_type: Optional[str] = None,\n    coverage_store: Optional[str] = None,\n    coverage: Optional[str] = None,\n) -&gt; str:\n    \"\"\"Displays a list of all templates on the server.\n\n    Args:\n        name: The name of the template.\n        workspace: Optional. The name of the workspace.\n        data_store: Optional. The name of the datastore.\n        feature_type: Optional. The name of the featuretype.\n        coverage_store: Optional. The name of the coveragestore.\n        coverage: Optional. The name of the coverage.\n\n    Returns:\n        The templates.\n    \"\"\"\n    if (\n        workspace is None\n        and data_store is None\n        and feature_type is None\n        and coverage_store is None\n        and coverage is None\n    ):\n        url = f\"{self.service_url}/rest/templates/{name}.ftl\"\n    if (\n        workspace is not None\n        and data_store is None\n        and feature_type is None\n        and coverage_store is None\n        and coverage is None\n    ):\n        url = f\"{self.service_url}/rest/workspaces/{workspace}/templates/{name}.ftl\"\n    elif (\n        workspace is not None\n        and data_store is not None\n        and feature_type is None\n        and coverage_store is None\n        and coverage is None\n    ):\n        url = f\"{self.service_url}/rest/workspaces/{workspace}/datastores/{data_store}/templates/{name}.ftl\"\n    elif (\n        workspace is not None\n        and data_store is not None\n        and feature_type is not None\n        and coverage_store is None\n        and coverage is None\n    ):\n        url = f\"{self.service_url}/rest/workspaces/{workspace}/datastores/{data_store}/featuretypes/{feature_type}/templates/{name}.ftl\"\n    elif (\n        workspace is not None\n        and data_store is None\n        and feature_type is None\n        and coverage_store is not None\n        and coverage is None\n    ):\n        url = f\"{self.service_url}/rest/workspaces/{workspace}/coveragestores/{coverage_store}/templates/{name}.ftl\"\n    elif (\n        workspace is not None\n        and data_store is None\n        and feature_type is None\n        and coverage_store is not None\n        and coverage is not None\n    ):\n        url = f\"{self.service_url}/rest/workspaces/{workspace}/coveragestores/{coverage_store}/coverages/{coverage}/templates/{name}.ftl\"\n    else:\n        raise ValueError(\n            f\"Invalid combinations of workspace, store, and featuretype. Got {workspace}, {data_store}, and {feature_type}.\"\n        )\n\n    response = self._request(method=\"get\", url=url)\n    return response.json()\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.create_template","title":"create_template","text":"<pre><code>create_template(name: str, body: str, *, workspace: Optional[str] = None, data_store: Optional[str] = None, feature_type: Optional[str] = None, coverage_store: Optional[str] = None, coverage: Optional[str] = None) -&gt; str\n</code></pre> <p>Inserts or updates a single template registered for use in a workspace (example for GetFeatureInfo WMS operation). Overwrites any existing template with the same name and location.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the template.</p> required <code>body</code> <code>str</code> <p>The body of the request used to modify the template.</p> required <code>workspace</code> <code>Optional[str]</code> <p>Optional. The name of the workspace.</p> <code>None</code> <code>data_store</code> <code>Optional[str]</code> <p>Optional. The name of the datastore.</p> <code>None</code> <code>feature_type</code> <code>Optional[str]</code> <p>Optional. The name of the featuretype.</p> <code>None</code> <code>coverage_store</code> <code>Optional[str]</code> <p>Optional. The name of the coveragestore.</p> <code>None</code> <code>coverage</code> <code>Optional[str]</code> <p>Optional. The name of the coverage.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def create_template(\n    self,\n    name: str,\n    body: str,\n    *,\n    workspace: Optional[str] = None,\n    data_store: Optional[str] = None,\n    feature_type: Optional[str] = None,\n    coverage_store: Optional[str] = None,\n    coverage: Optional[str] = None,\n) -&gt; str:\n    \"\"\"Inserts or updates a single template registered for use in a workspace (example for GetFeatureInfo WMS operation).\n    Overwrites any existing template with the same name and location.\n\n    Args:\n        name: The name of the template.\n        body: The body of the request used to modify the template.\n        workspace: Optional. The name of the workspace.\n        data_store: Optional. The name of the datastore.\n        feature_type: Optional. The name of the featuretype.\n        coverage_store: Optional. The name of the coveragestore.\n        coverage: Optional. The name of the coverage.\n\n    Returns:\n        Success message.\n    \"\"\"\n    if (\n        workspace is None\n        and data_store is None\n        and feature_type is None\n        and coverage_store is None\n        and coverage is None\n    ):\n        url = f\"{self.service_url}/rest/templates/{name}.ftl\"\n    if (\n        workspace is not None\n        and data_store is None\n        and feature_type is None\n        and coverage_store is None\n        and coverage is None\n    ):\n        url = f\"{self.service_url}/rest/workspaces/{workspace}/templates/{name}.ftl\"\n    elif (\n        workspace is not None\n        and data_store is not None\n        and feature_type is None\n        and coverage_store is None\n        and coverage is None\n    ):\n        url = f\"{self.service_url}/rest/workspaces/{workspace}/datastores/{data_store}/templates/{name}.ftl\"\n    elif (\n        workspace is not None\n        and data_store is not None\n        and feature_type is not None\n        and coverage_store is None\n        and coverage is None\n    ):\n        url = f\"{self.service_url}/rest/workspaces/{workspace}/datastores/{data_store}/featuretypes/{feature_type}/templates/{name}.ftl\"\n    elif (\n        workspace is not None\n        and data_store is None\n        and feature_type is None\n        and coverage_store is not None\n        and coverage is None\n    ):\n        url = f\"{self.service_url}/rest/workspaces/{workspace}/coveragestores/{coverage_store}/templates/{name}.ftl\"\n    elif (\n        workspace is not None\n        and data_store is None\n        and feature_type is None\n        and coverage_store is not None\n        and coverage is not None\n    ):\n        url = f\"{self.service_url}/rest/workspaces/{workspace}/coveragestores/{coverage_store}/coverages/{coverage}/templates/{name}.ftl\"\n    else:\n        raise ValueError(\n            f\"Invalid combinations of workspace, store, and featuretype. Got {workspace}, {data_store}, and {feature_type}.\"\n        )\n\n    headers = {\"Content-Type\": \"text/plain\"}\n    self._request(method=\"put\", url=url, body=body, headers=headers)\n    return CREATED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.delete_template","title":"delete_template","text":"<pre><code>delete_template(name: str, *, workspace: Optional[str] = None, data_store: Optional[str] = None, feature_type: Optional[str] = None, coverage_store: Optional[str] = None, coverage: Optional[str] = None) -&gt; str\n</code></pre> <p>Deletes a single template registered for use on the server.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the template.</p> required <code>workspace</code> <code>Optional[str]</code> <p>Optional. The name of the workspace.</p> <code>None</code> <code>data_store</code> <code>Optional[str]</code> <p>Optional. The name of the datastore.</p> <code>None</code> <code>feature_type</code> <code>Optional[str]</code> <p>Optional. The name of the featuretype.</p> <code>None</code> <code>coverage_store</code> <code>Optional[str]</code> <p>Optional. The name of the coveragestore.</p> <code>None</code> <code>coverage</code> <code>Optional[str]</code> <p>Optional. The name of the coverage.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def delete_template(\n    self,\n    name: str,\n    *,\n    workspace: Optional[str] = None,\n    data_store: Optional[str] = None,\n    feature_type: Optional[str] = None,\n    coverage_store: Optional[str] = None,\n    coverage: Optional[str] = None,\n) -&gt; str:\n    \"\"\"Deletes a single template registered for use on the server.\n\n    Args:\n        name: The name of the template.\n        workspace: Optional. The name of the workspace.\n        data_store: Optional. The name of the datastore.\n        feature_type: Optional. The name of the featuretype.\n        coverage_store: Optional. The name of the coveragestore.\n        coverage: Optional. The name of the coverage.\n\n    Returns:\n        Success message.\n    \"\"\"\n    if (\n        workspace is None\n        and data_store is None\n        and feature_type is None\n        and coverage_store is None\n        and coverage is None\n    ):\n        url = f\"{self.service_url}/rest/templates/{name}.ftl\"\n    if (\n        workspace is not None\n        and data_store is None\n        and feature_type is None\n        and coverage_store is None\n        and coverage is None\n    ):\n        url = f\"{self.service_url}/rest/workspaces/{workspace}/templates/{name}.ftl\"\n    elif (\n        workspace is not None\n        and data_store is not None\n        and feature_type is None\n        and coverage_store is None\n        and coverage is None\n    ):\n        url = f\"{self.service_url}/rest/workspaces/{workspace}/datastores/{data_store}/templates/{name}.ftl\"\n    elif (\n        workspace is not None\n        and data_store is not None\n        and feature_type is not None\n        and coverage_store is None\n        and coverage is None\n    ):\n        url = f\"{self.service_url}/rest/workspaces/{workspace}/datastores/{data_store}/featuretypes/{feature_type}/templates/{name}.ftl\"\n    elif (\n        workspace is not None\n        and data_store is None\n        and feature_type is None\n        and coverage_store is not None\n        and coverage is None\n    ):\n        url = f\"{self.service_url}/rest/workspaces/{workspace}/coveragestores/{coverage_store}/templates/{name}.ftl\"\n    elif (\n        workspace is not None\n        and data_store is None\n        and feature_type is None\n        and coverage_store is not None\n        and coverage is not None\n    ):\n        url = f\"{self.service_url}/rest/workspaces/{workspace}/coveragestores/{coverage_store}/coverages/{coverage}/templates/{name}.ftl\"\n    else:\n        raise ValueError(\n            f\"Invalid combinations of workspace, store, and featuretype. Got {workspace}, {data_store}, and {feature_type}.\"\n        )\n\n    self._request(method=\"delete\", url=url)\n    return DELETED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.get_wfs_transforms","title":"get_wfs_transforms","text":"<pre><code>get_wfs_transforms(*, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_wfs_transforms(*, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_wfs_transforms(*, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>Displays a list of all the transforms information available on the server.</p> <p>Parameters:</p> Name Type Description Default <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The XSLT transforms.</p> Example <p>To get the list of all the transforms available on the server, you can use the following code:</p> <pre><code>geoserver.get_transforms()\n</code></pre> Source code in <code>geoserver/geoserver.py</code> <pre><code>def get_wfs_transforms(self, *, format: Literal[\"json\", \"xml\"] = \"json\") -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"Displays a list of all the transforms information available on the server.\n\n    Args:\n        format: Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".\n\n    Returns:\n        The XSLT transforms.\n\n    Example:\n        To get the list of all the transforms available on the server, you can use the following code:\n\n        ```python\n        geoserver.get_transforms()\n        ```\n    \"\"\"\n    url = f\"{self.service_url}/rest/services/wfs/transforms.{format}\"\n    response = self._request(method=\"get\", url=url)\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.create_wfs_transform","title":"create_wfs_transform","text":"<pre><code>create_wfs_transform(body: Union[str, Dict[str, Any]], *, source_format: Optional[str] = None, output_format: Optional[str] = None, output_mime_type: Optional[str] = None, file_extension: Optional[str] = None) -&gt; str\n</code></pre> <p>Adds a new transform to the server. If the content type used is application/xml the server will assume a definition is being posted, and the XSLT will have to be uploaded separately using a PUT request with content type application/xslt+xml against the transformation resource. If the content type used is application/xslt+xml the server will assume the XSLT itself is being posted, and the name, sourceFormat, outputFormat, outputMimeType query parameters will be used to fill in the transform configuration instead.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>Union[str, Dict[str, Any]]</code> <p>The body of the request used to create the transform.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Example <p>To add a new transform to the server, you can use the following code:</p> <pre><code>body = \"\"\"\n&lt;transform&gt;\n    &lt;name&gt;test&lt;/name&gt;\n    &lt;sourceFormat&gt;GML2&lt;/sourceFormat&gt;\n    &lt;outputFormat&gt;text/xml&lt;/outputFormat&gt;\n    &lt;outputMimeType&gt;text/xml&lt;/outputMimeType&gt;\n    &lt;fileExtension&gt;xml&lt;/fileExtension&gt;\n&lt;/transform&gt;\n\"\"\"\n\ngeoserver.create_transform(body)\n</code></pre> Source code in <code>geoserver/geoserver.py</code> <pre><code>def create_wfs_transform(\n    self,\n    body: Union[str, Dict[str, Any]],\n    *,\n    source_format: Optional[str] = None,\n    output_format: Optional[str] = None,\n    output_mime_type: Optional[str] = None,\n    file_extension: Optional[str] = None,\n) -&gt; str:\n    \"\"\"Adds a new transform to the server.\n    If the content type used is application/xml the server will assume a definition is being posted,\n    and the XSLT will have to be uploaded separately using a PUT request with content type application/xslt+xml against the transformation resource.\n    If the content type used is application/xslt+xml the server will assume the XSLT itself is being posted,\n    and the name, sourceFormat, outputFormat, outputMimeType query parameters will be used to fill in the transform configuration instead.\n\n    Args:\n        body: The body of the request used to create the transform.\n\n    Returns:\n        Success message.\n\n    Example:\n        To add a new transform to the server, you can use the following code:\n\n        ```python\n        body = \\\"\\\"\\\"\n        &lt;transform&gt;\n            &lt;name&gt;test&lt;/name&gt;\n            &lt;sourceFormat&gt;GML2&lt;/sourceFormat&gt;\n            &lt;outputFormat&gt;text/xml&lt;/outputFormat&gt;\n            &lt;outputMimeType&gt;text/xml&lt;/outputMimeType&gt;\n            &lt;fileExtension&gt;xml&lt;/fileExtension&gt;\n        &lt;/transform&gt;\n        \\\"\\\"\\\"\n\n        geoserver.create_transform(body)\n        ```\n    \"\"\"\n    url = f\"{self.service_url}/rest/services/wfs/transforms\"\n    params = dict(\n        sourceFormat=source_format,\n        outputFormat=output_format,\n        outputMimeType=output_mime_type,\n        fileExtension=file_extension,\n    )\n    self._request(method=\"post\", url=url, body=body, params=params)\n    return CREATED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.get_wfs_transform","title":"get_wfs_transform","text":"<pre><code>get_wfs_transform(name: str, *, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_wfs_transform(name: str, *, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_wfs_transform(name: str, *, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>Retrieves a single transformation.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the transform.</p> required <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The transform.</p> Example <p>To get a single transformation, you can use the following code:</p> <pre><code>geoserver.get_transform(transform=\"test1\")\n</code></pre> Source code in <code>geoserver/geoserver.py</code> <pre><code>def get_wfs_transform(self, name: str, *, format: Literal[\"json\", \"xml\"] = \"json\") -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"Retrieves a single transformation.\n\n    Args:\n        name: The name of the transform.\n        format: Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".\n\n    Returns:\n        The transform.\n\n    Example:\n        To get a single transformation, you can use the following code:\n\n        ```python\n        geoserver.get_transform(transform=\"test1\")\n        ```\n    \"\"\"\n    url = f\"{self.service_url}/rest/services/wfs/transforms/{name}.{format}\"\n    response = self._request(method=\"get\", url=url)\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.update_wfs_transform","title":"update_wfs_transform","text":"<pre><code>update_wfs_transform(name: str, body: Union[str, Dict[str, Any]]) -&gt; str\n</code></pre> <p>Modifies a single transform.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the transform.</p> required <code>body</code> <code>Union[str, Dict[str, Any]]</code> <p>The body of the request used to modify the transform.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Example <p>To update a single transformation, you can use the following code:</p> <pre><code>body = \"\"\"\n&lt;transform&gt;\n    &lt;name&gt;test1&lt;/name&gt;\n    &lt;sourceFormat&gt;text/xml; subtype=gml/2.1.2&lt;/sourceFormat&gt;\n    &lt;outputFormat&gt;text/html&lt;/outputFormat&gt;\n    &lt;xslt&gt;test1.xslt&lt;/xslt&gt;\n&lt;/transform&gt;\n\"\"\"\n\ngeoserver.update_transform(transform=\"test1\", body=body)\n</code></pre> Source code in <code>geoserver/geoserver.py</code> <pre><code>def update_wfs_transform(self, name: str, body: Union[str, Dict[str, Any]]) -&gt; str:\n    \"\"\"Modifies a single transform.\n\n    Args:\n        name: The name of the transform.\n        body: The body of the request used to modify the transform.\n\n    Returns:\n        Success message.\n\n    Example:\n        To update a single transformation, you can use the following code:\n\n        ```python\n        body = \\\"\\\"\\\"\n        &lt;transform&gt;\n            &lt;name&gt;test1&lt;/name&gt;\n            &lt;sourceFormat&gt;text/xml; subtype=gml/2.1.2&lt;/sourceFormat&gt;\n            &lt;outputFormat&gt;text/html&lt;/outputFormat&gt;\n            &lt;xslt&gt;test1.xslt&lt;/xslt&gt;\n        &lt;/transform&gt;\n        \\\"\\\"\\\"\n\n        geoserver.update_transform(transform=\"test1\", body=body)\n        ```\n    \"\"\"\n    url = f\"{self.service_url}/rest/services/wfs/transforms/{name}\"\n    self._request(method=\"put\", url=url, body=body)\n    return UPDATED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.delete_wfs_transform","title":"delete_wfs_transform","text":"<pre><code>delete_wfs_transform(name: str) -&gt; str\n</code></pre> <p>Deletes a single transform.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the transform.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Example <p>To remove a single transformation, you can use the following code:</p> <pre><code>geoserver.delete_transform(transform=\"test1\")\n</code></pre> Source code in <code>geoserver/geoserver.py</code> <pre><code>def delete_wfs_transform(self, name: str) -&gt; str:\n    \"\"\"Deletes a single transform.\n\n    Args:\n        name: The name of the transform.\n\n    Returns:\n        Success message.\n\n    Example:\n        To remove a single transformation, you can use the following code:\n\n        ```python\n        geoserver.delete_transform(transform=\"test1\")\n        ```\n    \"\"\"\n    url = f\"{self.service_url}/rest/services/wfs/transforms/{name}\"\n    self._request(method=\"delete\", url=url)\n    return DELETED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.get_wms_layers","title":"get_wms_layers","text":"<pre><code>get_wms_layers(*, workspace: str, store: Optional[str] = None, list: Optional[Literal['available']] = None, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_wms_layers(*, workspace: str, store: Optional[str] = None, list: Optional[Literal['available']] = None, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_wms_layers(*, workspace: str, store: Optional[str] = None, list: Optional[Literal['available']] = None, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>Retrieves the WMS layers available on the server.</p> <p>Parameters:</p> Name Type Description Default <code>workspace</code> <code>str</code> <p>The name of the workspace.</p> required <code>store</code> <code>Optional[str]</code> <p>Optional. Name of the wms store.</p> <code>None</code> <code>list</code> <code>Optional[Literal['available']]</code> <p>Optional. Set <code>list=available</code> to see all possible layers in the store, not just ones currently published.</p> <code>None</code> <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The WMS layers.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def get_wms_layers(\n    self,\n    *,\n    workspace: str,\n    store: Optional[str] = None,\n    list: Optional[Literal[\"available\"]] = None,\n    format: Literal[\"json\", \"xml\"] = \"json\",\n) -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"Retrieves the WMS layers available on the server.\n\n    Args:\n        workspace: The name of the workspace.\n        store: Optional. Name of the wms store.\n        list: Optional. Set `list=available` to see all possible layers in the store, not just ones currently published.\n        format: Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".\n\n    Returns:\n        The WMS layers.\n    \"\"\"\n    url = f\"{self.service_url}/rest/workspaces/{workspace}/wmslayers.{format}\"\n    if store is not None:\n        url = f\"{self.service_url}/rest/workspaces/{workspace}/wmsstores/{store}/wmslayers.{format}\"\n\n    params = dict(list=list)\n    response = self._request(method=\"get\", url=url, params=params)\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.create_wms_layer","title":"create_wms_layer","text":"<pre><code>create_wms_layer(body: Union[str, Dict[str, Any]], *, workspace: str, store: Optional[str] = None) -&gt; str\n</code></pre> <p>Creates a new WMS layer.</p> <p>Parameters:</p> Name Type Description Default <code>workspace</code> <code>str</code> <p>The name of the workspace.</p> required <code>body</code> <code>Union[str, Dict[str, Any]]</code> <p>The body of the request used to create the WMS layer.</p> required <code>store</code> <code>Optional[str]</code> <p>Optional. Name of the wms store.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def create_wms_layer(self, body: Union[str, Dict[str, Any]], *, workspace: str, store: Optional[str] = None) -&gt; str:\n    \"\"\"Creates a new WMS layer.\n\n    Args:\n        workspace: The name of the workspace.\n        body: The body of the request used to create the WMS layer.\n        store: Optional. Name of the wms store.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/workspaces/{workspace}/wmslayers\"\n    if store is not None:\n        url = f\"{self.service_url}/rest/workspaces/{workspace}/wmsstores/{store}/wmslayers\"\n\n    self._request(method=\"post\", url=url, body=body)\n    return CREATED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.get_wms_layer","title":"get_wms_layer","text":"<pre><code>get_wms_layer(name: str, *, workspace: str, store: Optional[str] = None, quiet_on_not_found: bool = False, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_wms_layer(name: str, *, workspace: str, store: Optional[str] = None, quiet_on_not_found: bool = False, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_wms_layer(name: str, *, workspace: str, store: Optional[str] = None, quiet_on_not_found: bool = False, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>Retrieves a single WMS layer.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the wms layer.</p> required <code>workspace</code> <code>str</code> <p>The name of the workspace.</p> required <code>store</code> <code>Optional[str]</code> <p>Optional. Name of the wms store.</p> <code>None</code> <code>quiet_on_not_found</code> <code>bool</code> <p>Optional. When set to \"true\", will not log an exception when the style is not present. The 404 status code will still be returned.</p> <code>False</code> <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The WMS layer.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def get_wms_layer(\n    self,\n    name: str,\n    *,\n    workspace: str,\n    store: Optional[str] = None,\n    quiet_on_not_found: bool = False,\n    format: Literal[\"json\", \"xml\"] = \"json\",\n) -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"Retrieves a single WMS layer.\n\n    Args:\n        name: The name of the wms layer.\n        workspace: The name of the workspace.\n        store: Optional. Name of the wms store.\n        quiet_on_not_found: Optional. When set to \"true\", will not log an exception when the style is not present.\n            The 404 status code will still be returned.\n        format: Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".\n\n    Returns:\n        The WMS layer.\n    \"\"\"\n    url = f\"{self.service_url}/rest/workspaces/{workspace}/wmslayers/{name}.{format}\"\n    if store is not None:\n        url = f\"{self.service_url}/rest/workspaces/{workspace}/wmsstores/{store}/wmslayers/{name}.{format}\"\n\n    params = dict(quietOnNotFound=quiet_on_not_found)\n    response = self._request(method=\"get\", url=url, params=params)\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.update_wms_layer","title":"update_wms_layer","text":"<pre><code>update_wms_layer(name: str, body: Union[str, Dict[str, Any]], *, workspace: str, store: Optional[str] = None, calculate: Optional[List[str]] = None) -&gt; str\n</code></pre> <p>Modifies a single WMS layer.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the layer.</p> required <code>body</code> <code>Union[str, Dict[str, Any]]</code> <p>The body of the request used to modify the WMS layer.</p> required <code>workspace</code> <code>str</code> <p>The name of the workspace.</p> required <code>calculate</code> <code>Optional[List[str]]</code> <p>Specifies whether to recalculate any bounding boxes for a wms layer. Some properties are automatically recalculated when necessary. In particular, the native bounding box is recalculated when the projection or projection policy are changed, and the lat/lon bounding box is recalculated when the native bounding box is recalculated, or when a new native bounding box is explicitly provided in the request. (The native and lat/lon bounding boxes are not automatically recalculated when they are explicitly included in the request.) In addition, the client may explicitly request a fixed set of fields to calculate, by including a comma-separated list of their names in the recalculate parameter. The empty parameter \"recalculate=\" is useful avoid slow recalculation when operating against large datasets as \"recalculate=\" avoids calculating any fields, regardless of any changes to projection, projection policy, etc. The nativebbox parameter \"recalculate=nativebbox\" is used recalculates the native bounding box, while avoiding recalculating the lat/lon bounding box. Recalculate parameters can be used in together - \"recalculate=nativebbox,latlonbbox\" can be used after a bulk import to recalculates both the native bounding box and the lat/lon bounding box.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def update_wms_layer(\n    self,\n    name: str,\n    body: Union[str, Dict[str, Any]],\n    *,\n    workspace: str,\n    store: Optional[str] = None,\n    calculate: Optional[List[str]] = None,\n) -&gt; str:\n    \"\"\"Modifies a single WMS layer.\n\n    Args:\n        name: The name of the layer.\n        body: The body of the request used to modify the WMS layer.\n        workspace: The name of the workspace.\n        calculate: Specifies whether to recalculate any bounding boxes for a wms layer.\n            Some properties are automatically recalculated when necessary.\n            In particular, the native bounding box is recalculated when the projection or projection policy are changed,\n            and the lat/lon bounding box is recalculated when the native bounding box is recalculated,\n            or when a new native bounding box is explicitly provided in the request.\n            (The native and lat/lon bounding boxes are not automatically recalculated when they are explicitly included in the request.)\n            In addition, the client may explicitly request a fixed set of fields to calculate,\n            by including a comma-separated list of their names in the recalculate parameter.\n            The empty parameter \"recalculate=\" is useful avoid slow recalculation when operating against large datasets\n            as \"recalculate=\" avoids calculating any fields, regardless of any changes to projection, projection policy, etc.\n            The nativebbox parameter \"recalculate=nativebbox\" is used recalculates the native bounding box,\n            while avoiding recalculating the lat/lon bounding box. Recalculate parameters can be used in together -\n            \"recalculate=nativebbox,latlonbbox\" can be used after a bulk import to\n            recalculates both the native bounding box and the lat/lon bounding box.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/workspaces/{workspace}/wmslayers/{name}\"\n    if store is not None:\n        url = f\"{self.service_url}/rest/workspaces/{workspace}/wmsstores/{store}/wmslayers/{name}\"\n\n    params = dict(calculate=calculate)\n    self._request(method=\"put\", url=url, body=body, params=params)\n    return UPDATED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.delete_wms_layer","title":"delete_wms_layer","text":"<pre><code>delete_wms_layer(name: str, *, workspace: str, store: Optional[str] = None, recurse: bool = False) -&gt; str\n</code></pre> <p>Deletes a single WMS layer.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the layer.</p> required <code>workspace</code> <code>str</code> <p>The name of the workspace.</p> required <code>recurse</code> <code>bool</code> <p>Recursively deletes all layers referenced by the specified wmslayer. A request with <code>recurse=false</code> will fail if any layers reference the wmslayer.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def delete_wms_layer(self, name: str, *, workspace: str, store: Optional[str] = None, recurse: bool = False) -&gt; str:\n    \"\"\"Deletes a single WMS layer.\n\n    Args:\n        name: The name of the layer.\n        workspace: The name of the workspace.\n        recurse: Recursively deletes all layers referenced by the specified wmslayer.\n            A request with `recurse=false` will fail if any layers reference the wmslayer.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/workspaces/{workspace}/wmslayers/{name}\"\n    if store is not None:\n        url = f\"{self.service_url}/rest/workspaces/{workspace}/wmsstores/{store}/wmslayers/{name}\"\n\n    params = dict(recurse=recurse)\n    self._request(method=\"delete\", url=url, params=params)\n    return DELETED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.get_wms_stores","title":"get_wms_stores","text":"<pre><code>get_wms_stores(*, workspace: str, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_wms_stores(*, workspace: str, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_wms_stores(*, workspace: str, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>Retrieves the WMS stores available on the server.</p> <p>Parameters:</p> Name Type Description Default <code>workspace</code> <code>str</code> <p>The name of the workspace.</p> required <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The WMS stores.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def get_wms_stores(self, *, workspace: str, format: Literal[\"json\", \"xml\"] = \"json\") -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"Retrieves the WMS stores available on the server.\n\n    Args:\n        workspace: The name of the workspace.\n        format: Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".\n\n    Returns:\n        The WMS stores.\n    \"\"\"\n    url = f\"{self.service_url}/rest/workspaces/{workspace}/wmsstores.{format}\"\n    response = self._request(method=\"get\", url=url)\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.create_wms_store","title":"create_wms_store","text":"<pre><code>create_wms_store(body: Union[str, Dict[str, Any]], *, workspace: str) -&gt; str\n</code></pre> <p>Creates a new WMS store.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>Union[str, Dict[str, Any]]</code> <p>The body of the request used to create the WMS store.</p> required <code>workspace</code> <code>str</code> <p>The name of the workspace.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Example <p>To add a new WMS store to the server, you can use the following code:</p> <pre><code>body = \"\"\"\n&lt;wmsStore&gt;\n    &lt;name&gt;remote&lt;/name&gt;\n    &lt;capabilitiesUrl&gt;http://demo.geoserver.org/geoserver/wms?SERVICE=WMS&amp;VERSION=1.1.1&amp;REQUEST=GetCapabilities&lt;/capabilitiesUrl&gt;\n&lt;/wmsStore&gt;\n\"\"\"\n\ngeoserver.create_wms_store(workspace=\"test\", body=body)\n</code></pre> Source code in <code>geoserver/geoserver.py</code> <pre><code>def create_wms_store(self, body: Union[str, Dict[str, Any]], *, workspace: str) -&gt; str:\n    \"\"\"Creates a new WMS store.\n\n    Args:\n        body: The body of the request used to create the WMS store.\n        workspace: The name of the workspace.\n\n    Returns:\n        Success message.\n\n    Example:\n        To add a new WMS store to the server, you can use the following code:\n\n        ```python\n        body = \\\"\\\"\\\"\n        &lt;wmsStore&gt;\n            &lt;name&gt;remote&lt;/name&gt;\n            &lt;capabilitiesUrl&gt;http://demo.geoserver.org/geoserver/wms?SERVICE=WMS&amp;VERSION=1.1.1&amp;REQUEST=GetCapabilities&lt;/capabilitiesUrl&gt;\n        &lt;/wmsStore&gt;\n        \\\"\\\"\\\"\n\n        geoserver.create_wms_store(workspace=\"test\", body=body)\n        ```\n    \"\"\"\n    url = f\"{self.service_url}/rest/workspaces/{workspace}/wmsstores\"\n    self._request(method=\"post\", url=url, body=body)\n    return CREATED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.get_wms_store","title":"get_wms_store","text":"<pre><code>get_wms_store(name: str, *, workspace: str, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_wms_store(name: str, *, workspace: str, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_wms_store(name: str, *, workspace: str, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>Retrieves a single WMS store.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the WMS store.</p> required <code>workspace</code> <code>str</code> <p>The name of the workspace.</p> required <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The WMS store.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def get_wms_store(\n    self, name: str, *, workspace: str, format: Literal[\"json\", \"xml\"] = \"json\"\n) -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"Retrieves a single WMS store.\n\n    Args:\n        name: The name of the WMS store.\n        workspace: The name of the workspace.\n        format: Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".\n\n    Returns:\n        The WMS store.\n    \"\"\"\n    url = f\"{self.service_url}/rest/workspaces/{workspace}/wmsstores/{name}.{format}\"\n    response = self._request(method=\"get\", url=url)\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.update_wms_store","title":"update_wms_store","text":"<pre><code>update_wms_store(name: str, body: Union[str, Dict[str, Any]], *, workspace: str) -&gt; str\n</code></pre> <p>Modifies a single WMS store.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the WMS store.</p> required <code>workspace</code> <code>str</code> <p>The name of the workspace.</p> required <code>body</code> <code>Union[str, Dict[str, Any]]</code> <p>The body of the request used to modify the WMS store.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def update_wms_store(self, name: str, body: Union[str, Dict[str, Any]], *, workspace: str) -&gt; str:\n    \"\"\"Modifies a single WMS store.\n\n    Args:\n        name: The name of the WMS store.\n        workspace: The name of the workspace.\n        body: The body of the request used to modify the WMS store.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/workspaces/{workspace}/wmsstores/{name}\"\n    self._request(method=\"put\", url=url, body=body)\n    return UPDATED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.delete_wms_store","title":"delete_wms_store","text":"<pre><code>delete_wms_store(name: str, *, workspace: str) -&gt; str\n</code></pre> <p>Deletes a single WMS store.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the WMS store.</p> required <code>workspace</code> <code>str</code> <p>The name of the workspace.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def delete_wms_store(self, name: str, *, workspace: str) -&gt; str:\n    \"\"\"Deletes a single WMS store.\n\n    Args:\n        name: The name of the WMS store.\n        workspace: The name of the workspace.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/workspaces/{workspace}/wmsstores/{name}\"\n    self._request(method=\"delete\", url=url)\n    return DELETED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.get_wmts_layers","title":"get_wmts_layers","text":"<pre><code>get_wmts_layers(*, workspace: str, store: Optional[str] = None, list: Optional[Literal['available']] = None, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_wmts_layers(*, workspace: str, store: Optional[str] = None, list: Optional[Literal['available']] = None, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_wmts_layers(*, workspace: str, store: Optional[str] = None, list: Optional[Literal['available']] = None, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>Retrieves the WMTS layers available on the server.</p> <p>Parameters:</p> Name Type Description Default <code>workspace</code> <code>str</code> <p>The name of the workspace.</p> required <code>store</code> <code>Optional[str]</code> <p>Name of the wmts store.</p> <code>None</code> <code>list</code> <code>Optional[Literal['available']]</code> <p>Set <code>list=available</code> to see all possible layers in the store, not just ones currently published.</p> <code>None</code> <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The WMTS layers.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def get_wmts_layers(\n    self,\n    *,\n    workspace: str,\n    store: Optional[str] = None,\n    list: Optional[Literal[\"available\"]] = None,\n    format: Literal[\"json\", \"xml\"] = \"json\",\n) -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"Retrieves the WMTS layers available on the server.\n\n    Args:\n        workspace: The name of the workspace.\n        store: Name of the wmts store.\n        list: Set `list=available` to see all possible layers in the store, not just ones currently published.\n        format: Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".\n\n    Returns:\n        The WMTS layers.\n    \"\"\"\n    url = f\"{self.service_url}/rest/workspaces/{workspace}/layers.{format}\"\n    if store is not None:\n        url = f\"{self.service_url}/rest/workspaces/{workspace}/wmtsstores/{store}/layers.{format}\"\n\n    params = dict(list=list)\n    response = self._request(method=\"get\", url=url, params=params)\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.wmts_layer_exists","title":"wmts_layer_exists","text":"<pre><code>wmts_layer_exists(name: str, *, workspace: str, store: Optional[str] = None) -&gt; bool\n</code></pre> <p>Check if a WMTS layer exists.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the layer.</p> required <code>workspace</code> <code>str</code> <p>The name of the workspace.</p> required <code>store</code> <code>Optional[str]</code> <p>Name of the wmts store.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if the WMTS layer exists, False otherwise.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def wmts_layer_exists(self, name: str, *, workspace: str, store: Optional[str] = None) -&gt; bool:\n    \"\"\"Check if a WMTS layer exists.\n\n    Args:\n        name: The name of the layer.\n        workspace: The name of the workspace.\n        store: Name of the wmts store.\n\n    Returns:\n        True if the WMTS layer exists, False otherwise.\n    \"\"\"\n    url = f\"{self.service_url}/rest/workspaces/{workspace}/layers/{name}.xml\"\n    if store is not None:\n        url = f\"{self.service_url}/rest/workspaces/{workspace}/wmtsstores/{store}/layers/{name}.xml\"\n\n    response = self._request(method=\"head\", url=url, ignore=[404])\n    return response.status_code == 200\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.create_wmts_layer","title":"create_wmts_layer","text":"<pre><code>create_wmts_layer(body: Union[str, Dict[str, Any]], *, workspace: str, store: Optional[str] = None) -&gt; str\n</code></pre> <p>Creates a new WMTS layer.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>Union[str, Dict[str, Any]]</code> <p>The body of the request used to create the WMTS layer.</p> required <code>workspace</code> <code>str</code> <p>The name of the workspace.</p> required <code>store</code> <code>Optional[str]</code> <p>Name of the wmts store.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def create_wmts_layer(\n    self, body: Union[str, Dict[str, Any]], *, workspace: str, store: Optional[str] = None\n) -&gt; str:\n    \"\"\"Creates a new WMTS layer.\n\n    Args:\n        body: The body of the request used to create the WMTS layer.\n        workspace: The name of the workspace.\n        store: Name of the wmts store.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/workspaces/{workspace}/layers\"\n    if store is not None:\n        url = f\"{self.service_url}/rest/workspaces/{workspace}/wmtsstores/{store}/layers\"\n\n    self._request(method=\"post\", url=url, body=body)\n    return CREATED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.get_wmts_layer","title":"get_wmts_layer","text":"<pre><code>get_wmts_layer(name: str, *, workspace: str, store: Optional[str] = None, quiet_on_not_found: bool = False, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_wmts_layer(name: str, *, workspace: str, store: Optional[str] = None, quiet_on_not_found: bool = False, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_wmts_layer(name: str, *, workspace: str, store: Optional[str] = None, quiet_on_not_found: bool = False, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>Retrieves a single WMTS layer.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the layer.</p> required <code>workspace</code> <code>str</code> <p>The name of the workspace.</p> required <code>store</code> <code>Optional[str]</code> <p>Optional. Name of the wmts store.</p> <code>None</code> <code>quiet_on_not_found</code> <code>bool</code> <p>Optional. When set to \"true\", will not log an exception when the style is not present. The 404 status code will still be returned.</p> <code>False</code> <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The WMTS layer.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def get_wmts_layer(\n    self,\n    name: str,\n    *,\n    workspace: str,\n    store: Optional[str] = None,\n    quiet_on_not_found: bool = False,\n    format: Literal[\"json\", \"xml\"] = \"json\",\n) -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"Retrieves a single WMTS layer.\n\n    Args:\n        name: The name of the layer.\n        workspace: The name of the workspace.\n        store: Optional. Name of the wmts store.\n        quiet_on_not_found: Optional. When set to \"true\", will not log an exception when the style is not present.\n            The 404 status code will still be returned.\n        format: Optional. The format of the response. It can be either \"json\" or \"xml\". Defaults to \"json\".\n\n    Returns:\n        The WMTS layer.\n    \"\"\"\n    url = f\"{self.service_url}/rest/workspaces/{workspace}/layers/{name}.{format}\"\n    if store is not None:\n        url = f\"{self.service_url}/rest/workspaces/{workspace}/wmtsstores/{store}/layers/{name}.{format}\"\n\n    params = dict(quietOnNotFound=quiet_on_not_found)\n    response = self._request(method=\"get\", url=url, params=params)\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.update_wmts_layer","title":"update_wmts_layer","text":"<pre><code>update_wmts_layer(name: str, body: Union[str, Dict[str, Any]], *, workspace: str, store: Optional[str] = None) -&gt; str\n</code></pre> <p>Modifies a single WMTS layer.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the layer.</p> required <code>body</code> <code>Union[str, Dict[str, Any]]</code> <p>The body of the request used to modify the WMTS layer.</p> required <code>workspace</code> <code>str</code> <p>The name of the workspace.</p> required <code>store</code> <code>Optional[str]</code> <p>Name of the wmts store.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def update_wmts_layer(\n    self, name: str, body: Union[str, Dict[str, Any]], *, workspace: str, store: Optional[str] = None\n) -&gt; str:\n    \"\"\"Modifies a single WMTS layer.\n\n    Args:\n        name: The name of the layer.\n        body: The body of the request used to modify the WMTS layer.\n        workspace: The name of the workspace.\n        store: Name of the wmts store.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/workspaces/{workspace}/layers/{name}\"\n    if store is not None:\n        url = f\"{self.service_url}/rest/workspaces/{workspace}/wmtsstores/{store}/layers/{name}\"\n\n    self._request(method=\"put\", url=url, body=body)\n    return UPDATED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.delete_wmts_layer","title":"delete_wmts_layer","text":"<pre><code>delete_wmts_layer(name: str, *, workspace: str, store: Optional[str] = None, recurse: bool = False) -&gt; str\n</code></pre> <p>Deletes a single WMTS layer.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the layer.</p> required <code>workspace</code> <code>str</code> <p>The name of the workspace.</p> required <code>store</code> <code>Optional[str]</code> <p>Name of the wmts store.</p> <code>None</code> <code>recurse</code> <code>bool</code> <p>Recursively deletes all layers referenced by the specified wmtslayer. A request with <code>recurse=false</code> will fail if any layers reference the wmtslayer.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def delete_wmts_layer(\n    self, name: str, *, workspace: str, store: Optional[str] = None, recurse: bool = False\n) -&gt; str:\n    \"\"\"Deletes a single WMTS layer.\n\n    Args:\n        name: The name of the layer.\n        workspace: The name of the workspace.\n        store: Name of the wmts store.\n        recurse: Recursively deletes all layers referenced by the specified wmtslayer.\n            A request with `recurse=false` will fail if any layers reference the wmtslayer.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/workspaces/{workspace}/layers/{name}\"\n    if store is not None:\n        url = f\"{self.service_url}/rest/workspaces/{workspace}/wmtsstores/{store}/layers/{name}\"\n\n    params = dict(recurse=recurse)\n    self._request(method=\"delete\", url=url, params=params)\n    return DELETED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.get_wmts_stores","title":"get_wmts_stores","text":"<pre><code>get_wmts_stores(*, workspace: str, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_wmts_stores(*, workspace: str, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_wmts_stores(*, workspace: str, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>Retrieves the WMTS stores available on the server.</p> <p>Parameters:</p> Name Type Description Default <code>workspace</code> <code>str</code> <p>The name of the workspace.</p> required <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response. Can be either \"json\" or \"xml\".</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The WMTS stores.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def get_wmts_stores(self, *, workspace: str, format: Literal[\"json\", \"xml\"] = \"json\") -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"Retrieves the WMTS stores available on the server.\n\n    Args:\n        workspace: The name of the workspace.\n        format: Optional. The format of the response. Can be either \"json\" or \"xml\".\n\n    Returns:\n        The WMTS stores.\n    \"\"\"\n    url = f\"{self.service_url}/rest/workspaces/{workspace}/wmtsstores.{format}\"\n    response = self._request(method=\"get\", url=url)\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.wmts_store_exists","title":"wmts_store_exists","text":"<pre><code>wmts_store_exists(name: str, *, workspace: str) -&gt; bool\n</code></pre> <p>Checks if a WMTS store exists on the server.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the WMTS store.</p> required <code>workspace</code> <code>str</code> <p>The name of the workspace.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the WMTS store exists, False otherwise.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def wmts_store_exists(self, name: str, *, workspace: str) -&gt; bool:\n    \"\"\"Checks if a WMTS store exists on the server.\n\n    Args:\n        name: The name of the WMTS store.\n        workspace: The name of the workspace.\n\n    Returns:\n        True if the WMTS store exists, False otherwise.\n    \"\"\"\n    url = f\"{self.service_url}/rest/workspaces/{workspace}/wmtsstores/{name}.xml\"\n    response = self._request(method=\"head\", url=url, ignore=[404])\n    return response.status_code == 200\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.create_wmts_store","title":"create_wmts_store","text":"<pre><code>create_wmts_store(body: Union[str, Dict[str, Any]], *, workspace: str) -&gt; str\n</code></pre> <p>Creates a new WMTS store.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>Union[str, Dict[str, Any]]</code> <p>The body of the request used to create the WMTS store.</p> required <code>workspace</code> <code>str</code> <p>The name of the workspace.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def create_wmts_store(self, body: Union[str, Dict[str, Any]], *, workspace: str) -&gt; str:\n    \"\"\"Creates a new WMTS store.\n\n    Args:\n        body: The body of the request used to create the WMTS store.\n        workspace: The name of the workspace.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/workspaces/{workspace}/wmtsstores\"\n    self._request(method=\"post\", url=url, body=body)\n    return CREATED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.get_wmts_store","title":"get_wmts_store","text":"<pre><code>get_wmts_store(name: str, *, workspace: str, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_wmts_store(name: str, *, workspace: str, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_wmts_store(name: str, *, workspace: str, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>Retrieves a single WMTS store.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the WMTS store.</p> required <code>workspace</code> <code>str</code> <p>The name of the workspace.</p> required <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response. Can be either \"json\" or \"xml\".</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The WMTS store.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def get_wmts_store(\n    self, name: str, *, workspace: str, format: Literal[\"json\", \"xml\"] = \"json\"\n) -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"Retrieves a single WMTS store.\n\n    Args:\n        name: The name of the WMTS store.\n        workspace: The name of the workspace.\n        format: Optional. The format of the response. Can be either \"json\" or \"xml\".\n\n    Returns:\n        The WMTS store.\n    \"\"\"\n    url = f\"{self.service_url}/rest/workspaces/{workspace}/wmtsstores/{name}.{format}\"\n    response = self._request(method=\"get\", url=url)\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.update_wmts_store","title":"update_wmts_store","text":"<pre><code>update_wmts_store(name: str, body: Union[str, Dict[str, Any]], *, workspace: str) -&gt; str\n</code></pre> <p>Modifies a single WMTS store.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the WMTS store.</p> required <code>body</code> <code>Union[str, Dict[str, Any]]</code> <p>The body of the request used to modify the WMTS store.</p> required <code>workspace</code> <code>str</code> <p>The name of the workspace.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def update_wmts_store(self, name: str, body: Union[str, Dict[str, Any]], *, workspace: str) -&gt; str:\n    \"\"\"Modifies a single WMTS store.\n\n    Args:\n        name: The name of the WMTS store.\n        body: The body of the request used to modify the WMTS store.\n        workspace: The name of the workspace.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/workspaces/{workspace}/wmtsstores/{name}\"\n    self._request(method=\"put\", url=url, body=body)\n    return UPDATED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.delete_wmts_store","title":"delete_wmts_store","text":"<pre><code>delete_wmts_store(name: str, *, workspace: str) -&gt; str\n</code></pre> <p>Deletes a single WMTS store.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the WMTS store.</p> required <code>workspace</code> <code>str</code> <p>The name of the workspace.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def delete_wmts_store(self, name: str, *, workspace: str) -&gt; str:\n    \"\"\"Deletes a single WMTS store.\n\n    Args:\n        name: The name of the WMTS store.\n        workspace: The name of the workspace.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/workspaces/{workspace}/wmtsstores/{name}\"\n    self._request(method=\"delete\", url=url)\n    return DELETED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.get_workspaces","title":"get_workspaces","text":"<pre><code>get_workspaces(*, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_workspaces(*, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_workspaces(*, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>Displays a list of all workspaces on the server.</p> <p>Parameters:</p> Name Type Description Default <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response. Can be either \"json\" or \"xml\".</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The workspaces.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def get_workspaces(self, *, format: Literal[\"json\", \"xml\"] = \"json\") -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"Displays a list of all workspaces on the server.\n\n    Args:\n        format: Optional. The format of the response. Can be either \"json\" or \"xml\".\n\n    Returns:\n        The workspaces.\n    \"\"\"\n    url = f\"{self.service_url}/rest/workspaces.{format}\"\n    response = self._request(method=\"get\", url=url)\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.workspace_exists","title":"workspace_exists","text":"<pre><code>workspace_exists(name: str) -&gt; bool\n</code></pre> <p>Checks if a workspace exists on the server.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the workspace.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the workspace exists, False otherwise.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def workspace_exists(self, name: str) -&gt; bool:\n    \"\"\"Checks if a workspace exists on the server.\n\n    Args:\n        name: The name of the workspace.\n\n    Returns:\n        True if the workspace exists, False otherwise.\n    \"\"\"\n    url = f\"{self.service_url}/rest/workspaces/{name}.xml\"\n    response = self._request(method=\"head\", url=url, ignore=[404])\n    return response.status_code == 200\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.create_workspace","title":"create_workspace","text":"<pre><code>create_workspace(body: Union[str, Dict[str, Any]]) -&gt; str\n</code></pre> <p>Creates a new workspace.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>Union[str, Dict[str, Any]]</code> <p>The body of the request used to create the workspace.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def create_workspace(self, body: Union[str, Dict[str, Any]]) -&gt; str:\n    \"\"\"Creates a new workspace.\n\n    Args:\n        body: The body of the request used to create the workspace.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/workspaces\"\n    self._request(method=\"post\", url=url, body=body)\n    return CREATED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.create_workspace_from_name","title":"create_workspace_from_name","text":"<pre><code>create_workspace_from_name(name: str) -&gt; str\n</code></pre> <p>Shortcut to create a new workspace from a name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the workspace.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def create_workspace_from_name(self, name: str) -&gt; str:\n    \"\"\"Shortcut to create a new workspace from a name.\n\n    Args:\n        name: The name of the workspace.\n\n    Returns:\n        Success message.\n    \"\"\"\n    body = {\"workspace\": {\"name\": name}}\n    return self.create_workspace(body=body)\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.get_workspace","title":"get_workspace","text":"<pre><code>get_workspace(name: str, *, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_workspace(name: str, *, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_workspace(name: str, *, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>Displays a single workspace on the server.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the workspace.</p> required <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response. Can be either \"json\" or \"xml\".</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The workspace.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def get_workspace(self, name: str, *, format: Literal[\"json\", \"xml\"] = \"json\") -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"Displays a single workspace on the server.\n\n    Args:\n        name: The name of the workspace.\n        format: Optional. The format of the response. Can be either \"json\" or \"xml\".\n\n    Returns:\n        The workspace.\n    \"\"\"\n    url = f\"{self.service_url}/rest/workspaces/{name}.{format}\"\n    response = self._request(method=\"get\", url=url)\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.update_workspace","title":"update_workspace","text":"<pre><code>update_workspace(name: str, body: Union[str, Dict[str, Any]]) -&gt; str\n</code></pre> <p>Modifies a single workspace.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the workspace.</p> required <code>body</code> <code>Union[str, Dict[str, Any]]</code> <p>The body of the request used to modify the workspace.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def update_workspace(self, name: str, body: Union[str, Dict[str, Any]]) -&gt; str:\n    \"\"\"Modifies a single workspace.\n\n    Args:\n        name: The name of the workspace.\n        body: The body of the request used to modify the workspace.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/workspaces/{name}\"\n    self._request(method=\"put\", url=url, body=body)\n    return UPDATED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.delete_workspace","title":"delete_workspace","text":"<pre><code>delete_workspace(name: str, *, recurse: bool = False) -&gt; str\n</code></pre> <p>Deletes a single workspace.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the workspace.</p> required <code>recurse</code> <code>bool</code> <p>Optional. Recursively deletes all resources in the workspace. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def delete_workspace(self, name: str, *, recurse: bool = False) -&gt; str:\n    \"\"\"Deletes a single workspace.\n\n    Args:\n        name: The name of the workspace.\n        recurse: Optional. Recursively deletes all resources in the workspace. Defaults to False.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/workspaces/{name}\"\n    params = dict(recurse=recurse)\n    self._request(method=\"delete\", url=url, params=params)\n    return DELETED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.get_users","title":"get_users","text":"<pre><code>get_users(*, service: Optional[str] = None, group: Optional[str] = None, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_users(*, service: Optional[str] = None, group: Optional[str] = None, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_users(*, service: Optional[str] = None, group: Optional[str] = None, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>Query all users in the default user/group service.</p> <p>Parameters:</p> Name Type Description Default <code>service</code> <code>Optional[str]</code> <p>Optional. The name of the user/group service.</p> <code>None</code> <code>group</code> <code>Optional[str]</code> <p>Optional. The name of the group.</p> <code>None</code> <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response. Can be either \"json\" or \"xml\".</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The users.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def get_users(\n    self, *, service: Optional[str] = None, group: Optional[str] = None, format: Literal[\"json\", \"xml\"] = \"json\"\n) -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"Query all users in the default user/group service.\n\n    Args:\n        service: Optional. The name of the user/group service.\n        group: Optional. The name of the group.\n        format: Optional. The format of the response. Can be either \"json\" or \"xml\".\n\n    Returns:\n        The users.\n    \"\"\"\n    if service is None and group is None:\n        url = f\"{self.service_url}/rest/security/usergroup/users.{format}\"\n    elif service is not None and group is None:\n        url = f\"{self.service_url}/rest/security/usergroup/service/{service}/users.{format}\"\n    elif service is None and group is not None:\n        url = f\"{self.service_url}/rest/security/usergroup/group/{group}/users.{format}\"\n    else:\n        raise ValueError(\"Invalid combination of service and group.\")\n\n    response = self._request(method=\"get\", url=url)\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.create_user","title":"create_user","text":"<pre><code>create_user(body: Union[str, Dict[str, Any]], *, service: Optional[str] = None) -&gt; str\n</code></pre> <p>Add a new user to the default user/group service.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>Union[str, Dict[str, Any]]</code> <p>The body of the request used to create the user.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Example <p>To add a new user to the default user/group service, you can use the following code:</p> <pre><code>body = {\n    \"userName\": \"user\",\n    \"password\": \"password\",\n    \"enabled\": \"true\",\n}\ngeoserver.create_user(body=body)\n</code></pre> Source code in <code>geoserver/geoserver.py</code> <pre><code>def create_user(self, body: Union[str, Dict[str, Any]], *, service: Optional[str] = None) -&gt; str:\n    \"\"\"Add a new user to the default user/group service.\n\n    Args:\n        body: The body of the request used to create the user.\n\n    Returns:\n        Success message.\n\n    Example:\n        To add a new user to the default user/group service, you can use the following code:\n\n        ```python\n        body = {\n            \"userName\": \"user\",\n            \"password\": \"password\",\n            \"enabled\": \"true\",\n        }\n        geoserver.create_user(body=body)\n        ```\n    \"\"\"\n    url = f\"{self.service_url}/rest/security/usergroup/users\"\n    if service is not None:\n        url = f\"{self.service_url}/rest/security/usergroup/service/{service}/users\"\n\n    self._request(method=\"post\", url=url, body=body)\n    return CREATED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.update_user","title":"update_user","text":"<pre><code>update_user(name: str, body: Union[str, Dict[str, Any]], *, service: Optional[str] = None) -&gt; str\n</code></pre> <p>Update an existing user in the default user/group service.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the user.</p> required <code>body</code> <code>Union[str, Dict[str, Any]]</code> <p>The body of the request used to modify the user.</p> required <code>service</code> <code>Optional[str]</code> <p>The name of the user/group service.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Example <p>To update an existing user in the default user/group service, you can use the following code:</p> <pre><code>body = \"\"\"\n&lt;user&gt;\n    &lt;userName&gt;user&lt;/userName&gt;\n    &lt;password&gt;password&lt;/password&gt;\n    &lt;enabled&gt;true&lt;/enabled&gt;\n&lt;/user&gt;\n\"\"\"\n\ngeoserver.update_user(\"my_user\", body=body)\n</code></pre> Source code in <code>geoserver/geoserver.py</code> <pre><code>def update_user(self, name: str, body: Union[str, Dict[str, Any]], *, service: Optional[str] = None) -&gt; str:\n    \"\"\"Update an existing user in the default user/group service.\n\n    Args:\n        name: The name of the user.\n        body: The body of the request used to modify the user.\n        service: The name of the user/group service.\n\n    Returns:\n        Success message.\n\n    Example:\n        To update an existing user in the default user/group service, you can use the following code:\n\n        ```python\n        body = \\\"\\\"\\\"\n        &lt;user&gt;\n            &lt;userName&gt;user&lt;/userName&gt;\n            &lt;password&gt;password&lt;/password&gt;\n            &lt;enabled&gt;true&lt;/enabled&gt;\n        &lt;/user&gt;\n        \\\"\\\"\\\"\n\n        geoserver.update_user(\"my_user\", body=body)\n        ```\n    \"\"\"\n    url = f\"{self.service_url}/rest/security/usergroup/user/{name}\"\n    if service is not None:\n        url = f\"{self.service_url}/rest/security/usergroup/service/{service}/user/{name}\"\n\n    self._request(method=\"post\", url=url, body=body)\n    return UPDATED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.delete_user","title":"delete_user","text":"<pre><code>delete_user(name: str, *, service: Optional[str] = None) -&gt; str\n</code></pre> <p>Remove an existing user from the default user/group service.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the user.</p> required <code>service</code> <code>Optional[str]</code> <p>The name of the user/group service.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def delete_user(self, name: str, *, service: Optional[str] = None) -&gt; str:\n    \"\"\"Remove an existing user from the default user/group service.\n\n    Args:\n        name: The name of the user.\n        service: The name of the user/group service.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/security/usergroup/user/{name}\"\n    if service is not None:\n        url = f\"{self.service_url}/rest/security/usergroup/service/{service}/user/{name}\"\n\n    self._request(method=\"delete\", url=url)\n    return DELETED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.get_user_groups","title":"get_user_groups","text":"<pre><code>get_user_groups(*, user: str, service: Optional[str] = None, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_user_groups(*, user: str, service: Optional[str] = None, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_user_groups(*, user: str, service: Optional[str] = None, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>Query all groups in the default user/group service.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>str</code> <p>The name of the user.</p> required <code>service</code> <code>Optional[str]</code> <p>Optional. The name of the user/group service.</p> <code>None</code> <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response. Can be either \"json\" or \"xml\".</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The groups.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def get_user_groups(\n    self, *, user: str, service: Optional[str] = None, format: Literal[\"json\", \"xml\"] = \"json\"\n) -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"Query all groups in the default user/group service.\n\n    Args:\n        user: The name of the user.\n        service: Optional. The name of the user/group service.\n        format: Optional. The format of the response. Can be either \"json\" or \"xml\".\n\n    Returns:\n        The groups.\n    \"\"\"\n    url = f\"{self.service_url}/rest/security/usergroup/user/{user}/groups.{format}\"\n    if service is not None:\n        url = f\"{self.service_url}/rest/security/usergroup/service/{service}/user/{user}/groups.{format}\"\n\n    response = self._request(method=\"get\", url=url)\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.associate_user","title":"associate_user","text":"<pre><code>associate_user(user: str, group: str, *, service: Optional[str] = None) -&gt; str\n</code></pre> <p>Associate a user with a group in the default user/group service.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>str</code> <p>The name of the user.</p> required <code>group</code> <code>str</code> <p>The name of the group.</p> required <code>service</code> <code>Optional[str]</code> <p>The name of the user/group service.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def associate_user(self, user: str, group: str, *, service: Optional[str] = None) -&gt; str:\n    \"\"\"Associate a user with a group in the default user/group service.\n\n    Args:\n        user: The name of the user.\n        group: The name of the group.\n        service: The name of the user/group service.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/security/usergroup/user/{user}/group/{group}\"\n    if service is not None:\n        url = f\"{self.service_url}/rest/security/usergroup/service/{service}/user/{user}/group/{group}\"\n\n    self._request(method=\"post\", url=url)\n    return OK_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.disassociate_user","title":"disassociate_user","text":"<pre><code>disassociate_user(user: str, group: str, *, service: Optional[str] = None) -&gt; str\n</code></pre> <p>Remove a user from a group in the default user/group service.</p> <p>Parameters:</p> Name Type Description Default <code>user</code> <code>str</code> <p>The name of the user.</p> required <code>group</code> <code>str</code> <p>The name of the group.</p> required <code>service</code> <code>Optional[str]</code> <p>The name of the user/group service.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def disassociate_user(self, user: str, group: str, *, service: Optional[str] = None) -&gt; str:\n    \"\"\"Remove a user from a group in the default user/group service.\n\n    Args:\n        user: The name of the user.\n        group: The name of the group.\n        service: The name of the user/group service.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/security/usergroup/user/{user}/group/{group}\"\n    if service is not None:\n        url = f\"{self.service_url}/rest/security/usergroup/service/{service}/user/{user}/group/{group}\"\n\n    self._request(method=\"delete\", url=url)\n    return OK_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.create_user_group","title":"create_user_group","text":"<pre><code>create_user_group(name: str, *, service: Optional[str] = None) -&gt; str\n</code></pre> <p>Add a new group to the default user/group service.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the group.</p> required <code>service</code> <code>Optional[str]</code> <p>The name of the user/group service.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def create_user_group(self, name: str, *, service: Optional[str] = None) -&gt; str:\n    \"\"\"Add a new group to the default user/group service.\n\n    Args:\n        name: The name of the group.\n        service: The name of the user/group service.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/security/usergroup/group/{name}\"\n    if service is not None:\n        url = f\"{self.service_url}/rest/security/usergroup/service/{service}/group/{name}\"\n\n    self._request(method=\"post\", url=url)\n    return OK_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.delete_user_group","title":"delete_user_group","text":"<pre><code>delete_user_group(name: str, *, service: Optional[str] = None) -&gt; str\n</code></pre> <p>Remove a group from the default user/group service.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the group.</p> required <code>service</code> <code>Optional[str]</code> <p>The name of the user/group service.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Example <p>To remove a group from the default user/group service, you can use the following code:</p> <pre><code>geoserver.delete_group(group=\"group\")\n</code></pre> Source code in <code>geoserver/geoserver.py</code> <pre><code>def delete_user_group(self, name: str, *, service: Optional[str] = None) -&gt; str:\n    \"\"\"Remove a group from the default user/group service.\n\n    Args:\n        name: The name of the group.\n        service: The name of the user/group service.\n\n    Returns:\n        Success message.\n\n    Example:\n        To remove a group from the default user/group service, you can use the following code:\n\n        ```python\n        geoserver.delete_group(group=\"group\")\n        ```\n    \"\"\"\n    url = f\"{self.service_url}/rest/security/usergroup/group/{name}\"\n    if service is not None:\n        url = f\"{self.service_url}/rest/security/usergroup/service/{service}/group/{name}\"\n\n    self._request(method=\"delete\", url=url)\n    return OK_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.get_roles","title":"get_roles","text":"<pre><code>get_roles(*, service: Optional[str] = None, group: Optional[str] = None, user: Optional[str] = None, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_roles(*, service: Optional[str] = None, group: Optional[str] = None, user: Optional[str] = None, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_roles(*, service: Optional[str] = None, group: Optional[str] = None, user: Optional[str] = None, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>Query all roles in the default user/group service.</p> <p>Parameters:</p> Name Type Description Default <code>service</code> <code>Optional[str]</code> <p>Optional. The name of the user/group service.</p> <code>None</code> <code>group</code> <code>Optional[str]</code> <p>Optional. The name of the group.</p> <code>None</code> <code>user</code> <code>Optional[str]</code> <p>Optional. The name of the user.</p> <code>None</code> <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response. Can be either \"json\" or \"xml\".</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The roles.</p> Example <p>To get all roles in the default user/group service, you can use the following code:</p> <pre><code>geoserver.get_roles()\n</code></pre> Source code in <code>geoserver/geoserver.py</code> <pre><code>def get_roles(\n    self,\n    *,\n    service: Optional[str] = None,\n    group: Optional[str] = None,\n    user: Optional[str] = None,\n    format: Literal[\"json\", \"xml\"] = \"json\",\n) -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"Query all roles in the default user/group service.\n\n    Args:\n        service: Optional. The name of the user/group service.\n        group: Optional. The name of the group.\n        user: Optional. The name of the user.\n        format: Optional. The format of the response. Can be either \"json\" or \"xml\".\n\n    Returns:\n        The roles.\n\n    Example:\n        To get all roles in the default user/group service, you can use the following code:\n\n        ```python\n        geoserver.get_roles()\n        ```\n    \"\"\"\n    if service is None and group is None and user is None:\n        url = f\"{self.service_url}/rest/security/roles.{format}\"\n    elif service is not None and group is None and user is None:\n        url = f\"{self.service_url}/rest/security/roles/service/{service}.{format}\"\n    elif service is None and group is not None and user is None:\n        url = f\"{self.service_url}/rest/security/roles/group/{group}.{format}\"\n    elif service is not None and group is not None and user is None:\n        url = f\"{self.service_url}/rest/security/roles/service/{service}/group/{group}.{format}\"\n    elif service is not None and group is None and user is not None:\n        url = f\"{self.service_url}/rest/security/roles/service/{service}/user/{user}.{format}\"\n    else:\n        raise ValueError(\"Invalid combination of service, group and user.\")\n\n    response = self._request(method=\"get\", url=url)\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.create_role","title":"create_role","text":"<pre><code>create_role(name: str) -&gt; str\n</code></pre> <p>Add a new role to the default user/group service.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the role.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def create_role(self, name: str) -&gt; str:\n    \"\"\"Add a new role to the default user/group service.\n\n    Args:\n        name: The name of the role.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/security/roles/role/{name}\"\n\n    self._request(method=\"post\", url=url)\n    return CREATED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.delete_role","title":"delete_role","text":"<pre><code>delete_role(name: str) -&gt; str\n</code></pre> <p>Remove a role from the default user/group service.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the role.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geoserver.py</code> <pre><code>def delete_role(self, name: str) -&gt; str:\n    \"\"\"Remove a role from the default user/group service.\n\n    Args:\n        name: The name of the role.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/rest/security/roles/role/{name}\"\n\n    self._request(method=\"delete\", url=url)\n    return DELETED_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.associate_role","title":"associate_role","text":"<pre><code>associate_role(role: str, *, service: Optional[str] = None, group: Optional[str] = None, user: Optional[str] = None) -&gt; str\n</code></pre> <p>Associate a user with a role in the default user/group service.</p> <p>Parameters:</p> Name Type Description Default <code>role</code> <code>str</code> <p>The name of the role.</p> required <code>service</code> <code>Optional[str]</code> <p>The name of the user/group service.</p> <code>None</code> <code>group</code> <code>Optional[str]</code> <p>The name of the group.</p> <code>None</code> <code>user</code> <code>Optional[str]</code> <p>The name of the user.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Example <p>To associate a user with a role in the default user/group service, you can use the following code:</p> <pre><code>geoserver.associate_role(role=\"ROLE_ADMIN\", user=\"admin\")\n</code></pre> Source code in <code>geoserver/geoserver.py</code> <pre><code>def associate_role(\n    self, role: str, *, service: Optional[str] = None, group: Optional[str] = None, user: Optional[str] = None\n) -&gt; str:\n    \"\"\"Associate a user with a role in the default user/group service.\n\n    Args:\n        role: The name of the role.\n        service: The name of the user/group service.\n        group: The name of the group.\n        user: The name of the user.\n\n    Returns:\n        Success message.\n\n    Example:\n        To associate a user with a role in the default user/group service, you can use the following code:\n\n        ```python\n        geoserver.associate_role(role=\"ROLE_ADMIN\", user=\"admin\")\n        ```\n    \"\"\"\n    if service is not None and group is None and user is None:\n        url = f\"{self.service_url}/rest/security/roles/service/{service}/role/{role}\"\n    elif service is None and group is None and user is not None:\n        url = f\"{self.service_url}/rest/security/roles/role/{role}/user/{user}\"\n    elif service is None and group is not None and user is None:\n        url = f\"{self.service_url}/rest/security/roles/role/{role}/group/{group}\"\n    elif service is not None and group is None and user is not None:\n        url = f\"{self.service_url}/rest/security/roles/service/{service}/role/{role}/user/{user}\"\n    elif service is not None and group is not None and user is None:\n        url = f\"{self.service_url}/rest/security/roles/service/{service}/role/{role}/group/{group}\"\n    else:\n        raise ValueError(\"Invalid combination of service, group and user.\")\n\n    self._request(method=\"post\", url=url)\n    return OK_MESSAGE\n</code></pre>"},{"location":"api/geoserver/#geoserver.geoserver.GeoServer.disassociate_role","title":"disassociate_role","text":"<pre><code>disassociate_role(role: str, *, service: Optional[str] = None, group: Optional[str] = None, user: Optional[str] = None) -&gt; str\n</code></pre> <p>Disassociate a user with a role in the default user/group service.</p> <p>Parameters:</p> Name Type Description Default <code>role</code> <code>str</code> <p>The name of the role.</p> required <code>service</code> <code>Optional[str]</code> <p>The name of the user/group service.</p> <code>None</code> <code>group</code> <code>Optional[str]</code> <p>The name of the group.</p> <code>None</code> <code>user</code> <code>Optional[str]</code> <p>The name of the user.</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Example <p>To disassociate a user from a role in the default user/group service, you can use the following code:</p> <pre><code>geoserver.disassociate_role(role=\"ROLE_ADMIN\", user=\"admin\")\n</code></pre> Source code in <code>geoserver/geoserver.py</code> <pre><code>def disassociate_role(\n    self, role: str, *, service: Optional[str] = None, group: Optional[str] = None, user: Optional[str] = None\n) -&gt; str:\n    \"\"\"Disassociate a user with a role in the default user/group service.\n\n    Args:\n        role: The name of the role.\n        service: The name of the user/group service.\n        group: The name of the group.\n        user: The name of the user.\n\n    Returns:\n        Success message.\n\n    Example:\n        To disassociate a user from a role in the default user/group service, you can use the following code:\n\n        ```python\n        geoserver.disassociate_role(role=\"ROLE_ADMIN\", user=\"admin\")\n        ```\n    \"\"\"\n    if service is not None and group is None and user is None:\n        url = f\"{self.service_url}/rest/security/roles/service/{service}/role/{role}\"\n    elif service is None and group is None and user is not None:\n        url = f\"{self.service_url}/rest/security/roles/role/{role}/user/{user}\"\n    elif service is None and group is not None and user is None:\n        url = f\"{self.service_url}/rest/security/roles/role/{role}/group/{group}\"\n    elif service is not None and group is None and user is not None:\n        url = f\"{self.service_url}/rest/security/roles/service/{service}/role/{role}/user/{user}\"\n    elif service is not None and group is not None and user is None:\n        url = f\"{self.service_url}/rest/security/roles/service/{service}/role/{role}/group/{group}\"\n    else:\n        raise ValueError(\"Invalid combination of service, group and user.\")\n\n    self._request(method=\"delete\", url=url)\n    return OK_MESSAGE\n</code></pre>"},{"location":"api/geowebcache/","title":"GeoWebCache","text":"<p>               Bases: <code>Base</code></p> Source code in <code>geoserver/base.py</code> <pre><code>def __init__(\n    self,\n    service_url: str = \"http://localhost:8080/geoserver\",\n    username: Optional[str] = None,\n    password: Optional[str] = None,\n    headers: Optional[Dict[str, Any]] = None,\n    cookies: Optional[Dict[str, Any]] = None,\n    auth: Optional[AuthBase] = None,\n    allow_redirects: bool = True,\n    proxies: Any = None,\n    verify: bool = True,\n    cert: Optional[str] = None,\n):\n    if auth is None and username is not None and password is not None:\n        auth = HTTPBasicAuth(username, password)\n\n    self.service_url = service_url.rstrip(\"/\")\n    self.auth = auth\n    self.headers = headers or {}\n    self.cookies = cookies or {}\n    self.allow_redirects = allow_redirects\n    self.proxies = proxies or {}\n    self.verify = verify\n    self.cert = cert\n</code></pre>"},{"location":"api/geowebcache/#geoserver.geowebcache.GeoWebCache.get_blob_stores","title":"get_blob_stores","text":"<pre><code>get_blob_stores(*, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_blob_stores(*, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_blob_stores(*, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>Retrieves the blob stores available on the server.</p> <p>Parameters:</p> Name Type Description Default <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response.</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The blob stores.</p> Source code in <code>geoserver/geowebcache.py</code> <pre><code>def get_blob_stores(self, *, format: Literal[\"json\", \"xml\"] = \"json\") -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"Retrieves the blob stores available on the server.\n\n    Args:\n        format: Optional. The format of the response.\n\n    Returns:\n        The blob stores.\n    \"\"\"\n    url = f\"{self.service_url}/gwc/rest/blobstores.{format}\"\n    response = self._request(method=\"get\", url=url)\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geowebcache/#geoserver.geowebcache.GeoWebCache.get_blob_store","title":"get_blob_store","text":"<pre><code>get_blob_store(name: str, *, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_blob_store(name: str, *, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_blob_store(name: str, *, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>Retrieves a single blob store.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the blob store.</p> required <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response.</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The blob store.</p> Source code in <code>geoserver/geowebcache.py</code> <pre><code>def get_blob_store(self, name: str, *, format: Literal[\"json\", \"xml\"] = \"json\") -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"Retrieves a single blob store.\n\n    Args:\n        name: The name of the blob store.\n        format: Optional. The format of the response.\n\n    Returns:\n        The blob store.\n    \"\"\"\n    url = f\"{self.service_url}/gwc/rest/blobstores/{name}\"\n    response = self._request(method=\"get\", url=url)\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geowebcache/#geoserver.geowebcache.GeoWebCache.insert_blob_store","title":"insert_blob_store","text":"<pre><code>insert_blob_store(name: str, body: Union[str, Dict[str, Any]]) -&gt; str\n</code></pre> <p>Creates a new blob store.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the blob store.</p> required <code>body</code> <code>Union[str, Dict[str, Any]]</code> <p>The body of the request used to create the blob store.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geowebcache.py</code> <pre><code>def insert_blob_store(self, name: str, body: Union[str, Dict[str, Any]]) -&gt; str:\n    \"\"\"Creates a new blob store.\n\n    Args:\n        name: The name of the blob store.\n        body: The body of the request used to create the blob store.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/gwc/rest/blobstores/{name}.json\"\n    self._request(method=\"post\", url=url, body=body)\n    return CREATED_MESSAGE\n</code></pre>"},{"location":"api/geowebcache/#geoserver.geowebcache.GeoWebCache.delete_blob_store","title":"delete_blob_store","text":"<pre><code>delete_blob_store(name: str) -&gt; str\n</code></pre> <p>Deletes a single blob store.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the blob store.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geowebcache.py</code> <pre><code>def delete_blob_store(self, name: str) -&gt; str:\n    \"\"\"Deletes a single blob store.\n\n    Args:\n        name: The name of the blob store.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/gwc/rest/blobstores/{name}\"\n    self._request(method=\"delete\", url=url)\n    return DELETED_MESSAGE\n</code></pre>"},{"location":"api/geowebcache/#geoserver.geowebcache.GeoWebCache.get_layer_bounds","title":"get_layer_bounds","text":"<pre><code>get_layer_bounds(layer: str, srs: str, type: str, *, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_layer_bounds(layer: str, srs: str, type: str, *, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_layer_bounds(layer: str, srs: str, type: str, *, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>Retrieves the bounds for a layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer</code> <code>str</code> <p>The name of the layer.</p> required <code>srs</code> <code>str</code> <p>The srs projection used against the layer to find the bounds such as EPSG:4326.</p> required <code>type</code> <code>str</code> <p>Accepts java as an extension.</p> required <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response.</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The bounds.</p> Source code in <code>geoserver/geowebcache.py</code> <pre><code>def get_layer_bounds(\n    self, layer: str, srs: str, type: str, *, format: Literal[\"json\", \"xml\"] = \"json\"\n) -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"Retrieves the bounds for a layer.\n\n    Args:\n        layer: The name of the layer.\n        srs: The srs projection used against the layer to find the bounds such as EPSG:4326.\n        type: Accepts java as an extension.\n        format: Optional. The format of the response.\n\n    Returns:\n        The bounds.\n    \"\"\"\n    url = f\"{self.service_url}/gwc/rest/bounds/{layer}/{srs}/{type}.{format}\"\n    response = self._request(method=\"get\", url=url)\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geowebcache/#geoserver.geowebcache.GeoWebCache.get_diskquota","title":"get_diskquota","text":"<pre><code>get_diskquota(*, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_diskquota(*, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_diskquota(*, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>Retrieves the disk quota settings.</p> <p>Parameters:</p> Name Type Description Default <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response.</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The disk quota settings.</p> Source code in <code>geoserver/geowebcache.py</code> <pre><code>def get_diskquota(self, *, format: Literal[\"json\", \"xml\"] = \"json\") -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"Retrieves the disk quota settings.\n\n    Args:\n        format: Optional. The format of the response.\n\n    Returns:\n        The disk quota settings.\n    \"\"\"\n    url = f\"{self.service_url}/gwc/rest/diskquota.{format}\"\n    response = self._request(method=\"get\", url=url)\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geowebcache/#geoserver.geowebcache.GeoWebCache.update_diskquota","title":"update_diskquota","text":"<pre><code>update_diskquota(body: Union[str, Dict[str, Any]]) -&gt; str\n</code></pre> <p>Modifies the disk quota settings.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>Union[str, Dict[str, Any]]</code> <p>The body of the request used to modify the disk quota settings.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geowebcache.py</code> <pre><code>def update_diskquota(self, body: Union[str, Dict[str, Any]]) -&gt; str:\n    \"\"\"Modifies the disk quota settings.\n\n    Args:\n        body: The body of the request used to modify the disk quota settings.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/gwc/rest/diskquota\"\n    self._request(method=\"put\", url=url, body=body)\n    return UPDATED_MESSAGE\n</code></pre>"},{"location":"api/geowebcache/#geoserver.geowebcache.GeoWebCache.filter_update","title":"filter_update","text":"<pre><code>filter_update(filter: str, update: str, *, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>filter_update(filter: str, update: str, *, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>filter_update(filter: str, update: str, *, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>Restfully updates the given filter with parameters provided in the xml or zip.</p> <p>Parameters:</p> Name Type Description Default <code>filter</code> <code>str</code> <p>The filter to use for the update.</p> required <code>update</code> <code>str</code> <p>The update to apply.</p> required <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response.</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The response.</p> Source code in <code>geoserver/geowebcache.py</code> <pre><code>def filter_update(\n    self, filter: str, update: str, *, format: Literal[\"json\", \"xml\"] = \"json\"\n) -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"Restfully updates the given filter with parameters provided in the xml or zip.\n\n    Args:\n        filter: The filter to use for the update.\n        update: The update to apply.\n        format: Optional. The format of the response.\n\n    Returns:\n        The response.\n    \"\"\"\n    url = f\"{self.service_url}/gwc/rest/filter/{filter}/update/{update}.{format}\"\n    response = self._request(method=\"post\", url=url)\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geowebcache/#geoserver.geowebcache.GeoWebCache.get_global_settings","title":"get_global_settings","text":"<pre><code>get_global_settings(*, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_global_settings(*, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_global_settings(*, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>Retrieves the global settings.</p> <p>Parameters:</p> Name Type Description Default <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response.</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The global settings.</p> Source code in <code>geoserver/geowebcache.py</code> <pre><code>def get_global_settings(self, *, format: Literal[\"json\", \"xml\"] = \"json\") -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"Retrieves the global settings.\n\n    Args:\n        format: Optional. The format of the response.\n\n    Returns:\n        The global settings.\n    \"\"\"\n    url = f\"{self.service_url}/gwc/rest/global.{format}\"\n    response = self._request(method=\"get\", url=url)\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geowebcache/#geoserver.geowebcache.GeoWebCache.update_global_settings","title":"update_global_settings","text":"<pre><code>update_global_settings(body: Union[str, Dict[str, Any]]) -&gt; str\n</code></pre> <p>Modifies the global settings.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>Union[str, Dict[str, Any]]</code> <p>The body of the request used to modify the global settings.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geowebcache.py</code> <pre><code>def update_global_settings(self, body: Union[str, Dict[str, Any]]) -&gt; str:\n    \"\"\"Modifies the global settings.\n\n    Args:\n        body: The body of the request used to modify the global settings.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/gwc/rest/global\"\n    self._request(method=\"put\", url=url, body=body)\n    return UPDATED_MESSAGE\n</code></pre>"},{"location":"api/geowebcache/#geoserver.geowebcache.GeoWebCache.get_gridsets","title":"get_gridsets","text":"<pre><code>get_gridsets(*, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_gridsets(*, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_gridsets(*, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>Retrieves the gridsets available on the server.</p> <p>Parameters:</p> Name Type Description Default <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response.</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The gridsets.</p> Source code in <code>geoserver/geowebcache.py</code> <pre><code>def get_gridsets(self, *, format: Literal[\"json\", \"xml\"] = \"json\") -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"Retrieves the gridsets available on the server.\n\n    Args:\n        format: Optional. The format of the response.\n\n    Returns:\n        The gridsets.\n    \"\"\"\n    url = f\"{self.service_url}/gwc/rest/gridsets.{format}\"\n    response = self._request(method=\"get\", url=url)\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geowebcache/#geoserver.geowebcache.GeoWebCache.get_gridset","title":"get_gridset","text":"<pre><code>get_gridset(name: str, *, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_gridset(name: str, *, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_gridset(name: str, *, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>Retrieves a single gridset.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the gridset.</p> required <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response.</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The gridset.</p> Source code in <code>geoserver/geowebcache.py</code> <pre><code>def get_gridset(self, name: str, *, format: Literal[\"json\", \"xml\"] = \"json\") -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"Retrieves a single gridset.\n\n    Args:\n        name: The name of the gridset.\n        format: Optional. The format of the response.\n\n    Returns:\n        The gridset.\n    \"\"\"\n    url = f\"{self.service_url}/gwc/rest/gridsets/{name}.{format}\"\n    response = self._request(method=\"get\", url=url)\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geowebcache/#geoserver.geowebcache.GeoWebCache.insert_gridset","title":"insert_gridset","text":"<pre><code>insert_gridset(name: str, body: Union[str, Dict[str, Any]]) -&gt; str\n</code></pre> <p>Creates a new configured gridset on the server, or modifies an existing gridset.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the gridset.</p> required <code>body</code> <code>Union[str, Dict[str, Any]]</code> <p>The body of the request used to modify the gridset.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geowebcache.py</code> <pre><code>def insert_gridset(self, name: str, body: Union[str, Dict[str, Any]]) -&gt; str:\n    \"\"\"Creates a new configured gridset on the server, or modifies an existing gridset.\n\n    Args:\n        name: The name of the gridset.\n        body: The body of the request used to modify the gridset.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/gwc/rest/gridsets/{name}\"\n    response = self._request(method=\"put\", url=url, body=body)\n    return response.text\n</code></pre>"},{"location":"api/geowebcache/#geoserver.geowebcache.GeoWebCache.delete_gridset","title":"delete_gridset","text":"<pre><code>delete_gridset(name: str) -&gt; str\n</code></pre> <p>Deletes a single gridset.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the gridset.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geowebcache.py</code> <pre><code>def delete_gridset(self, name: str) -&gt; str:\n    \"\"\"Deletes a single gridset.\n\n    Args:\n        name: The name of the gridset.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/gwc/rest/gridsets/{name}\"\n    self._request(method=\"delete\", url=url)\n    return DELETED_MESSAGE\n</code></pre>"},{"location":"api/geowebcache/#geoserver.geowebcache.GeoWebCache.get_layers","title":"get_layers","text":"<pre><code>get_layers(*, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_layers(*, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_layers(*, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>Retrieves the layers available on the server.</p> <p>Parameters:</p> Name Type Description Default <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response.</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The layers.</p> Source code in <code>geoserver/geowebcache.py</code> <pre><code>def get_layers(self, *, format: Literal[\"json\", \"xml\"] = \"json\") -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"Retrieves the layers available on the server.\n\n    Args:\n        format: Optional. The format of the response.\n\n    Returns:\n        The layers.\n    \"\"\"\n    url = f\"{self.service_url}/gwc/rest/layers.{format}\"\n    response = self._request(method=\"get\", url=url)\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geowebcache/#geoserver.geowebcache.GeoWebCache.get_layer","title":"get_layer","text":"<pre><code>get_layer(name: str, *, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_layer(name: str, *, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_layer(name: str, *, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>Retrieves a single layer.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the layer.</p> required <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response.</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The layer.</p> Source code in <code>geoserver/geowebcache.py</code> <pre><code>def get_layer(self, name: str, *, format: Literal[\"json\", \"xml\"] = \"json\") -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"Retrieves a single layer.\n\n    Args:\n        name: The name of the layer.\n        format: Optional. The format of the response.\n\n    Returns:\n        The layer.\n    \"\"\"\n    url = f\"{self.service_url}/gwc/rest/layers/{name}.{format}\"\n    response = self._request(method=\"get\", url=url)\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geowebcache/#geoserver.geowebcache.GeoWebCache.insert_layer","title":"insert_layer","text":"<pre><code>insert_layer(name: str, body: Union[str, Dict[str, Any]]) -&gt; Dict[str, Any]\n</code></pre> <p>Creates a new layer on the server, or modifies an existing layer.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the layer.</p> required <code>body</code> <code>Union[str, Dict[str, Any]]</code> <p>The body of the request used to modify the layer.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Success message.</p> Source code in <code>geoserver/geowebcache.py</code> <pre><code>def insert_layer(self, name: str, body: Union[str, Dict[str, Any]]) -&gt; Dict[str, Any]:\n    \"\"\"Creates a new layer on the server, or modifies an existing layer.\n\n    Args:\n        name: The name of the layer.\n        body: The body of the request used to modify the layer.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/gwc/rest/layers/{name}\"\n    response = self._request(method=\"put\", url=url, body=body)\n    return response.json()\n</code></pre>"},{"location":"api/geowebcache/#geoserver.geowebcache.GeoWebCache.delete_layer","title":"delete_layer","text":"<pre><code>delete_layer(name: str) -&gt; str\n</code></pre> <p>Deletes a single layer.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the layer.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geowebcache.py</code> <pre><code>def delete_layer(self, name: str) -&gt; str:\n    \"\"\"Deletes a single layer.\n\n    Args:\n        name: The name of the layer.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/gwc/rest/layers/{name}\"\n    self._request(method=\"delete\", url=url)\n    return DELETED_MESSAGE\n</code></pre>"},{"location":"api/geowebcache/#geoserver.geowebcache.GeoWebCache.get_masstruncate","title":"get_masstruncate","text":"<pre><code>get_masstruncate(*, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_masstruncate(*, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_masstruncate(*, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>Returns xml containing the request type capabilities for mass truncation.</p> <p>Parameters:</p> Name Type Description Default <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response.</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The mass truncate settings.</p> Source code in <code>geoserver/geowebcache.py</code> <pre><code>def get_masstruncate(self, *, format: Literal[\"json\", \"xml\"] = \"json\") -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"Returns xml containing the request type capabilities for mass truncation.\n\n    Args:\n        format: Optional. The format of the response.\n\n    Returns:\n        The mass truncate settings.\n    \"\"\"\n    url = f\"{self.service_url}/gwc/rest/masstruncate.{format}\"\n    headers = {\"Accept\": \"application/xml\"}\n    response = self._request(method=\"get\", url=url, headers=headers)\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geowebcache/#geoserver.geowebcache.GeoWebCache.create_masstruncate","title":"create_masstruncate","text":"<pre><code>create_masstruncate(*, request_type: str, layer: str) -&gt; str\n</code></pre> <p>Issues a mass truncate request based on the request type parameter. truncateLayer, will clear all caches associated with a named layer, including all permutations of gridset, parameter filter values, and image formats.</p> <p>Parameters:</p> Name Type Description Default <code>request_type</code> <code>str</code> <p>The type of request.</p> required <code>layer</code> <code>str</code> <p>The name of the layer.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geowebcache.py</code> <pre><code>def create_masstruncate(self, *, request_type: str, layer: str) -&gt; str:\n    \"\"\"Issues a mass truncate request based on the request type parameter.\n    truncateLayer, will clear all caches associated with a named layer, including all permutations of gridset,\n    parameter filter values, and image formats.\n\n    Args:\n        request_type: The type of request.\n        layer: The name of the layer.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/gwc/rest/masstruncate\"\n    params = dict(requestType=request_type, layer=layer)\n    response = self._request(method=\"post\", url=url, params=params)\n    return response.text\n</code></pre>"},{"location":"api/geowebcache/#geoserver.geowebcache.GeoWebCache.get_statistics","title":"get_statistics","text":"<pre><code>get_statistics(*, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_statistics(*, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_statistics(*, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>Retrieves the statistics for a layer or gridset.</p> <p>Parameters:</p> Name Type Description Default <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response.</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The statistics.</p> Source code in <code>geoserver/geowebcache.py</code> <pre><code>def get_statistics(self, *, format: Literal[\"json\", \"xml\"] = \"json\") -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"Retrieves the statistics for a layer or gridset.\n\n    Args:\n        format: Optional. The format of the response.\n\n    Returns:\n        The statistics.\n    \"\"\"\n    url = f\"{self.service_url}/gwc/rest/statistics.{format}\"\n    response = self._request(method=\"get\", url=url)\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"api/geowebcache/#geoserver.geowebcache.GeoWebCache.reload","title":"reload","text":"<pre><code>reload(body: str) -&gt; str\n</code></pre> <p>Reloads the GeoWebCache settings after making changes to the configuration.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>str</code> <p>The string value of the configuration ie. <code>reload_configuration=1</code>.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Success message.</p> Source code in <code>geoserver/geowebcache.py</code> <pre><code>def reload(self, body: str) -&gt; str:\n    \"\"\"Reloads the GeoWebCache settings after making changes to the configuration.\n\n    Args:\n        body: The string value of the configuration ie. `reload_configuration=1`.\n\n    Returns:\n        Success message.\n    \"\"\"\n    url = f\"{self.service_url}/gwc/rest/reload\"\n    headers = {\"Content-Type\": \"text/plain\"}\n    response = self._request(method=\"post\", url=url, data=body, headers=headers)\n    return response.text\n</code></pre>"},{"location":"api/geowebcache/#geoserver.geowebcache.GeoWebCache.get_seed","title":"get_seed","text":"<pre><code>get_seed(*, format: Literal['json'] = 'json') -&gt; Dict[str, Any]\n</code></pre><pre><code>get_seed(*, format: Literal['xml']) -&gt; str\n</code></pre> <pre><code>get_seed(*, format: Literal['json', 'xml'] = 'json') -&gt; Union[str, Dict[str, Any]]\n</code></pre> <p>Query's and returns a json array of the status for all currently running task. The array contains a set of long in the following order: [tiles processed, total number of tiles to process, number of remaining tiles, Task ID, Task status]. The returned task status will be one of -1 = ABORTED, 0 = PENDING, 1 = RUNNING, 2 = DONE</p> <p>Parameters:</p> Name Type Description Default <code>format</code> <code>Literal['json', 'xml']</code> <p>Optional. The format of the response.</p> <code>'json'</code> <p>Returns:</p> Type Description <code>Union[str, Dict[str, Any]]</code> <p>The seed settings.</p> Source code in <code>geoserver/geowebcache.py</code> <pre><code>def get_seed(self, *, format: Literal[\"json\", \"xml\"] = \"json\") -&gt; Union[str, Dict[str, Any]]:\n    \"\"\"Query's and returns a json array of the status for all currently running task.\n    The array contains a set of long in the following order:\n    [tiles processed, total number of tiles to process, number of remaining tiles, Task ID, Task status].\n    The returned task status will be one of -1 = ABORTED, 0 = PENDING, 1 = RUNNING, 2 = DONE\n\n    Args:\n        format: Optional. The format of the response.\n\n    Returns:\n        The seed settings.\n    \"\"\"\n    url = f\"{self.service_url}/gwc/rest/seed.{format}\"\n    response = self._request(method=\"get\", url=url)\n    return response.json() if format == \"json\" else response.text\n</code></pre>"},{"location":"notebooks/About/","title":"About","text":"In\u00a0[1]: Copied! <pre>from geoserver import GeoServer\n</pre> from geoserver import GeoServer In\u00a0[2]: Copied! <pre># Setup the geoserver instance\ngeoserver = GeoServer(\n    service_url=\"http://localhost:8080/geoserver\",\n    username=\"admin\",\n    password=\"geoserver\",\n)\n</pre> # Setup the geoserver instance geoserver = GeoServer(     service_url=\"http://localhost:8080/geoserver\",     username=\"admin\",     password=\"geoserver\", ) In\u00a0[3]: Copied! <pre>geoserver.get_version()\n</pre> geoserver.get_version() Out[3]: <pre>{'about': {'resource': [{'@name': 'GeoServer',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0'},\n   {'@name': 'GeoTools',\n    'Build-Timestamp': '30-Mar-2023 06:48',\n    'Version': 29,\n    'Git-Revision': '76b6ac20cb7579da3a4c3f88b574e29aa1db80c2'},\n   {'@name': 'GeoWebCache',\n    'Version': '1.23.0',\n    'Git-Revision': '1.23.x/437ba9ba8468c6431945e3e988a330eb35012bee'}]}}</pre> In\u00a0[4]: Copied! <pre>geoserver.get_manifest(manifest=\"gwc-.*\")\n</pre> geoserver.get_manifest(manifest=\"gwc-.*\") Out[4]: <pre>{'about': {'resource': [{'@name': 'gwc-core-1.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Implementation-Vendor': 'https://www.geowebcache.org',\n    'Implementation-Title': 'org.geowebcache',\n    'Specification-Version': '1.23.0',\n    'Implementation-Version': '1.23.x/437ba9ba8468c6431945e3e988a330eb35012bee',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.8.6',\n    'Specification-Title': 'org.geowebcache',\n    'Built-By': 'jgarnett',\n    'Build-Jdk': '11.0.18',\n    'Specification-Vendor': 'https://www.geowebcache.org'},\n   {'@name': 'gwc-diskquota-core-1.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Implementation-Vendor': 'http://geowebcache.org',\n    'Implementation-Title': 'org.geowebcache',\n    'Specification-Version': '1.23.0',\n    'Implementation-Version': '1.23.x/437ba9ba8468c6431945e3e988a330eb35012bee',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.8.6',\n    'Specification-Title': 'org.geowebcache',\n    'Built-By': 'jgarnett',\n    'Build-Jdk': '11.0.18',\n    'Specification-Vendor': 'http://geowebcache.org'},\n   {'@name': 'gwc-diskquota-jdbc-1.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Implementation-Vendor': 'http://geowebcache.org',\n    'Implementation-Title': 'org.geowebcache',\n    'Specification-Version': '1.23.0',\n    'Implementation-Version': '1.23.x/437ba9ba8468c6431945e3e988a330eb35012bee',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.8.6',\n    'Specification-Title': 'org.geowebcache',\n    'Built-By': 'jgarnett',\n    'Build-Jdk': '11.0.18',\n    'Specification-Vendor': 'http://geowebcache.org'},\n   {'@name': 'gwc-georss-1.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Implementation-Vendor': 'http://geowebcache.org',\n    'Implementation-Title': 'org.geowebcache',\n    'Specification-Version': '1.23.0',\n    'Implementation-Version': '1.23.x/437ba9ba8468c6431945e3e988a330eb35012bee',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.8.6',\n    'Specification-Title': 'org.geowebcache',\n    'Built-By': 'jgarnett',\n    'Build-Jdk': '11.0.18',\n    'Specification-Vendor': 'http://geowebcache.org'},\n   {'@name': 'gwc-gmaps-1.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Implementation-Vendor': 'http://geowebcache.org',\n    'Implementation-Title': 'org.geowebcache',\n    'Specification-Version': '1.23.0',\n    'Implementation-Version': '1.23.x/437ba9ba8468c6431945e3e988a330eb35012bee',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.8.6',\n    'Specification-Title': 'org.geowebcache',\n    'Built-By': 'jgarnett',\n    'Build-Jdk': '11.0.18',\n    'Specification-Vendor': 'http://geowebcache.org'},\n   {'@name': 'gwc-kml-1.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Implementation-Vendor': 'http://geowebcache.org',\n    'Implementation-Title': 'org.geowebcache',\n    'Specification-Version': '1.23.0',\n    'Implementation-Version': '1.23.x/437ba9ba8468c6431945e3e988a330eb35012bee',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.8.6',\n    'Specification-Title': 'org.geowebcache',\n    'Built-By': 'jgarnett',\n    'Build-Jdk': '11.0.18',\n    'Specification-Vendor': 'http://geowebcache.org'},\n   {'@name': 'gwc-rest-1.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Implementation-Vendor': 'http://geowebcache.org',\n    'Implementation-Title': 'org.geowebcache',\n    'Specification-Version': '1.23.0',\n    'Implementation-Version': '1.23.x/437ba9ba8468c6431945e3e988a330eb35012bee',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.8.6',\n    'Specification-Title': 'org.geowebcache',\n    'Built-By': 'jgarnett',\n    'Build-Jdk': '11.0.18',\n    'Specification-Vendor': 'http://geowebcache.org'},\n   {'@name': 'gwc-tms-1.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Implementation-Vendor': 'http://geowebcache.org',\n    'Implementation-Title': 'org.geowebcache',\n    'Specification-Version': '1.23.0',\n    'Implementation-Version': '1.23.x/437ba9ba8468c6431945e3e988a330eb35012bee',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.8.6',\n    'Specification-Title': 'org.geowebcache',\n    'Built-By': 'jgarnett',\n    'Build-Jdk': '11.0.18',\n    'Specification-Vendor': 'http://geowebcache.org'},\n   {'@name': 'gwc-ve-1.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Implementation-Vendor': 'http://geowebcache.org',\n    'Implementation-Title': 'org.geowebcache',\n    'Specification-Version': '1.23.0',\n    'Implementation-Version': '1.23.x/437ba9ba8468c6431945e3e988a330eb35012bee',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.8.6',\n    'Specification-Title': 'org.geowebcache',\n    'Built-By': 'jgarnett',\n    'Build-Jdk': '11.0.18',\n    'Specification-Vendor': 'http://geowebcache.org'},\n   {'@name': 'gwc-wms-1.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Implementation-Vendor': 'http://geowebcache.org',\n    'Implementation-Title': 'org.geowebcache',\n    'Specification-Version': '1.23.0',\n    'Implementation-Version': '1.23.x/437ba9ba8468c6431945e3e988a330eb35012bee',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.8.6',\n    'Specification-Title': 'org.geowebcache',\n    'Built-By': 'jgarnett',\n    'Build-Jdk': '11.0.18',\n    'Specification-Vendor': 'http://geowebcache.org'},\n   {'@name': 'gwc-wmts-1.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Implementation-Vendor': 'http://geowebcache.org',\n    'Implementation-Title': 'org.geowebcache',\n    'Specification-Version': '1.23.0',\n    'Implementation-Version': '1.23.x/437ba9ba8468c6431945e3e988a330eb35012bee',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.8.6',\n    'Specification-Title': 'org.geowebcache',\n    'Built-By': 'jgarnett',\n    'Build-Jdk': '11.0.18',\n    'Specification-Vendor': 'http://geowebcache.org'}]}}</pre> In\u00a0[5]: Copied! <pre>geoserver.get_manifest(key=\"GeoServerModule\")\n</pre> geoserver.get_manifest(key=\"GeoServerModule\") Out[5]: <pre>{'about': {'resource': [{'@name': 'gs-control-flow-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'OWS request flow controller',\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver.extension',\n    'GeoServerModule': 'extension',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'OWS request flow controller',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''},\n   {'@name': 'gs-csw-api-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'Catalog Services for the Web interfaces',\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver.csw',\n    'GeoServerModule': 'extension',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'Catalog Services for the Web interfaces',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''},\n   {'@name': 'gs-csw-core-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'Catalog Services for the Web core module',\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver.csw',\n    'GeoServerModule': 'extension',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'Catalog Services for the Web core module',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''},\n   {'@name': 'gs-csw-iso-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'Catalog Services for the Web ISO metadata profile module',\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver.csw',\n    'GeoServerModule': 'extension',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'Catalog Services for the Web ISO metadata profile module',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''},\n   {'@name': 'gs-gdal-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'ImageI/O-Ext GDAL Coverage Extension',\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver.extension',\n    'GeoServerModule': 'extension',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'ImageI/O-Ext GDAL Coverage Extension',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''},\n   {'@name': 'gs-gwc-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'GeoWebCache (GWC) Module',\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver',\n    'GeoServerModule': 'core',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'GeoWebCache (GWC) Module',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''},\n   {'@name': 'gs-gwc-rest-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'GeoWebCache (GWC) Rest Module',\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver',\n    'GeoServerModule': 'core',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'GeoWebCache (GWC) Rest Module',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''},\n   {'@name': 'gs-h2-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'H2 DataStore Extension',\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver.extension',\n    'GeoServerModule': 'extension',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'H2 DataStore Extension',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''},\n   {'@name': 'gs-inspire-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'GeoServer INSPIRE Extensions',\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver.extension',\n    'GeoServerModule': 'extension',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'GeoServer INSPIRE Extensions',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''},\n   {'@name': 'gs-kml-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'KML support for GeoServer',\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver',\n    'GeoServerModule': 'core',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'KML support for GeoServer',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''},\n   {'@name': 'gs-libjpeg-turbo-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'GeoServer libjpeg-turbo Module',\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver.extension',\n    'GeoServerModule': 'extension',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'GeoServer libjpeg-turbo Module',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''},\n   {'@name': 'gs-main-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'Main Module',\n    'Sealed': True,\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver',\n    'GeoServerModule': 'core',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'Main Module',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''},\n   {'@name': 'gs-monitor-core-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'Core Monitor Extension',\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver.extension',\n    'GeoServerModule': 'extension',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'Core Monitor Extension',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''},\n   {'@name': 'gs-netcdf-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'NetCDF Coverage format',\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver.extension',\n    'GeoServerModule': 'extension',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'NetCDF Coverage format',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''},\n   {'@name': 'gs-netcdf-out-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'WCS NetCDF output Module',\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver.extension',\n    'GeoServerModule': 'extension',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'WCS NetCDF output Module',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''},\n   {'@name': 'gs-ows-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'Open Web Service Module',\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver',\n    'GeoServerModule': 'core',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'Open Web Service Module',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''},\n   {'@name': 'gs-platform-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'Core Platform Module',\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver',\n    'GeoServerModule': 'core',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'Core Platform Module',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''},\n   {'@name': 'gs-printing-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'Printing Module',\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver.extension',\n    'GeoServerModule': 'extension',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'Printing Module',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''},\n   {'@name': 'gs-rest-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'gs-rest',\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver',\n    'GeoServerModule': 'core',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'gs-rest',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''},\n   {'@name': 'gs-restconfig-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'gs-restconfig',\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver',\n    'GeoServerModule': 'core',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'gs-restconfig',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''},\n   {'@name': 'gs-restconfig-wcs-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'gs-restconfig-wcs',\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver',\n    'GeoServerModule': 'core',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'gs-restconfig-wcs',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''},\n   {'@name': 'gs-restconfig-wfs-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'gs-restconfig-wfs',\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver',\n    'GeoServerModule': 'core',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'gs-restconfig-wfs',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''},\n   {'@name': 'gs-restconfig-wms-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'gs-restconfig-wms',\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver',\n    'GeoServerModule': 'core',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'gs-restconfig-wms',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''},\n   {'@name': 'gs-restconfig-wmts-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'WMTS REST configuration',\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver',\n    'GeoServerModule': 'core',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'WMTS REST configuration',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''},\n   {'@name': 'gs-sec-jdbc-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'GeoServer JDBC Security Module',\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver.security',\n    'GeoServerModule': 'core',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'GeoServer JDBC Security Module',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''},\n   {'@name': 'gs-sec-ldap-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'GeoServer LDAP Security Module',\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver.security',\n    'GeoServerModule': 'core',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'GeoServer LDAP Security Module',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''},\n   {'@name': 'gs-vectortiles-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'Vector Tiles',\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver.extension',\n    'GeoServerModule': 'extension',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'Vector Tiles',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''},\n   {'@name': 'gs-wcs-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'Web Coverage Service Module',\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver',\n    'GeoServerModule': 'core',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'Web Coverage Service Module',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''},\n   {'@name': 'gs-wcs1_0-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'Web Coverage Service 1.0 Module',\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver',\n    'GeoServerModule': 'core',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'Web Coverage Service 1.0 Module',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''},\n   {'@name': 'gs-wcs1_1-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'Web Coverage Service 1.1 Module',\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver',\n    'GeoServerModule': 'core',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'Web Coverage Service 1.1 Module',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''},\n   {'@name': 'gs-wcs2_0-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'Web Coverage Service 2.0 Module',\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver',\n    'GeoServerModule': 'core',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'Web Coverage Service 2.0 Module',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''},\n   {'@name': 'gs-web-core-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'Core UI Module',\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver.web',\n    'GeoServerModule': 'core',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'Core UI Module',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''},\n   {'@name': 'gs-web-csw-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'CSW UI Module',\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver.csw',\n    'GeoServerModule': 'extension',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'CSW UI Module',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''},\n   {'@name': 'gs-web-demo-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'Demos Module',\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver.web',\n    'GeoServerModule': 'core',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'Demos Module',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''},\n   {'@name': 'gs-web-gwc-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'GWC UI Module',\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver.web',\n    'GeoServerModule': 'core',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'GWC UI Module',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''},\n   {'@name': 'gs-web-rest-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'REST UI Module',\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver.web',\n    'GeoServerModule': 'core',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'REST UI Module',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''},\n   {'@name': 'gs-web-sec-core-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'Security UI Core Module',\n    'Sealed': True,\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver.web',\n    'GeoServerModule': 'core',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'Security UI Core Module',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''},\n   {'@name': 'gs-web-sec-jdbc-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'Security UI JDBC Module',\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver.web',\n    'GeoServerModule': 'core',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'Security UI JDBC Module',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''},\n   {'@name': 'gs-web-sec-ldap-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'Security UI LDAP Module',\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver.web',\n    'GeoServerModule': 'core',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'Security UI LDAP Module',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''},\n   {'@name': 'gs-web-wcs-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'WCS UI Module',\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver.web',\n    'GeoServerModule': 'core',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'WCS UI Module',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''},\n   {'@name': 'gs-web-wfs-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'WFS UI Module',\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver.web',\n    'GeoServerModule': 'core',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'WFS UI Module',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''},\n   {'@name': 'gs-web-wms-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'WMS UI Module',\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver.web',\n    'GeoServerModule': 'core',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'WMS UI Module',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''},\n   {'@name': 'gs-web-wps-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'Web Processing Service GUI',\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver.extension',\n    'GeoServerModule': 'extension',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'Web Processing Service GUI',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''},\n   {'@name': 'gs-wfs-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'Web Feature Service Module',\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver',\n    'GeoServerModule': 'core',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'Web Feature Service Module',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''},\n   {'@name': 'gs-wms-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'Web Map Service Module',\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver',\n    'GeoServerModule': 'core',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'Web Map Service Module',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''},\n   {'@name': 'gs-wps-core-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'Web Processing Service Module',\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver.extension',\n    'GeoServerModule': 'extension',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'Web Processing Service Module',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''},\n   {'@name': 'gs-wps-kml-ppio-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'KML PPIO for WPS',\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver.extension',\n    'GeoServerModule': 'extension',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'KML PPIO for WPS',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''}]}}</pre> In\u00a0[6]: Copied! <pre>geoserver.get_manifest(key=\"GeoServerModule\", value=\"extension\")\n</pre> geoserver.get_manifest(key=\"GeoServerModule\", value=\"extension\") Out[6]: <pre>{'about': {'resource': [{'@name': 'gs-control-flow-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'OWS request flow controller',\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver.extension',\n    'GeoServerModule': 'extension',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'OWS request flow controller',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''},\n   {'@name': 'gs-csw-api-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'Catalog Services for the Web interfaces',\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver.csw',\n    'GeoServerModule': 'extension',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'Catalog Services for the Web interfaces',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''},\n   {'@name': 'gs-csw-core-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'Catalog Services for the Web core module',\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver.csw',\n    'GeoServerModule': 'extension',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'Catalog Services for the Web core module',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''},\n   {'@name': 'gs-csw-iso-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'Catalog Services for the Web ISO metadata profile module',\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver.csw',\n    'GeoServerModule': 'extension',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'Catalog Services for the Web ISO metadata profile module',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''},\n   {'@name': 'gs-gdal-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'ImageI/O-Ext GDAL Coverage Extension',\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver.extension',\n    'GeoServerModule': 'extension',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'ImageI/O-Ext GDAL Coverage Extension',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''},\n   {'@name': 'gs-h2-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'H2 DataStore Extension',\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver.extension',\n    'GeoServerModule': 'extension',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'H2 DataStore Extension',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''},\n   {'@name': 'gs-inspire-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'GeoServer INSPIRE Extensions',\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver.extension',\n    'GeoServerModule': 'extension',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'GeoServer INSPIRE Extensions',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''},\n   {'@name': 'gs-libjpeg-turbo-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'GeoServer libjpeg-turbo Module',\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver.extension',\n    'GeoServerModule': 'extension',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'GeoServer libjpeg-turbo Module',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''},\n   {'@name': 'gs-monitor-core-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'Core Monitor Extension',\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver.extension',\n    'GeoServerModule': 'extension',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'Core Monitor Extension',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''},\n   {'@name': 'gs-netcdf-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'NetCDF Coverage format',\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver.extension',\n    'GeoServerModule': 'extension',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'NetCDF Coverage format',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''},\n   {'@name': 'gs-netcdf-out-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'WCS NetCDF output Module',\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver.extension',\n    'GeoServerModule': 'extension',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'WCS NetCDF output Module',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''},\n   {'@name': 'gs-printing-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'Printing Module',\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver.extension',\n    'GeoServerModule': 'extension',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'Printing Module',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''},\n   {'@name': 'gs-vectortiles-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'Vector Tiles',\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver.extension',\n    'GeoServerModule': 'extension',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'Vector Tiles',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''},\n   {'@name': 'gs-web-csw-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'CSW UI Module',\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver.csw',\n    'GeoServerModule': 'extension',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'CSW UI Module',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''},\n   {'@name': 'gs-web-wps-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'Web Processing Service GUI',\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver.extension',\n    'GeoServerModule': 'extension',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'Web Processing Service GUI',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''},\n   {'@name': 'gs-wps-core-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'Web Processing Service Module',\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver.extension',\n    'GeoServerModule': 'extension',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'Web Processing Service Module',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''},\n   {'@name': 'gs-wps-kml-ppio-2.23.0',\n    'Archiver-Version': 'Plexus Archiver',\n    'Build-Timestamp': '04-Apr-2023 06:16',\n    'Implementation-Title': 'KML PPIO for WPS',\n    'Specification-Version': '2.23.0',\n    'Implementation-Version': '2.23.0',\n    'Git-Revision': 'afef4aab83639a1af6dd79b122c7e70277d9f8b0',\n    'Manifest-Version': 1,\n    'Created-By': 'Apache Maven 3.6.3',\n    'Implementation-Vendor-Id': 'org.geoserver.extension',\n    'GeoServerModule': 'extension',\n    'Build-Jdk': '11.0.4',\n    'Specification-Vendor': 'Open Source Geospatial Foundation',\n    'Implementation-Vendor': 'Open Source Geospatial Foundation',\n    'Application-Name': '',\n    'Specification-Title': 'KML PPIO for WPS',\n    'Built-By': 'jenkins',\n    'Project-Version': '2.23.0',\n    'Iteration-Name': ''}]}}</pre> In\u00a0[7]: Copied! <pre>geoserver.get_system_status()\n</pre> geoserver.get_system_status() Out[7]: <pre>{'metrics': {'metric': [{'available': False,\n    'description': 'Operating system',\n    'name': 'OPERATING_SYSTEM',\n    'unit': '',\n    'category': 'SYSTEM',\n    'identifier': 'OPERATING_SYSTEM',\n    'priority': 1,\n    'value': 'NOT AVAILABLE'},\n   {'available': False,\n    'description': 'Uptime',\n    'name': 'SYSTEM_UPTIME',\n    'unit': 'sec',\n    'category': 'SYSTEM',\n    'identifier': 'SYSTEM_UPTIME',\n    'priority': 2,\n    'value': 'NOT AVAILABLE'},\n   {'available': False,\n    'description': 'System average load 1 minute',\n    'name': 'SYSTEM_AVERAGE_LOAD_1',\n    'unit': '',\n    'category': 'SYSTEM',\n    'identifier': 'SYSTEM_AVERAGE_LOAD_1',\n    'priority': 3,\n    'value': 'NOT AVAILABLE'},\n   {'available': False,\n    'description': 'System average load 5 minutes',\n    'name': 'SYSTEM_AVERAGE_LOAD_5',\n    'unit': '',\n    'category': 'SYSTEM',\n    'identifier': 'SYSTEM_AVERAGE_LOAD_5',\n    'priority': 3,\n    'value': 'NOT AVAILABLE'},\n   {'available': False,\n    'description': 'System average load 15 minutes',\n    'name': 'SYSTEM_AVERAGE_LOAD_15',\n    'unit': '',\n    'category': 'SYSTEM',\n    'identifier': 'SYSTEM_AVERAGE_LOAD_15',\n    'priority': 3,\n    'value': 'NOT AVAILABLE'},\n   {'available': False,\n    'description': 'Number of physical CPUs',\n    'name': 'PHYSICAL_CPUS',\n    'unit': '',\n    'category': 'CPU',\n    'identifier': 'PHYSICAL_CPUS',\n    'priority': 100,\n    'value': 'NOT AVAILABLE'},\n   {'available': False,\n    'description': 'Number of logical CPUs',\n    'name': 'LOGICAL_CPUS',\n    'unit': '',\n    'category': 'CPU',\n    'identifier': 'LOGICAL_CPUS',\n    'priority': 101,\n    'value': 'NOT AVAILABLE'},\n   {'available': False,\n    'description': 'Number of running process',\n    'name': 'RUNNING_PROCESS',\n    'unit': '',\n    'category': 'CPU',\n    'identifier': 'RUNNING_PROCESS',\n    'priority': 102,\n    'value': 'NOT AVAILABLE'},\n   {'available': False,\n    'description': 'Number of running threads',\n    'name': 'RUNNING_THREADS',\n    'unit': '',\n    'category': 'CPU',\n    'identifier': 'RUNNING_THREADS',\n    'priority': 103,\n    'value': 'NOT AVAILABLE'},\n   {'available': False,\n    'description': 'CPU average load',\n    'name': 'CPU_LOAD',\n    'unit': '%',\n    'category': 'CPU',\n    'identifier': 'CPU_LOAD',\n    'priority': 104,\n    'value': 'NOT AVAILABLE'},\n   {'available': False,\n    'description': 'CPU load',\n    'name': 'PER_CPU_LOAD',\n    'unit': '%',\n    'category': 'CPU',\n    'identifier': 'PER_CPU_LOAD',\n    'priority': 105,\n    'value': 'NOT AVAILABLE'},\n   {'available': False,\n    'description': 'Used physical memory ',\n    'name': 'MEMORY_USED',\n    'unit': '%',\n    'category': 'MEMORY',\n    'identifier': 'MEMORY_USED',\n    'priority': 200,\n    'value': 'NOT AVAILABLE'},\n   {'available': False,\n    'description': 'Total physical memory ',\n    'name': 'MEMORY_TOTAL',\n    'unit': 'bytes',\n    'category': 'MEMORY',\n    'identifier': 'MEMORY_TOTAL',\n    'priority': 201,\n    'value': 'NOT AVAILABLE'},\n   {'available': False,\n    'description': 'Free physical memory',\n    'name': 'MEMORY_FREE',\n    'unit': 'bytes',\n    'category': 'MEMORY',\n    'identifier': 'MEMORY_FREE',\n    'priority': 201,\n    'value': 'NOT AVAILABLE'},\n   {'available': False,\n    'description': 'Used swap memory',\n    'name': 'SWAP_USED',\n    'unit': '%',\n    'category': 'SWAP',\n    'identifier': 'SWAP_USED',\n    'priority': 300,\n    'value': 'NOT AVAILABLE'},\n   {'available': False,\n    'description': 'Total swap memory',\n    'name': 'SWAP_TOTAL',\n    'unit': 'bytes',\n    'category': 'SWAP',\n    'identifier': 'SWAP_TOTAL',\n    'priority': 301,\n    'value': 'NOT AVAILABLE'},\n   {'available': False,\n    'description': 'Free swap memory',\n    'name': 'SWAP_FREE',\n    'unit': 'bytes',\n    'category': 'SWAP',\n    'identifier': 'SWAP_FREE',\n    'priority': 302,\n    'value': 'NOT AVAILABLE'},\n   {'available': False,\n    'description': 'File system usage',\n    'name': 'FILE_SYSTEM_TOTAL_USAGE',\n    'unit': '%',\n    'category': 'FILE_SYSTEM',\n    'identifier': 'FILE_SYSTEM_TOTAL_USAGE',\n    'priority': 400,\n    'value': 'NOT AVAILABLE'},\n   {'available': False,\n    'description': 'Partition space used',\n    'name': 'PARTITION_USED',\n    'unit': '%',\n    'category': 'FILE_SYSTEM',\n    'identifier': 'PARTITION_USED',\n    'priority': 500,\n    'value': 'NOT AVAILABLE'},\n   {'available': False,\n    'description': 'Partition total space',\n    'name': 'PARTITION_TOTAL',\n    'unit': 'bytes',\n    'category': 'FILE_SYSTEM',\n    'identifier': 'PARTITION_TOTAL',\n    'priority': 501,\n    'value': 'NOT AVAILABLE'},\n   {'available': False,\n    'description': 'Partition free space',\n    'name': 'PARTITION_FREE',\n    'unit': 'bytes',\n    'category': 'FILE_SYSTEM',\n    'identifier': 'PARTITION_FREE',\n    'priority': 502,\n    'value': 'NOT AVAILABLE'},\n   {'available': False,\n    'description': 'Network interfaces send',\n    'name': 'NETWORK_INTERFACES_SEND',\n    'unit': 'bytes',\n    'category': 'NETWORK',\n    'identifier': 'NETWORK_INTERFACES_SEND',\n    'priority': 800,\n    'value': 'NOT AVAILABLE'},\n   {'available': False,\n    'description': 'Network interfaces received',\n    'name': 'NETWORK_INTERFACES_RECEIVED',\n    'unit': 'bytes',\n    'category': 'NETWORK',\n    'identifier': 'NETWORK_INTERFACES_RECEIVED',\n    'priority': 801,\n    'value': 'NOT AVAILABLE'},\n   {'available': False,\n    'description': 'Network interface band usage',\n    'name': 'NETWORK_INTERFACE_SEND',\n    'unit': 'bytes',\n    'category': 'NETWORK',\n    'identifier': 'NETWORK_INTERFACE_SEND',\n    'priority': 900,\n    'value': 'NOT AVAILABLE'},\n   {'available': False,\n    'description': 'Network interface available band',\n    'name': 'NETWORK_INTERFACE_RECEIVED',\n    'unit': 'bytes',\n    'category': 'NETWORK',\n    'identifier': 'NETWORK_INTERFACE_RECEIVED',\n    'priority': 901,\n    'value': 'NOT AVAILABLE'},\n   {'available': False,\n    'description': 'CPU temperature',\n    'name': 'TEMPERATURE',\n    'unit': '\u00b0C',\n    'category': 'SENSORS',\n    'identifier': 'TEMPERATURE',\n    'priority': 1200,\n    'value': 'NOT AVAILABLE'},\n   {'available': False,\n    'description': 'CPU voltage',\n    'name': 'VOLTAGE',\n    'unit': 'V',\n    'category': 'SENSORS',\n    'identifier': 'VOLTAGE',\n    'priority': 1201,\n    'value': 'NOT AVAILABLE'},\n   {'available': False,\n    'description': 'Fan speed',\n    'name': 'FAN_SPEED',\n    'unit': 'rpm',\n    'category': 'SENSORS',\n    'identifier': 'FAN_SPEED',\n    'priority': 1202,\n    'value': 'NOT AVAILABLE'},\n   {'available': False,\n    'description': 'GeoServer CPU usage',\n    'name': 'GEOSERVER_CPU_USAGE',\n    'unit': '%',\n    'category': 'GEOSERVER',\n    'identifier': 'GEOSERVER_CPU_USAGE',\n    'priority': 1300,\n    'value': 'NOT AVAILABLE'},\n   {'available': False,\n    'description': 'GeoServer threads',\n    'name': 'GEOSERVER_THREADS',\n    'unit': '',\n    'category': 'GEOSERVER',\n    'identifier': 'GEOSERVER_THREADS',\n    'priority': 1301,\n    'value': 'NOT AVAILABLE'},\n   {'available': False,\n    'description': 'GeoServer JVM memory usage',\n    'name': 'GEOSERVER_JVM_MEMORY_USAGE',\n    'unit': '%',\n    'category': 'GEOSERVER',\n    'identifier': 'GEOSERVER_JVM_MEMORY_USAGE',\n    'priority': 1302,\n    'value': 'NOT AVAILABLE'}]}}</pre> In\u00a0[8]: Copied! <pre>xml = geoserver.get_system_status(format=\"xml\")\nprint(xml)\n</pre> xml = geoserver.get_system_status(format=\"xml\") print(xml) <pre>&lt;metrics&gt;\n  &lt;metric&gt;\n    &lt;available&gt;false&lt;/available&gt;\n    &lt;description&gt;Operating system&lt;/description&gt;\n    &lt;name&gt;OPERATING_SYSTEM&lt;/name&gt;\n    &lt;unit&gt;&lt;/unit&gt;\n    &lt;category&gt;SYSTEM&lt;/category&gt;\n    &lt;identifier&gt;OPERATING_SYSTEM&lt;/identifier&gt;\n    &lt;priority&gt;1&lt;/priority&gt;\n    &lt;value&gt;NOT AVAILABLE&lt;/value&gt;\n  &lt;/metric&gt;\n  &lt;metric&gt;\n    &lt;available&gt;false&lt;/available&gt;\n    &lt;description&gt;Uptime&lt;/description&gt;\n    &lt;name&gt;SYSTEM_UPTIME&lt;/name&gt;\n    &lt;unit&gt;sec&lt;/unit&gt;\n    &lt;category&gt;SYSTEM&lt;/category&gt;\n    &lt;identifier&gt;SYSTEM_UPTIME&lt;/identifier&gt;\n    &lt;priority&gt;2&lt;/priority&gt;\n    &lt;value&gt;NOT AVAILABLE&lt;/value&gt;\n  &lt;/metric&gt;\n  &lt;metric&gt;\n    &lt;available&gt;false&lt;/available&gt;\n    &lt;description&gt;System average load 1 minute&lt;/description&gt;\n    &lt;name&gt;SYSTEM_AVERAGE_LOAD_1&lt;/name&gt;\n    &lt;unit&gt;&lt;/unit&gt;\n    &lt;category&gt;SYSTEM&lt;/category&gt;\n    &lt;identifier&gt;SYSTEM_AVERAGE_LOAD_1&lt;/identifier&gt;\n    &lt;priority&gt;3&lt;/priority&gt;\n    &lt;value&gt;NOT AVAILABLE&lt;/value&gt;\n  &lt;/metric&gt;\n  &lt;metric&gt;\n    &lt;available&gt;false&lt;/available&gt;\n    &lt;description&gt;System average load 5 minutes&lt;/description&gt;\n    &lt;name&gt;SYSTEM_AVERAGE_LOAD_5&lt;/name&gt;\n    &lt;unit&gt;&lt;/unit&gt;\n    &lt;category&gt;SYSTEM&lt;/category&gt;\n    &lt;identifier&gt;SYSTEM_AVERAGE_LOAD_5&lt;/identifier&gt;\n    &lt;priority&gt;3&lt;/priority&gt;\n    &lt;value&gt;NOT AVAILABLE&lt;/value&gt;\n  &lt;/metric&gt;\n  &lt;metric&gt;\n    &lt;available&gt;false&lt;/available&gt;\n    &lt;description&gt;System average load 15 minutes&lt;/description&gt;\n    &lt;name&gt;SYSTEM_AVERAGE_LOAD_15&lt;/name&gt;\n    &lt;unit&gt;&lt;/unit&gt;\n    &lt;category&gt;SYSTEM&lt;/category&gt;\n    &lt;identifier&gt;SYSTEM_AVERAGE_LOAD_15&lt;/identifier&gt;\n    &lt;priority&gt;3&lt;/priority&gt;\n    &lt;value&gt;NOT AVAILABLE&lt;/value&gt;\n  &lt;/metric&gt;\n  &lt;metric&gt;\n    &lt;available&gt;false&lt;/available&gt;\n    &lt;description&gt;Number of physical CPUs&lt;/description&gt;\n    &lt;name&gt;PHYSICAL_CPUS&lt;/name&gt;\n    &lt;unit&gt;&lt;/unit&gt;\n    &lt;category&gt;CPU&lt;/category&gt;\n    &lt;identifier&gt;PHYSICAL_CPUS&lt;/identifier&gt;\n    &lt;priority&gt;100&lt;/priority&gt;\n    &lt;value&gt;NOT AVAILABLE&lt;/value&gt;\n  &lt;/metric&gt;\n  &lt;metric&gt;\n    &lt;available&gt;false&lt;/available&gt;\n    &lt;description&gt;Number of logical CPUs&lt;/description&gt;\n    &lt;name&gt;LOGICAL_CPUS&lt;/name&gt;\n    &lt;unit&gt;&lt;/unit&gt;\n    &lt;category&gt;CPU&lt;/category&gt;\n    &lt;identifier&gt;LOGICAL_CPUS&lt;/identifier&gt;\n    &lt;priority&gt;101&lt;/priority&gt;\n    &lt;value&gt;NOT AVAILABLE&lt;/value&gt;\n  &lt;/metric&gt;\n  &lt;metric&gt;\n    &lt;available&gt;false&lt;/available&gt;\n    &lt;description&gt;Number of running process&lt;/description&gt;\n    &lt;name&gt;RUNNING_PROCESS&lt;/name&gt;\n    &lt;unit&gt;&lt;/unit&gt;\n    &lt;category&gt;CPU&lt;/category&gt;\n    &lt;identifier&gt;RUNNING_PROCESS&lt;/identifier&gt;\n    &lt;priority&gt;102&lt;/priority&gt;\n    &lt;value&gt;NOT AVAILABLE&lt;/value&gt;\n  &lt;/metric&gt;\n  &lt;metric&gt;\n    &lt;available&gt;false&lt;/available&gt;\n    &lt;description&gt;Number of running threads&lt;/description&gt;\n    &lt;name&gt;RUNNING_THREADS&lt;/name&gt;\n    &lt;unit&gt;&lt;/unit&gt;\n    &lt;category&gt;CPU&lt;/category&gt;\n    &lt;identifier&gt;RUNNING_THREADS&lt;/identifier&gt;\n    &lt;priority&gt;103&lt;/priority&gt;\n    &lt;value&gt;NOT AVAILABLE&lt;/value&gt;\n  &lt;/metric&gt;\n  &lt;metric&gt;\n    &lt;available&gt;false&lt;/available&gt;\n    &lt;description&gt;CPU average load&lt;/description&gt;\n    &lt;name&gt;CPU_LOAD&lt;/name&gt;\n    &lt;unit&gt;%&lt;/unit&gt;\n    &lt;category&gt;CPU&lt;/category&gt;\n    &lt;identifier&gt;CPU_LOAD&lt;/identifier&gt;\n    &lt;priority&gt;104&lt;/priority&gt;\n    &lt;value&gt;NOT AVAILABLE&lt;/value&gt;\n  &lt;/metric&gt;\n  &lt;metric&gt;\n    &lt;available&gt;false&lt;/available&gt;\n    &lt;description&gt;CPU load&lt;/description&gt;\n    &lt;name&gt;PER_CPU_LOAD&lt;/name&gt;\n    &lt;unit&gt;%&lt;/unit&gt;\n    &lt;category&gt;CPU&lt;/category&gt;\n    &lt;identifier&gt;PER_CPU_LOAD&lt;/identifier&gt;\n    &lt;priority&gt;105&lt;/priority&gt;\n    &lt;value&gt;NOT AVAILABLE&lt;/value&gt;\n  &lt;/metric&gt;\n  &lt;metric&gt;\n    &lt;available&gt;false&lt;/available&gt;\n    &lt;description&gt;Used physical memory &lt;/description&gt;\n    &lt;name&gt;MEMORY_USED&lt;/name&gt;\n    &lt;unit&gt;%&lt;/unit&gt;\n    &lt;category&gt;MEMORY&lt;/category&gt;\n    &lt;identifier&gt;MEMORY_USED&lt;/identifier&gt;\n    &lt;priority&gt;200&lt;/priority&gt;\n    &lt;value&gt;NOT AVAILABLE&lt;/value&gt;\n  &lt;/metric&gt;\n  &lt;metric&gt;\n    &lt;available&gt;false&lt;/available&gt;\n    &lt;description&gt;Total physical memory &lt;/description&gt;\n    &lt;name&gt;MEMORY_TOTAL&lt;/name&gt;\n    &lt;unit&gt;bytes&lt;/unit&gt;\n    &lt;category&gt;MEMORY&lt;/category&gt;\n    &lt;identifier&gt;MEMORY_TOTAL&lt;/identifier&gt;\n    &lt;priority&gt;201&lt;/priority&gt;\n    &lt;value&gt;NOT AVAILABLE&lt;/value&gt;\n  &lt;/metric&gt;\n  &lt;metric&gt;\n    &lt;available&gt;false&lt;/available&gt;\n    &lt;description&gt;Free physical memory&lt;/description&gt;\n    &lt;name&gt;MEMORY_FREE&lt;/name&gt;\n    &lt;unit&gt;bytes&lt;/unit&gt;\n    &lt;category&gt;MEMORY&lt;/category&gt;\n    &lt;identifier&gt;MEMORY_FREE&lt;/identifier&gt;\n    &lt;priority&gt;201&lt;/priority&gt;\n    &lt;value&gt;NOT AVAILABLE&lt;/value&gt;\n  &lt;/metric&gt;\n  &lt;metric&gt;\n    &lt;available&gt;false&lt;/available&gt;\n    &lt;description&gt;Used swap memory&lt;/description&gt;\n    &lt;name&gt;SWAP_USED&lt;/name&gt;\n    &lt;unit&gt;%&lt;/unit&gt;\n    &lt;category&gt;SWAP&lt;/category&gt;\n    &lt;identifier&gt;SWAP_USED&lt;/identifier&gt;\n    &lt;priority&gt;300&lt;/priority&gt;\n    &lt;value&gt;NOT AVAILABLE&lt;/value&gt;\n  &lt;/metric&gt;\n  &lt;metric&gt;\n    &lt;available&gt;false&lt;/available&gt;\n    &lt;description&gt;Total swap memory&lt;/description&gt;\n    &lt;name&gt;SWAP_TOTAL&lt;/name&gt;\n    &lt;unit&gt;bytes&lt;/unit&gt;\n    &lt;category&gt;SWAP&lt;/category&gt;\n    &lt;identifier&gt;SWAP_TOTAL&lt;/identifier&gt;\n    &lt;priority&gt;301&lt;/priority&gt;\n    &lt;value&gt;NOT AVAILABLE&lt;/value&gt;\n  &lt;/metric&gt;\n  &lt;metric&gt;\n    &lt;available&gt;false&lt;/available&gt;\n    &lt;description&gt;Free swap memory&lt;/description&gt;\n    &lt;name&gt;SWAP_FREE&lt;/name&gt;\n    &lt;unit&gt;bytes&lt;/unit&gt;\n    &lt;category&gt;SWAP&lt;/category&gt;\n    &lt;identifier&gt;SWAP_FREE&lt;/identifier&gt;\n    &lt;priority&gt;302&lt;/priority&gt;\n    &lt;value&gt;NOT AVAILABLE&lt;/value&gt;\n  &lt;/metric&gt;\n  &lt;metric&gt;\n    &lt;available&gt;false&lt;/available&gt;\n    &lt;description&gt;File system usage&lt;/description&gt;\n    &lt;name&gt;FILE_SYSTEM_TOTAL_USAGE&lt;/name&gt;\n    &lt;unit&gt;%&lt;/unit&gt;\n    &lt;category&gt;FILE_SYSTEM&lt;/category&gt;\n    &lt;identifier&gt;FILE_SYSTEM_TOTAL_USAGE&lt;/identifier&gt;\n    &lt;priority&gt;400&lt;/priority&gt;\n    &lt;value&gt;NOT AVAILABLE&lt;/value&gt;\n  &lt;/metric&gt;\n  &lt;metric&gt;\n    &lt;available&gt;false&lt;/available&gt;\n    &lt;description&gt;Partition space used&lt;/description&gt;\n    &lt;name&gt;PARTITION_USED&lt;/name&gt;\n    &lt;unit&gt;%&lt;/unit&gt;\n    &lt;category&gt;FILE_SYSTEM&lt;/category&gt;\n    &lt;identifier&gt;PARTITION_USED&lt;/identifier&gt;\n    &lt;priority&gt;500&lt;/priority&gt;\n    &lt;value&gt;NOT AVAILABLE&lt;/value&gt;\n  &lt;/metric&gt;\n  &lt;metric&gt;\n    &lt;available&gt;false&lt;/available&gt;\n    &lt;description&gt;Partition total space&lt;/description&gt;\n    &lt;name&gt;PARTITION_TOTAL&lt;/name&gt;\n    &lt;unit&gt;bytes&lt;/unit&gt;\n    &lt;category&gt;FILE_SYSTEM&lt;/category&gt;\n    &lt;identifier&gt;PARTITION_TOTAL&lt;/identifier&gt;\n    &lt;priority&gt;501&lt;/priority&gt;\n    &lt;value&gt;NOT AVAILABLE&lt;/value&gt;\n  &lt;/metric&gt;\n  &lt;metric&gt;\n    &lt;available&gt;false&lt;/available&gt;\n    &lt;description&gt;Partition free space&lt;/description&gt;\n    &lt;name&gt;PARTITION_FREE&lt;/name&gt;\n    &lt;unit&gt;bytes&lt;/unit&gt;\n    &lt;category&gt;FILE_SYSTEM&lt;/category&gt;\n    &lt;identifier&gt;PARTITION_FREE&lt;/identifier&gt;\n    &lt;priority&gt;502&lt;/priority&gt;\n    &lt;value&gt;NOT AVAILABLE&lt;/value&gt;\n  &lt;/metric&gt;\n  &lt;metric&gt;\n    &lt;available&gt;false&lt;/available&gt;\n    &lt;description&gt;Network interfaces send&lt;/description&gt;\n    &lt;name&gt;NETWORK_INTERFACES_SEND&lt;/name&gt;\n    &lt;unit&gt;bytes&lt;/unit&gt;\n    &lt;category&gt;NETWORK&lt;/category&gt;\n    &lt;identifier&gt;NETWORK_INTERFACES_SEND&lt;/identifier&gt;\n    &lt;priority&gt;800&lt;/priority&gt;\n    &lt;value&gt;NOT AVAILABLE&lt;/value&gt;\n  &lt;/metric&gt;\n  &lt;metric&gt;\n    &lt;available&gt;false&lt;/available&gt;\n    &lt;description&gt;Network interfaces received&lt;/description&gt;\n    &lt;name&gt;NETWORK_INTERFACES_RECEIVED&lt;/name&gt;\n    &lt;unit&gt;bytes&lt;/unit&gt;\n    &lt;category&gt;NETWORK&lt;/category&gt;\n    &lt;identifier&gt;NETWORK_INTERFACES_RECEIVED&lt;/identifier&gt;\n    &lt;priority&gt;801&lt;/priority&gt;\n    &lt;value&gt;NOT AVAILABLE&lt;/value&gt;\n  &lt;/metric&gt;\n  &lt;metric&gt;\n    &lt;available&gt;false&lt;/available&gt;\n    &lt;description&gt;Network interface band usage&lt;/description&gt;\n    &lt;name&gt;NETWORK_INTERFACE_SEND&lt;/name&gt;\n    &lt;unit&gt;bytes&lt;/unit&gt;\n    &lt;category&gt;NETWORK&lt;/category&gt;\n    &lt;identifier&gt;NETWORK_INTERFACE_SEND&lt;/identifier&gt;\n    &lt;priority&gt;900&lt;/priority&gt;\n    &lt;value&gt;NOT AVAILABLE&lt;/value&gt;\n  &lt;/metric&gt;\n  &lt;metric&gt;\n    &lt;available&gt;false&lt;/available&gt;\n    &lt;description&gt;Network interface available band&lt;/description&gt;\n    &lt;name&gt;NETWORK_INTERFACE_RECEIVED&lt;/name&gt;\n    &lt;unit&gt;bytes&lt;/unit&gt;\n    &lt;category&gt;NETWORK&lt;/category&gt;\n    &lt;identifier&gt;NETWORK_INTERFACE_RECEIVED&lt;/identifier&gt;\n    &lt;priority&gt;901&lt;/priority&gt;\n    &lt;value&gt;NOT AVAILABLE&lt;/value&gt;\n  &lt;/metric&gt;\n  &lt;metric&gt;\n    &lt;available&gt;false&lt;/available&gt;\n    &lt;description&gt;CPU temperature&lt;/description&gt;\n    &lt;name&gt;TEMPERATURE&lt;/name&gt;\n    &lt;unit&gt;\u00b0C&lt;/unit&gt;\n    &lt;category&gt;SENSORS&lt;/category&gt;\n    &lt;identifier&gt;TEMPERATURE&lt;/identifier&gt;\n    &lt;priority&gt;1200&lt;/priority&gt;\n    &lt;value&gt;NOT AVAILABLE&lt;/value&gt;\n  &lt;/metric&gt;\n  &lt;metric&gt;\n    &lt;available&gt;false&lt;/available&gt;\n    &lt;description&gt;CPU voltage&lt;/description&gt;\n    &lt;name&gt;VOLTAGE&lt;/name&gt;\n    &lt;unit&gt;V&lt;/unit&gt;\n    &lt;category&gt;SENSORS&lt;/category&gt;\n    &lt;identifier&gt;VOLTAGE&lt;/identifier&gt;\n    &lt;priority&gt;1201&lt;/priority&gt;\n    &lt;value&gt;NOT AVAILABLE&lt;/value&gt;\n  &lt;/metric&gt;\n  &lt;metric&gt;\n    &lt;available&gt;false&lt;/available&gt;\n    &lt;description&gt;Fan speed&lt;/description&gt;\n    &lt;name&gt;FAN_SPEED&lt;/name&gt;\n    &lt;unit&gt;rpm&lt;/unit&gt;\n    &lt;category&gt;SENSORS&lt;/category&gt;\n    &lt;identifier&gt;FAN_SPEED&lt;/identifier&gt;\n    &lt;priority&gt;1202&lt;/priority&gt;\n    &lt;value&gt;NOT AVAILABLE&lt;/value&gt;\n  &lt;/metric&gt;\n  &lt;metric&gt;\n    &lt;available&gt;false&lt;/available&gt;\n    &lt;description&gt;GeoServer CPU usage&lt;/description&gt;\n    &lt;name&gt;GEOSERVER_CPU_USAGE&lt;/name&gt;\n    &lt;unit&gt;%&lt;/unit&gt;\n    &lt;category&gt;GEOSERVER&lt;/category&gt;\n    &lt;identifier&gt;GEOSERVER_CPU_USAGE&lt;/identifier&gt;\n    &lt;priority&gt;1300&lt;/priority&gt;\n    &lt;value&gt;NOT AVAILABLE&lt;/value&gt;\n  &lt;/metric&gt;\n  &lt;metric&gt;\n    &lt;available&gt;false&lt;/available&gt;\n    &lt;description&gt;GeoServer threads&lt;/description&gt;\n    &lt;name&gt;GEOSERVER_THREADS&lt;/name&gt;\n    &lt;unit&gt;&lt;/unit&gt;\n    &lt;category&gt;GEOSERVER&lt;/category&gt;\n    &lt;identifier&gt;GEOSERVER_THREADS&lt;/identifier&gt;\n    &lt;priority&gt;1301&lt;/priority&gt;\n    &lt;value&gt;NOT AVAILABLE&lt;/value&gt;\n  &lt;/metric&gt;\n  &lt;metric&gt;\n    &lt;available&gt;false&lt;/available&gt;\n    &lt;description&gt;GeoServer JVM memory usage&lt;/description&gt;\n    &lt;name&gt;GEOSERVER_JVM_MEMORY_USAGE&lt;/name&gt;\n    &lt;unit&gt;%&lt;/unit&gt;\n    &lt;category&gt;GEOSERVER&lt;/category&gt;\n    &lt;identifier&gt;GEOSERVER_JVM_MEMORY_USAGE&lt;/identifier&gt;\n    &lt;priority&gt;1302&lt;/priority&gt;\n    &lt;value&gt;NOT AVAILABLE&lt;/value&gt;\n  &lt;/metric&gt;\n&lt;/metrics&gt;\n</pre> In\u00a0[9]: Copied! <pre>html = geoserver.get_system_status(format=\"html\")\nprint(html)\n</pre> html = geoserver.get_system_status(format=\"html\") print(html) <pre>&lt;html&gt;\n\t&lt;head&gt;\n\t\t&lt;style&gt;\n\t\t \tbody {\n\t\t   \t\tmargin:0;\n\t\t   \t\tpadding:0;\n\t\t\t\tbackground: #fff;\n\t\t\t\tcolor: #0076a1;\n\t\t\t\tfont-family: Tahoma, \"Lucida Sans Unicode\", \"Lucida Grande\", Verdana, sans-serif;\n\t\t \t}\n\t\t  \ttable {\n\n\t\t\t}\n\t\t\tth{\n\t\t\t\tbackground: transparent;\n\t\t\t}\n\t\t\ttd{\n\t\t\t\tpadding: 4px 10px 4px 5px;\n\t\t\t}\n\t\t\tthead th {\n\t\t\t\tbackground: #c6e09b;\n\t\t\t\tborder: 1px solid #0076a1;\n\t\t\t\tborder-width: 0 0 1px;\n\t\t\t}\n\t\t\ttr.even td,\n\t\t\ttr.even th {\n\t\t\t\tbackground: #e2efcd;\n\t\t\t}\n\t\t&lt;/style&gt;\n\t&lt;/head&gt;\n  \t&lt;body&gt;\n\t  \t&lt;table width=\"100%\"&gt;\n\t  \t\t&lt;thead&gt;\n\t  \t\t\t&lt;th&gt;Info&lt;/th&gt;\n\t  \t\t\t&lt;th&gt;Value&lt;/th&gt;\n\t  \t\t&lt;/thead&gt;\n\t\t  \t\t\t  \t&lt;tr class=\"odd\"&gt;\n\t\t  \t\t&lt;td&gt;Operating system&lt;/td&gt;\n\t\t  \t\t&lt;td&gt;NOT AVAILABLE&lt;/td&gt;\n\t\t  \t&lt;/tr&gt;\n\t\t  \t&lt;tr class=\"even\"&gt;\n\t\t  \t\t&lt;td&gt;Uptime&lt;/td&gt;\n\t\t  \t\t&lt;td&gt;NOT AVAILABLE&lt;/td&gt;\n\t\t  \t&lt;/tr&gt;\n\t\t  \t&lt;tr class=\"odd\"&gt;\n\t\t  \t\t&lt;td&gt;System average load 1 minute&lt;/td&gt;\n\t\t  \t\t&lt;td&gt;NOT AVAILABLE&lt;/td&gt;\n\t\t  \t&lt;/tr&gt;\n\t\t  \t&lt;tr class=\"even\"&gt;\n\t\t  \t\t&lt;td&gt;System average load 5 minutes&lt;/td&gt;\n\t\t  \t\t&lt;td&gt;NOT AVAILABLE&lt;/td&gt;\n\t\t  \t&lt;/tr&gt;\n\t\t  \t&lt;tr class=\"odd\"&gt;\n\t\t  \t\t&lt;td&gt;System average load 15 minutes&lt;/td&gt;\n\t\t  \t\t&lt;td&gt;NOT AVAILABLE&lt;/td&gt;\n\t\t  \t&lt;/tr&gt;\n\t\t  \t&lt;tr class=\"even\"&gt;\n\t\t  \t\t&lt;td&gt;Number of physical CPUs&lt;/td&gt;\n\t\t  \t\t&lt;td&gt;NOT AVAILABLE&lt;/td&gt;\n\t\t  \t&lt;/tr&gt;\n\t\t  \t&lt;tr class=\"odd\"&gt;\n\t\t  \t\t&lt;td&gt;Number of logical CPUs&lt;/td&gt;\n\t\t  \t\t&lt;td&gt;NOT AVAILABLE&lt;/td&gt;\n\t\t  \t&lt;/tr&gt;\n\t\t  \t&lt;tr class=\"even\"&gt;\n\t\t  \t\t&lt;td&gt;Number of running process&lt;/td&gt;\n\t\t  \t\t&lt;td&gt;NOT AVAILABLE&lt;/td&gt;\n\t\t  \t&lt;/tr&gt;\n\t\t  \t&lt;tr class=\"odd\"&gt;\n\t\t  \t\t&lt;td&gt;Number of running threads&lt;/td&gt;\n\t\t  \t\t&lt;td&gt;NOT AVAILABLE&lt;/td&gt;\n\t\t  \t&lt;/tr&gt;\n\t\t  \t&lt;tr class=\"even\"&gt;\n\t\t  \t\t&lt;td&gt;CPU average load&lt;/td&gt;\n\t\t  \t\t&lt;td&gt;NOT AVAILABLE&lt;/td&gt;\n\t\t  \t&lt;/tr&gt;\n\t\t  \t&lt;tr class=\"odd\"&gt;\n\t\t  \t\t&lt;td&gt;CPU load&lt;/td&gt;\n\t\t  \t\t&lt;td&gt;NOT AVAILABLE&lt;/td&gt;\n\t\t  \t&lt;/tr&gt;\n\t\t  \t&lt;tr class=\"even\"&gt;\n\t\t  \t\t&lt;td&gt;Used physical memory &lt;/td&gt;\n\t\t  \t\t&lt;td&gt;NOT AVAILABLE&lt;/td&gt;\n\t\t  \t&lt;/tr&gt;\n\t\t  \t&lt;tr class=\"odd\"&gt;\n\t\t  \t\t&lt;td&gt;Total physical memory &lt;/td&gt;\n\t\t  \t\t&lt;td&gt;NOT AVAILABLE&lt;/td&gt;\n\t\t  \t&lt;/tr&gt;\n\t\t  \t&lt;tr class=\"even\"&gt;\n\t\t  \t\t&lt;td&gt;Free physical memory&lt;/td&gt;\n\t\t  \t\t&lt;td&gt;NOT AVAILABLE&lt;/td&gt;\n\t\t  \t&lt;/tr&gt;\n\t\t  \t&lt;tr class=\"odd\"&gt;\n\t\t  \t\t&lt;td&gt;Used swap memory&lt;/td&gt;\n\t\t  \t\t&lt;td&gt;NOT AVAILABLE&lt;/td&gt;\n\t\t  \t&lt;/tr&gt;\n\t\t  \t&lt;tr class=\"even\"&gt;\n\t\t  \t\t&lt;td&gt;Total swap memory&lt;/td&gt;\n\t\t  \t\t&lt;td&gt;NOT AVAILABLE&lt;/td&gt;\n\t\t  \t&lt;/tr&gt;\n\t\t  \t&lt;tr class=\"odd\"&gt;\n\t\t  \t\t&lt;td&gt;Free swap memory&lt;/td&gt;\n\t\t  \t\t&lt;td&gt;NOT AVAILABLE&lt;/td&gt;\n\t\t  \t&lt;/tr&gt;\n\t\t  \t&lt;tr class=\"even\"&gt;\n\t\t  \t\t&lt;td&gt;File system usage&lt;/td&gt;\n\t\t  \t\t&lt;td&gt;NOT AVAILABLE&lt;/td&gt;\n\t\t  \t&lt;/tr&gt;\n\t\t  \t&lt;tr class=\"odd\"&gt;\n\t\t  \t\t&lt;td&gt;Partition space used&lt;/td&gt;\n\t\t  \t\t&lt;td&gt;NOT AVAILABLE&lt;/td&gt;\n\t\t  \t&lt;/tr&gt;\n\t\t  \t&lt;tr class=\"even\"&gt;\n\t\t  \t\t&lt;td&gt;Partition total space&lt;/td&gt;\n\t\t  \t\t&lt;td&gt;NOT AVAILABLE&lt;/td&gt;\n\t\t  \t&lt;/tr&gt;\n\t\t  \t&lt;tr class=\"odd\"&gt;\n\t\t  \t\t&lt;td&gt;Partition free space&lt;/td&gt;\n\t\t  \t\t&lt;td&gt;NOT AVAILABLE&lt;/td&gt;\n\t\t  \t&lt;/tr&gt;\n\t\t  \t&lt;tr class=\"even\"&gt;\n\t\t  \t\t&lt;td&gt;Network interfaces send&lt;/td&gt;\n\t\t  \t\t&lt;td&gt;NOT AVAILABLE&lt;/td&gt;\n\t\t  \t&lt;/tr&gt;\n\t\t  \t&lt;tr class=\"odd\"&gt;\n\t\t  \t\t&lt;td&gt;Network interfaces received&lt;/td&gt;\n\t\t  \t\t&lt;td&gt;NOT AVAILABLE&lt;/td&gt;\n\t\t  \t&lt;/tr&gt;\n\t\t  \t&lt;tr class=\"even\"&gt;\n\t\t  \t\t&lt;td&gt;Network interface band usage&lt;/td&gt;\n\t\t  \t\t&lt;td&gt;NOT AVAILABLE&lt;/td&gt;\n\t\t  \t&lt;/tr&gt;\n\t\t  \t&lt;tr class=\"odd\"&gt;\n\t\t  \t\t&lt;td&gt;Network interface available band&lt;/td&gt;\n\t\t  \t\t&lt;td&gt;NOT AVAILABLE&lt;/td&gt;\n\t\t  \t&lt;/tr&gt;\n\t\t  \t&lt;tr class=\"even\"&gt;\n\t\t  \t\t&lt;td&gt;CPU temperature&lt;/td&gt;\n\t\t  \t\t&lt;td&gt;NOT AVAILABLE&lt;/td&gt;\n\t\t  \t&lt;/tr&gt;\n\t\t  \t&lt;tr class=\"odd\"&gt;\n\t\t  \t\t&lt;td&gt;CPU voltage&lt;/td&gt;\n\t\t  \t\t&lt;td&gt;NOT AVAILABLE&lt;/td&gt;\n\t\t  \t&lt;/tr&gt;\n\t\t  \t&lt;tr class=\"even\"&gt;\n\t\t  \t\t&lt;td&gt;Fan speed&lt;/td&gt;\n\t\t  \t\t&lt;td&gt;NOT AVAILABLE&lt;/td&gt;\n\t\t  \t&lt;/tr&gt;\n\t\t  \t&lt;tr class=\"odd\"&gt;\n\t\t  \t\t&lt;td&gt;GeoServer CPU usage&lt;/td&gt;\n\t\t  \t\t&lt;td&gt;NOT AVAILABLE&lt;/td&gt;\n\t\t  \t&lt;/tr&gt;\n\t\t  \t&lt;tr class=\"even\"&gt;\n\t\t  \t\t&lt;td&gt;GeoServer threads&lt;/td&gt;\n\t\t  \t\t&lt;td&gt;NOT AVAILABLE&lt;/td&gt;\n\t\t  \t&lt;/tr&gt;\n\t\t  \t&lt;tr class=\"odd\"&gt;\n\t\t  \t\t&lt;td&gt;GeoServer JVM memory usage&lt;/td&gt;\n\t\t  \t\t&lt;td&gt;NOT AVAILABLE&lt;/td&gt;\n\t\t  \t&lt;/tr&gt;\n\t\t&lt;/table&gt;\n\t&lt;/body&gt;\n &lt;/html&gt;\n</pre>"},{"location":"notebooks/About/#about","title":"About\u00b6","text":"<p>The REST API allows you to set and retrieve information about the server itself.</p> <p>Note:  You can find the official example at https://docs.geoserver.org/2.25.x/en/user/rest/about.html</p>"},{"location":"notebooks/About/#setup","title":"Setup\u00b6","text":""},{"location":"notebooks/About/#imports","title":"Imports\u00b6","text":"<p>First, we need to import the necessary modules and classes.</p>"},{"location":"notebooks/About/#geoserver-connection","title":"GeoServer Connection\u00b6","text":"<p>Connect to the running GeoServer instance and create a workspace and a store.</p>"},{"location":"notebooks/About/#retrieving-version","title":"Retrieving version\u00b6","text":"<p>To get the GeoServer version, we can use the <code>get_version</code> method.</p>"},{"location":"notebooks/About/#retrieving-manifests","title":"Retrieving manifests\u00b6","text":"<p>To get the manifests, we can use the <code>get_manifest</code> method.</p>"},{"location":"notebooks/About/#retrieve-the-full-manifest","title":"Retrieve the full manifest\u00b6","text":"<p>Note:  The result will be a very long list of manifest information. While this can be useful, it is often desirable to filter this list.</p> <pre>geoserver.get_manifest()\n</pre>"},{"location":"notebooks/About/#retrieve-manifests-filtered-by-resource-name","title":"Retrieve manifests, filtered by resource name\u00b6","text":"<p>This example will retrieve only resources where the name attribute matches <code>gwc-.*</code>.</p>"},{"location":"notebooks/About/#retrieve-manifests-filtered-by-resource-property","title":"Retrieve manifests filtered by resource property\u00b6","text":""},{"location":"notebooks/About/#retrieve-manifests-filtered-by-both-resource-name-and-property","title":"Retrieve manifests, filtered by both resource name and property\u00b6","text":"<p>This example will retrieve only resources where a property with named <code>GeoServerModule</code> has a value equal to <code>extension</code>.</p>"},{"location":"notebooks/About/#system-status","title":"System Status\u00b6","text":"<p>It is possible to request the available system information (monitoring data) through the GeoServer REST API. The supported formats are XML, JSON and HTML.</p>"},{"location":"notebooks/All%20In%20One/","title":"All In One","text":"In\u00a0[1]: Copied! <pre>from pathlib import Path\nfrom geoserver import GeoServer\n</pre> from pathlib import Path from geoserver import GeoServer In\u00a0[2]: Copied! <pre># Directory containing sample data\nDATA_DIR = Path(\"../tests/data\")\nassert DATA_DIR.exists(), f\"The directory {DATA_DIR} does not exist.\"\n</pre> # Directory containing sample data DATA_DIR = Path(\"../tests/data\") assert DATA_DIR.exists(), f\"The directory {DATA_DIR} does not exist.\" In\u00a0[3]: Copied! <pre>geoserver = GeoServer(\n    \"http://localhost:8080/geoserver\", \n    username=\"admin\", \n    password=\"geoserver\"\n)\n</pre> geoserver = GeoServer(     \"http://localhost:8080/geoserver\",      username=\"admin\",      password=\"geoserver\" ) In\u00a0[4]: Copied! <pre>if geoserver.workspace_exists(\"demo\"):\n    geoserver.delete_workspace(\"demo\", recurse=True)\n</pre> if geoserver.workspace_exists(\"demo\"):     geoserver.delete_workspace(\"demo\", recurse=True) In\u00a0[5]: Copied! <pre>geoserver.get_workspaces()\n</pre> geoserver.get_workspaces() Out[5]: <pre>{'workspaces': ''}</pre> <p>It is also possible to return the result as XML format using:</p> In\u00a0[6]: Copied! <pre>workspace = geoserver.get_workspaces(format=\"xml\")  # Default is \"json\"\nprint(workspace)\n</pre> workspace = geoserver.get_workspaces(format=\"xml\")  # Default is \"json\" print(workspace) <pre>&lt;workspaces/&gt;\n</pre> In\u00a0[7]: Copied! <pre># Using JSON format\nbody = {\"workspace\": {\"name\": \"demo\"}}\n# Using XML format\nbody = \"&lt;workspace&gt;&lt;name&gt;demo&lt;/name&gt;&lt;/workspace&gt;\"\n\n\ngeoserver.create_workspace(body=body)\n</pre> # Using JSON format body = {\"workspace\": {\"name\": \"demo\"}} # Using XML format body = \"demo\"   geoserver.create_workspace(body=body) Out[7]: <pre>'Created'</pre> In\u00a0[8]: Copied! <pre>geoserver.get_workspace(\"demo\")\n</pre> geoserver.get_workspace(\"demo\") Out[8]: <pre>{'workspace': {'name': 'demo',\n  'isolated': False,\n  'dateCreated': '2024-06-12 22:29:47.282 UTC',\n  'dataStores': 'http://localhost:8080/geoserver/rest/workspaces/demo/datastores.json',\n  'coverageStores': 'http://localhost:8080/geoserver/rest/workspaces/demo/coveragestores.json',\n  'wmsStores': 'http://localhost:8080/geoserver/rest/workspaces/demo/wmsstores.json',\n  'wmtsStores': 'http://localhost:8080/geoserver/rest/workspaces/demo/wmtsstores.json'}}</pre> In\u00a0[9]: Copied! <pre># Using JSON format\nbody = {\"workspace\": {\"name\": \"demo\", \"enabled\": \"true\"}}\n# Using XML format\nbody = \"&lt;workspace&gt;&lt;name&gt;demo&lt;/name&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/workspace&gt;\"\n\n\ngeoserver.update_workspace(\"demo\", body=body)\n</pre> # Using JSON format body = {\"workspace\": {\"name\": \"demo\", \"enabled\": \"true\"}} # Using XML format body = \"demotrue\"   geoserver.update_workspace(\"demo\", body=body) Out[9]: <pre>'Updated'</pre> In\u00a0[10]: Copied! <pre>geoserver.get_data_stores(workspace=\"demo\")\n</pre> geoserver.get_data_stores(workspace=\"demo\") Out[10]: <pre>{'dataStores': ''}</pre> In\u00a0[11]: Copied! <pre># Get the shapefile\nfile_path = DATA_DIR / \"vectors\" / \"buildings.shp\"\nassert file_path.exists(), f\"File not found: {file_path.as_posix()!r}\"\n\n\n# If the store already exists, it will be overwritten\ngeoserver.upload_data_store(file_path, name=\"buildings\", workspace=\"demo\")\n# If the `store` parameter is not provided, the name of the store will be the same as the file name\ngeoserver.upload_data_store(file_path, workspace=\"demo\")\n</pre> # Get the shapefile file_path = DATA_DIR / \"vectors\" / \"buildings.shp\" assert file_path.exists(), f\"File not found: {file_path.as_posix()!r}\"   # If the store already exists, it will be overwritten geoserver.upload_data_store(file_path, name=\"buildings\", workspace=\"demo\") # If the `store` parameter is not provided, the name of the store will be the same as the file name geoserver.upload_data_store(file_path, workspace=\"demo\") Out[11]: <pre>'Created'</pre> In\u00a0[12]: Copied! <pre># Using JSON format\nbody={\n    \"dataStore\": {\n        \"name\": \"buildings_v2\",\n        \"connectionParameters\": {\n            \"entry\": [\n                {\"@key\":\"url\", \"$\": \"file:data/demo/buildings/buildings.shp\"},\n                {\"@key\":\"filetype\", \"$\": \"shapefile\"},\n            ]\n        }\n    }\n}\n\n\n# Using XML format\nbody = \"\"\"\n&lt;dataStore&gt;\n    &lt;name&gt;buildings_v2&lt;/name&gt;\n    &lt;connectionParameters&gt;\n        &lt;entry key=\"url\"&gt;file:data/demo/buildings/buildings.shp&lt;/entry&gt;\n        &lt;entry key=\"filetype\"&gt;shapefile&lt;/entry&gt;\n    &lt;/connectionParameters&gt;\n&lt;/dataStore&gt;\n\"\"\"\n\n\ngeoserver.create_data_store(body=body, workspace=\"demo\")\n</pre> # Using JSON format body={     \"dataStore\": {         \"name\": \"buildings_v2\",         \"connectionParameters\": {             \"entry\": [                 {\"@key\":\"url\", \"$\": \"file:data/demo/buildings/buildings.shp\"},                 {\"@key\":\"filetype\", \"$\": \"shapefile\"},             ]         }     } }   # Using XML format body = \"\"\"  buildings_v2 file:data/demo/buildings/buildings.shp shapefile  \"\"\"   geoserver.create_data_store(body=body, workspace=\"demo\") Out[12]: <pre>'Created'</pre> In\u00a0[13]: Copied! <pre>!ogr2ogr -f PostgreSQL PG:\"host=localhost port=5432 user=admin dbname=db password=postgres\" ../tests/data/vectors/landuse.shp -nlt PROMOTE_TO_MULTI -lco OVERWRITE=YES\n</pre> !ogr2ogr -f PostgreSQL PG:\"host=localhost port=5432 user=admin dbname=db password=postgres\" ../tests/data/vectors/landuse.shp -nlt PROMOTE_TO_MULTI -lco OVERWRITE=YES <pre>Warning 1: Layer creation options ignored since an existing layer is\n         being appended to.\n</pre> In\u00a0[14]: Copied! <pre># Using JSON format\nbody = {\n    \"dataStore\": {\n        \"name\": \"postgis\",\n        \"description\": \"PostGIS connection\",\n        \"connectionParameters\": {\n            \"host\": \"postgis\",\n            \"port\": \"5432\",\n            \"database\": \"db\",\n            \"user\": \"admin\",\n            \"passwd\": \"postgres\",\n            \"dbtype\": \"postgis\",\n            \"schema\": \"public\",\n            \"Expose primary keys\": \"true\",\n            \"Loose bbox\": \"true\",\n            \"Estimated extends\": \"true\",\n            \"fetch size\": \"1000\",\n            \"Max open prepared statements\": \"50\",\n            \"preparedStatements\": \"false\",\n            \"validate connections\": \"true\",\n            \"validate connections on borrow\": \"true\",\n            \"validate connections on return\": \"true\",\n            \"Connection timeout\": \"20\",\n            \"Eviction run periodicity\": \"3600\",\n            \"Min evictable idle time\": \"300\",\n            \"Max active\": \"50\",\n            \"Max idle\": \"10\",\n            \"Max wait\": \"10000\",\n            \"Test on borrow\": \"true\",\n            \"Test while idle\": \"true\",\n            \"Time between eviction runs\": \"60000\",\n        }\n    }\n}\n\n# Using XML format\nbody = \"\"\"\n&lt;dataStore&gt;\n    &lt;name&gt;postgis&lt;/name&gt;\n    &lt;description&gt;PostGIS connection&lt;/description&gt;\n    &lt;connectionParameters&gt;\n        &lt;entry key=\"host\"&gt;postgis&lt;/entry&gt;\n        &lt;entry key=\"port\"&gt;5432&lt;/entry&gt;\n        &lt;entry key=\"database\"&gt;db&lt;/entry&gt;\n        &lt;entry key=\"user\"&gt;admin&lt;/entry&gt;\n        &lt;entry key=\"passwd\"&gt;postgres&lt;/entry&gt;\n        &lt;entry key=\"dbtype\"&gt;postgis&lt;/entry&gt;\n        &lt;entry key=\"schema\"&gt;public&lt;/entry&gt;\n        &lt;entry key=\"Expose primary keys\"&gt;true&lt;/entry&gt;\n        &lt;entry key=\"Loose bbox\"&gt;true&lt;/entry&gt;\n        &lt;entry key=\"Estimated extends\"&gt;true&lt;/entry&gt;\n        &lt;entry key=\"fetch size\"&gt;1000&lt;/entry&gt;\n        &lt;entry key=\"Max open prepared statements\"&gt;50&lt;/entry&gt;\n        &lt;entry key=\"preparedStatements\"&gt;false&lt;/entry&gt;\n        &lt;entry key=\"validate connections\"&gt;true&lt;/entry&gt;\n        &lt;entry key=\"validate connections on borrow\"&gt;true&lt;/entry&gt;\n        &lt;entry key=\"validate connections on return\"&gt;true&lt;/entry&gt;\n        &lt;entry key=\"Connection timeout\"&gt;20&lt;/entry&gt;\n        &lt;entry key=\"Eviction run periodicity\"&gt;3600&lt;/entry&gt;\n        &lt;entry key=\"Min evictable idle time\"&gt;300&lt;/entry&gt;\n        &lt;entry key=\"Max active\"&gt;50&lt;/entry&gt;\n        &lt;entry key=\"Max idle\"&gt;10&lt;/entry&gt;\n        &lt;entry key=\"Max wait\"&gt;10000&lt;/entry&gt;\n        &lt;entry key=\"Test on borrow\"&gt;true&lt;/entry&gt;\n        &lt;entry key=\"Test while idle\"&gt;true&lt;/entry&gt;\n        &lt;entry key=\"Time between eviction runs\"&gt;60000&lt;/entry&gt;\n    &lt;/connectionParameters&gt;\n&lt;/dataStore&gt;\n\"\"\"\n\n\ngeoserver.create_data_store(body=body, workspace=\"demo\")\n</pre> # Using JSON format body = {     \"dataStore\": {         \"name\": \"postgis\",         \"description\": \"PostGIS connection\",         \"connectionParameters\": {             \"host\": \"postgis\",             \"port\": \"5432\",             \"database\": \"db\",             \"user\": \"admin\",             \"passwd\": \"postgres\",             \"dbtype\": \"postgis\",             \"schema\": \"public\",             \"Expose primary keys\": \"true\",             \"Loose bbox\": \"true\",             \"Estimated extends\": \"true\",             \"fetch size\": \"1000\",             \"Max open prepared statements\": \"50\",             \"preparedStatements\": \"false\",             \"validate connections\": \"true\",             \"validate connections on borrow\": \"true\",             \"validate connections on return\": \"true\",             \"Connection timeout\": \"20\",             \"Eviction run periodicity\": \"3600\",             \"Min evictable idle time\": \"300\",             \"Max active\": \"50\",             \"Max idle\": \"10\",             \"Max wait\": \"10000\",             \"Test on borrow\": \"true\",             \"Test while idle\": \"true\",             \"Time between eviction runs\": \"60000\",         }     } }  # Using XML format body = \"\"\"  postgis PostGIS connection postgis 5432 db admin postgres postgis public true true true 1000 50 false true true true 20 3600 300 50 10 10000 true true 60000  \"\"\"   geoserver.create_data_store(body=body, workspace=\"demo\") Out[14]: <pre>'Created'</pre> <p>Once added, you should also publish the feature types contained in the data store. Use the <code>create_feature_type</code> method to do this.</p> In\u00a0[15]: Copied! <pre># Using JSON format\nbody = {\n    \"featureType\": {\n        \"name\": \"landuse\",\n        \"title\": \"landuse\",\n        \"advertised\": \"true\",\n    }\n}\n# Using XML format\nbody = \"\"\"\n&lt;featureType&gt;\n    &lt;name&gt;landuse&lt;/name&gt;\n    &lt;title&gt;landuse&lt;/title&gt;\n    &lt;advertised&gt;true&lt;/advertised&gt;\n&lt;/featureType&gt;\n\"\"\"\n\n\ngeoserver.create_feature_type(body=body, workspace=\"demo\", store=\"postgis\")\n</pre> # Using JSON format body = {     \"featureType\": {         \"name\": \"landuse\",         \"title\": \"landuse\",         \"advertised\": \"true\",     } } # Using XML format body = \"\"\"  landuse landuse true  \"\"\"   geoserver.create_feature_type(body=body, workspace=\"demo\", store=\"postgis\") Out[15]: <pre>'Created'</pre> In\u00a0[16]: Copied! <pre>geoserver.get_data_store(name=\"buildings\", workspace=\"demo\")\n</pre> geoserver.get_data_store(name=\"buildings\", workspace=\"demo\") Out[16]: <pre>{'dataStore': {'name': 'buildings',\n  'type': 'Shapefile',\n  'enabled': True,\n  'workspace': {'name': 'demo',\n   'href': 'http://localhost:8080/geoserver/rest/workspaces/demo.json'},\n  'connectionParameters': {'entry': [{'@key': 'namespace', '$': 'http://demo'},\n    {'@key': 'url',\n     '$': 'file:/opt/geoserver/data_dir/data/demo/buildings/buildings.shp'}]},\n  '_default': False,\n  'dateCreated': '2024-06-12 22:29:47.368 UTC',\n  'dateModified': '2024-06-12 22:29:47.377 UTC',\n  'disableOnConnFailure': False,\n  'featureTypes': 'http://localhost:8080/geoserver/rest/workspaces/demo/datastores/buildings/featuretypes.json'}}</pre> In\u00a0[17]: Copied! <pre>geoserver.reset_data_store_caches(name=\"buildings\", workspace=\"demo\")\n</pre> geoserver.reset_data_store_caches(name=\"buildings\", workspace=\"demo\") Out[17]: <pre>'OK'</pre> In\u00a0[18]: Copied! <pre># Using JSON format\nbody = {\n    \"dataStore\": {\n        \"name\": \"buildings\",\n    }\n}\n\n# Using XML format\nbody = \"&lt;dataStore&gt;&lt;name&gt;buildings&lt;/name&gt;&lt;/dataStore&gt;\"\n\n\ngeoserver.update_data_store(name=\"buildings\", body=body, workspace=\"demo\")\n</pre> # Using JSON format body = {     \"dataStore\": {         \"name\": \"buildings\",     } }  # Using XML format body = \"buildings\"   geoserver.update_data_store(name=\"buildings\", body=body, workspace=\"demo\") Out[18]: <pre>'Updated'</pre> In\u00a0[19]: Copied! <pre>geoserver.get_coverage_stores(workspace=\"demo\")\n</pre> geoserver.get_coverage_stores(workspace=\"demo\") Out[19]: <pre>{'coverageStores': ''}</pre> In\u00a0[20]: Copied! <pre>file_path = DATA_DIR / \"rasters\" /  \"raster.tif\"\nassert file_path.exists(), f\"File not found: {file_path.as_posix()!r}\"\n\n\n# If the store already exists, it will be overwritten\ngeoserver.upload_coverage_store(file_path, format=\"geotiff\", workspace=\"demo\", name=\"raster\")\n# If the `store` parameter is not provided, the name of the store will be the same as the file name\ngeoserver.upload_coverage_store(file_path, format=\"geotiff\", workspace=\"demo\")\n</pre> file_path = DATA_DIR / \"rasters\" /  \"raster.tif\" assert file_path.exists(), f\"File not found: {file_path.as_posix()!r}\"   # If the store already exists, it will be overwritten geoserver.upload_coverage_store(file_path, format=\"geotiff\", workspace=\"demo\", name=\"raster\") # If the `store` parameter is not provided, the name of the store will be the same as the file name geoserver.upload_coverage_store(file_path, format=\"geotiff\", workspace=\"demo\") Out[20]: <pre>'Created'</pre> In\u00a0[21]: Copied! <pre>geoserver.get_coverage_store(name=\"raster\", workspace=\"demo\")\n</pre> geoserver.get_coverage_store(name=\"raster\", workspace=\"demo\") Out[21]: <pre>{'coverageStore': {'name': 'raster',\n  'type': 'GeoTIFF',\n  'enabled': True,\n  'workspace': {'name': 'demo',\n   'href': 'http://localhost:8080/geoserver/rest/workspaces/demo.json'},\n  '_default': False,\n  'dateCreated': '2024-06-12 22:29:47.909 UTC',\n  'dateModified': '2024-06-12 22:29:47.928 UTC',\n  'disableOnConnFailure': False,\n  'url': 'file:data/demo/raster/raster.tif',\n  'coverages': 'http://localhost:8080/geoserver/rest/workspaces/demo/coveragestores/raster/coverages.json'}}</pre> In\u00a0[22]: Copied! <pre># Using JSON format\nbody = {\n    \"coverageStore\": {\n        \"name\": \"raster\",\n    }\n}\n\n# Using XML format\nbody = \"\"\"\n&lt;coverageStore&gt;\n    &lt;name&gt;raster&lt;/name&gt;\n&lt;/coverageStore&gt;\n\"\"\"\n\n\ngeoserver.update_coverage_store(name=\"raster\", body=body, workspace=\"demo\")\n</pre> # Using JSON format body = {     \"coverageStore\": {         \"name\": \"raster\",     } }  # Using XML format body = \"\"\"  raster  \"\"\"   geoserver.update_coverage_store(name=\"raster\", body=body, workspace=\"demo\") Out[22]: <pre>'Updated'</pre> In\u00a0[23]: Copied! <pre>geoserver.get_coverages(workspace=\"demo\")\n</pre> geoserver.get_coverages(workspace=\"demo\") Out[23]: <pre>{'coverages': {'coverage': [{'name': 'raster',\n    'href': 'http://localhost:8080/geoserver/rest/workspaces/demo/coverages/raster.json'}]}}</pre> In\u00a0[24]: Copied! <pre>geoserver.get_coverage(workspace=\"demo\", name=\"raster\")\n</pre> geoserver.get_coverage(workspace=\"demo\", name=\"raster\") Out[24]: <pre>{'coverage': {'name': 'raster',\n  'nativeName': 'raster',\n  'namespace': {'name': 'demo',\n   'href': 'http://localhost:8080/geoserver/rest/namespaces/demo.json'},\n  'title': 'raster',\n  'description': 'Generated from GeoTIFF',\n  'keywords': {'string': ['raster', 'WCS', 'GeoTIFF']},\n  'nativeCRS': 'GEOGCS[\"WGS 84\", \\n  DATUM[\"World Geodetic System 1984\", \\n    SPHEROID[\"WGS 84\", 6378137.0, 298.257223563, AUTHORITY[\"EPSG\",\"7030\"]], \\n    AUTHORITY[\"EPSG\",\"6326\"]], \\n  PRIMEM[\"Greenwich\", 0.0, AUTHORITY[\"EPSG\",\"8901\"]], \\n  UNIT[\"degree\", 0.017453292519943295], \\n  AXIS[\"Geodetic longitude\", EAST], \\n  AXIS[\"Geodetic latitude\", NORTH], \\n  AUTHORITY[\"EPSG\",\"4326\"]]',\n  'srs': 'EPSG:4326',\n  'nativeBoundingBox': {'minx': -1.514093836,\n   'maxx': -1.508900084,\n   'miny': 48.63391919,\n   'maxy': 48.638064247,\n   'crs': 'EPSG:4326'},\n  'latLonBoundingBox': {'minx': -1.514093836,\n   'maxx': -1.508900084,\n   'miny': 48.63391919,\n   'maxy': 48.638064247,\n   'crs': 'EPSG:4326'},\n  'projectionPolicy': 'REPROJECT_TO_DECLARED',\n  'enabled': True,\n  'advertised': True,\n  'metadata': {'entry': {'@key': 'dirName', '$': 'raster_null'}},\n  'store': {'@class': 'coverageStore',\n   'name': 'demo:raster',\n   'href': 'http://localhost:8080/geoserver/rest/workspaces/demo/coveragestores/raster.json'},\n  'serviceConfiguration': False,\n  'simpleConversionEnabled': False,\n  'nativeFormat': 'GeoTIFF',\n  'grid': {'@dimension': 2,\n   'range': {'low': '0 0', 'high': '866 691'},\n   'transform': {'scaleX': '5.997404157043939E-6',\n    'scaleY': '-5.998635311146656E-6',\n    'shearX': 0,\n    'shearY': 0,\n    'translateX': -1.5140908372979216,\n    'translateY': 48.638061247682344},\n   'crs': 'EPSG:4326'},\n  'supportedFormats': {'string': ['GIF',\n    'PNG',\n    'JPEG',\n    'TIFF',\n    'NetCDF',\n    'EHdr',\n    'VRT',\n    'GEOTIFF',\n    'DTED',\n    'ArcGrid',\n    'RST',\n    'GeoPackage (mosaic)',\n    'ImageMosaic',\n    'SRP',\n    'ENVIHdr',\n    'ERDASImg',\n    'ImagePyramid',\n    'AIG',\n    'RPFTOC',\n    'NITF']},\n  'interpolationMethods': {'string': ['nearest neighbor',\n    'bilinear',\n    'bicubic']},\n  'defaultInterpolationMethod': 'nearest neighbor',\n  'dimensions': {'coverageDimension': [{'name': 'RED_BAND',\n     'description': 'GridSampleDimension[-Infinity,Infinity]',\n     'range': {'min': '-inf', 'max': 'inf'},\n     'unit': 'W.m-2.Sr-1',\n     'dimensionType': {'name': 'UNSIGNED_8BITS'}},\n    {'name': 'GREEN_BAND',\n     'description': 'GridSampleDimension[-Infinity,Infinity]',\n     'range': {'min': '-inf', 'max': 'inf'},\n     'unit': 'W.m-2.Sr-1',\n     'dimensionType': {'name': 'UNSIGNED_8BITS'}},\n    {'name': 'BLUE_BAND',\n     'description': 'GridSampleDimension[-Infinity,Infinity]',\n     'range': {'min': '-inf', 'max': 'inf'},\n     'unit': 'W.m-2.Sr-1',\n     'dimensionType': {'name': 'UNSIGNED_8BITS'}},\n    {'name': 'ALPHA_BAND',\n     'description': 'GridSampleDimension[-Infinity,Infinity]',\n     'range': {'min': '-inf', 'max': 'inf'},\n     'dimensionType': {'name': 'UNSIGNED_8BITS'}}]},\n  'requestSRS': {'string': 'EPSG:4326'},\n  'responseSRS': {'string': 'EPSG:4326'},\n  'parameters': {'entry': [{'string': ['InputTransparentColor', '']},\n    {'string': ['SUGGESTED_TILE_SIZE', '512,512']},\n    {'string': ['Bands', '']},\n    {'string': ['RescalePixels', True]}]},\n  'nativeCoverageName': 'raster'}}</pre> In\u00a0[\u00a0]: Copied! <pre>geoserver.get_styles()\n</pre> geoserver.get_styles() Out[\u00a0]: <pre>{'styles': {'style': [{'name': 'generic',\n    'href': 'http://localhost:8080/geoserver/rest/styles/generic.json'},\n   {'name': 'line',\n    'href': 'http://localhost:8080/geoserver/rest/styles/line.json'},\n   {'name': 'point',\n    'href': 'http://localhost:8080/geoserver/rest/styles/point.json'},\n   {'name': 'polygon',\n    'href': 'http://localhost:8080/geoserver/rest/styles/polygon.json'},\n   {'name': 'raster',\n    'href': 'http://localhost:8080/geoserver/rest/styles/raster.json'}]}}</pre> In\u00a0[\u00a0]: Copied! <pre>geoserver.get_style(\"point\")\n</pre> geoserver.get_style(\"point\") Out[\u00a0]: <pre>{'style': {'name': 'point',\n  'format': 'sld',\n  'languageVersion': {'version': '1.0.0'},\n  'filename': 'default_point.sld'}}</pre> In\u00a0[\u00a0]: Copied! <pre># Using XML format\nbody = \"\"\"\n&lt;style&gt;\n    &lt;name&gt;elevation&lt;/name&gt;\n    &lt;filename&gt;elevation.sld&lt;/filename&gt;\n&lt;/style&gt;\n\"\"\"\n\ngeoserver.create_style(body=body, workspace=\"demo\")\n</pre> # Using XML format body = \"\"\"  \"\"\"  geoserver.create_style(body=body, workspace=\"demo\") Out[\u00a0]: <pre>'Created'</pre> In\u00a0[\u00a0]: Copied! <pre># Get the styles associated to the raster layer\nfile_path = DATA_DIR / \"styles\" / \"elevation.sld\"\nassert file_path.exists(), f\"File not found: {file_path.as_posix()!r}\"\n\n\nwith open(file_path, \"r\") as file:\n    body = file.read()\n\n    \ngeoserver.update_style(\"elevation\", body=body, workspace=\"demo\")\n</pre> # Get the styles associated to the raster layer file_path = DATA_DIR / \"styles\" / \"elevation.sld\" assert file_path.exists(), f\"File not found: {file_path.as_posix()!r}\"   with open(file_path, \"r\") as file:     body = file.read()       geoserver.update_style(\"elevation\", body=body, workspace=\"demo\") Out[\u00a0]: <pre>'Updated'</pre> In\u00a0[\u00a0]: Copied! <pre># Get the styles associated to the raster layer\nfile_path = DATA_DIR / \"styles\" / \"elevation.sld\"\nassert file_path.exists(), f\"File not found: {file_path.as_posix()!r}\"\n\n\ngeoserver.upload_style(file=file_path, workspace=\"demo\", name=\"elevation_v2\")\n</pre> # Get the styles associated to the raster layer file_path = DATA_DIR / \"styles\" / \"elevation.sld\" assert file_path.exists(), f\"File not found: {file_path.as_posix()!r}\"   geoserver.upload_style(file=file_path, workspace=\"demo\", name=\"elevation_v2\") Out[\u00a0]: <pre>'Created'</pre> In\u00a0[\u00a0]: Copied! <pre># Get the styles associated to the raster layer\nfile_path = DATA_DIR / \"styles\" / \"elevation.sld\"\nassert file_path.exists(), f\"File not found: {file_path.as_posix()!r}\"\n\n\nwith open(file_path, \"r\") as file:\n    body = file.read()\n\n    \ngeoserver.update_style(\"elevation\", body=body, workspace=\"demo\")\n</pre> # Get the styles associated to the raster layer file_path = DATA_DIR / \"styles\" / \"elevation.sld\" assert file_path.exists(), f\"File not found: {file_path.as_posix()!r}\"   with open(file_path, \"r\") as file:     body = file.read()       geoserver.update_style(\"elevation\", body=body, workspace=\"demo\") Out[\u00a0]: <pre>'Updated'</pre> In\u00a0[\u00a0]: Copied! <pre>xml = geoserver.download_style(\"elevation\", workspace=\"demo\")\nprint(xml)\n</pre> xml = geoserver.download_style(\"elevation\", workspace=\"demo\") print(xml) <pre>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;sld:StyledLayerDescriptor xmlns=\"http://www.opengis.net/sld\" xmlns:sld=\"http://www.opengis.net/sld\" xmlns:gml=\"http://www.opengis.net/gml\" xmlns:ogc=\"http://www.opengis.net/ogc\" version=\"1.0.0\"&gt;\n  &lt;sld:NamedLayer&gt;\n    &lt;sld:Name&gt;raster&lt;/sld:Name&gt;\n    &lt;sld:UserStyle&gt;\n      &lt;sld:Name&gt;raster&lt;/sld:Name&gt;\n      &lt;sld:FeatureTypeStyle&gt;\n        &lt;sld:Name&gt;name&lt;/sld:Name&gt;\n        &lt;sld:Rule&gt;\n          &lt;sld:RasterSymbolizer&gt;\n            &lt;sld:ChannelSelection&gt;\n              &lt;sld:GrayChannel&gt;\n                &lt;sld:SourceChannelName&gt;1&lt;/sld:SourceChannelName&gt;\n                &lt;sld:ContrastEnhancement&gt;\n                  &lt;sld:GammaValue&gt;1.0&lt;/sld:GammaValue&gt;\n                &lt;/sld:ContrastEnhancement&gt;\n              &lt;/sld:GrayChannel&gt;\n            &lt;/sld:ChannelSelection&gt;\n            &lt;sld:ColorMap&gt;\n              &lt;sld:ColorMapEntry color=\"#FFFFFF\" opacity=\"0\" quantity=\"-1\" label=\"label\"/&gt;\n              &lt;sld:ColorMapEntry color=\"#0000FF\" opacity=\"1\" quantity=\"0\" label=\"label\"/&gt;\n              &lt;sld:ColorMapEntry color=\"#FF0000\" opacity=\"1\" quantity=\"110\" label=\"label\"/&gt;\n            &lt;/sld:ColorMap&gt;\n            &lt;sld:ContrastEnhancement/&gt;\n          &lt;/sld:RasterSymbolizer&gt;\n        &lt;/sld:Rule&gt;\n      &lt;/sld:FeatureTypeStyle&gt;\n    &lt;/sld:UserStyle&gt;\n  &lt;/sld:NamedLayer&gt;\n&lt;/sld:StyledLayerDescriptor&gt;\n\n\n</pre>"},{"location":"notebooks/All%20In%20One/#all-in-one","title":"All In One\u00b6","text":"<p>This notebook showcases some of the most common use cases to interact with a <code>GeoServer</code> server using its REST API through the <code>geoserver-py</code> Python package.</p>"},{"location":"notebooks/All%20In%20One/#imports","title":"Imports\u00b6","text":"<p>Let's start by importing the required libraries:</p>"},{"location":"notebooks/All%20In%20One/#config","title":"Config\u00b6","text":"<p>We'll set up the configuration for the notebook:</p>"},{"location":"notebooks/All%20In%20One/#connection","title":"Connection\u00b6","text":"<p>Connect to the GeoServer instance using the <code>GeoServer</code> object. You can pass additional parameters to the constructor, such as the <code>username</code>, <code>password</code> and other <code>requests</code> supported parameters.</p>"},{"location":"notebooks/All%20In%20One/#setup","title":"Setup\u00b6","text":"<p>If the demo workspace already exists, we will delete it so that the demo can be run multiple times.</p>"},{"location":"notebooks/All%20In%20One/#workspaces","title":"Workspaces\u00b6","text":""},{"location":"notebooks/All%20In%20One/#list-existing-workspaces","title":"List existing workspaces\u00b6","text":"<p>To list the existing workspaces, we can use the <code>get_workspaces</code> method.</p>"},{"location":"notebooks/All%20In%20One/#create-a-new-workspace","title":"Create a new workspace\u00b6","text":"<p>To create a new workspace, use the <code>create_workspace</code> method. This method will return a success message if the workspace is created successfully.</p>"},{"location":"notebooks/All%20In%20One/#select-a-workspace","title":"Select a workspace\u00b6","text":"<p>To select a specific workspace, use the <code>get_workspace</code> method.</p>"},{"location":"notebooks/All%20In%20One/#update-a-workspace","title":"Update a workspace\u00b6","text":"<p>To update a workspace, use the <code>update_workspace</code> method.</p>"},{"location":"notebooks/All%20In%20One/#remove-a-workspace","title":"Remove a workspace\u00b6","text":"<p>To remove a workspace, use the <code>delete_workspace</code> method. This method will return a success message if the workspace is removed successfully. If the workspace is not empty, an error will be raised. To remove a workspace and all its contents, use the <code>recurse=True</code> argument.</p> <pre>geoserver.delete_workspace(workspace=\"demo\", recurse=True)\n</pre>"},{"location":"notebooks/All%20In%20One/#datastores","title":"Datastores\u00b6","text":"<p>This section will guide you on how to interact with data stores in the GeoServer instance.</p>"},{"location":"notebooks/All%20In%20One/#list-existing-data-stores","title":"List existing data stores\u00b6","text":"<p>To view the data stores in the workspace, use the <code>get_data_stores</code> method:</p>"},{"location":"notebooks/All%20In%20One/#create-a-new-data-stores","title":"Create a new data stores\u00b6","text":"<p>There are different ways to create / add data in a GeoServer instance. You can either upload diretly your data (from a local file, external URL, PostGIS, etc.) or create a new data store from a data already present in the GeoServer instance (e.g. you can reference a file that is already present in the <code>data</code> directory of the geoserver).</p>"},{"location":"notebooks/All%20In%20One/#from-a-local-shapefile","title":"From a local shapefile\u00b6","text":"<p>To upload a data store from a local shapefile, use the <code>upload_data_store</code> method. This method will return a success message if the data store is created successfully.</p>"},{"location":"notebooks/All%20In%20One/#from-a-file-already-present-in-the-geoserver-instance","title":"From a file already present in the GeoServer instance\u00b6","text":"<p>Now that we have uploaded a file <code>buildings.shp</code> to the GeoServer instance, we can create a new data store from this file.</p>"},{"location":"notebooks/All%20In%20One/#from-a-postgis-database","title":"From a PostGIS database\u00b6","text":"<p>You can also add a PostGIS data store to the GeoServer instance. To do this, you need to provide the database connection details.</p> <p>You will have to upload the data to the PostGIS database first:</p>"},{"location":"notebooks/All%20In%20One/#select-a-data-store","title":"Select a data store\u00b6","text":"<p>Now that we created a data store from a vector source, we can list it using the <code>get_data_stores</code> method.</p>"},{"location":"notebooks/All%20In%20One/#clear-data-caches","title":"Clear data caches\u00b6","text":"<p>You can clear the data caches using the <code>clear_data_store_cache</code> method.</p>"},{"location":"notebooks/All%20In%20One/#update-a-data-store","title":"Update a data store\u00b6","text":"<p>To update a data store, use the <code>update_data_store</code> method.</p>"},{"location":"notebooks/All%20In%20One/#remove-a-data-store","title":"Remove a data store\u00b6","text":"<p>To delete a datastore, use the following command:</p> <pre>geoserver.delete_data_store(name=\"buildings\", workspace=\"demo\")\n</pre>"},{"location":"notebooks/All%20In%20One/#coverage-stores","title":"Coverage Stores\u00b6","text":"<p>Coverage stores are used to store raster data. A coverage is a raster based data which originates from a coverage store.</p>"},{"location":"notebooks/All%20In%20One/#list-existing-coverage-stores","title":"List existing coverage stores\u00b6","text":"<p>To list the existing coverage stores, use the <code>get_coverage_stores</code> method.</p>"},{"location":"notebooks/All%20In%20One/#create-a-new-coverage-store","title":"Create a new coverage store\u00b6","text":"<p>You can create a coverage store from a local raster file. Use the <code>upload_coverage_store</code> method to create a new coverage store.</p>"},{"location":"notebooks/All%20In%20One/#select-a-coverage-store","title":"Select a coverage store\u00b6","text":"<p>To select a specific coverage store, use the <code>get_coverage_store</code> method.</p>"},{"location":"notebooks/All%20In%20One/#update-a-coverage-store","title":"Update a coverage store\u00b6","text":""},{"location":"notebooks/All%20In%20One/#remove-a-coverage-store","title":"Remove a coverage store\u00b6","text":"<p>To remove a coverage store, use the <code>delete_coverage_store</code> method.</p> <pre>geoserver.delete_coverage_store(name=\"raster\", workspace=\"demo\", recurse=True)\n</pre>"},{"location":"notebooks/All%20In%20One/#coverages","title":"Coverages\u00b6","text":"<p>Coverages are automatically created when a coverage store is created.</p>"},{"location":"notebooks/All%20In%20One/#list-existing-coverages","title":"List existing coverages\u00b6","text":"<p>To list the existing coverages, use the <code>get_coverages</code> method.</p>"},{"location":"notebooks/All%20In%20One/#select-a-coverage","title":"Select a coverage\u00b6","text":"<p>To select a specific coverage, use the <code>get_coverage</code> method.</p>"},{"location":"notebooks/All%20In%20One/#styles","title":"Styles\u00b6","text":"<p>The REST API allows you to list, create, upload, update, and delete styles in GeoServer.</p>"},{"location":"notebooks/All%20In%20One/#listing-all-styles","title":"Listing all styles\u00b6","text":"<p>To list all the styles in the GeoServer instance, use the <code>get_styles</code> method.</p>"},{"location":"notebooks/All%20In%20One/#retrieve-a-style","title":"Retrieve a style\u00b6","text":"<p>To get a specific style, use the <code>get_style</code> method.</p>"},{"location":"notebooks/All%20In%20One/#creating-a-style","title":"Creating a style\u00b6","text":"<p>You can create a new style on the server in two ways. In the first way, the creation is done in two steps: the style entry is created in the catalog, and then the style content is uploaded. The second way can add the style to the server in a single step by uploading a file containing the style content.</p>"},{"location":"notebooks/All%20In%20One/#create-a-new-style-in-two-steps","title":"Create a new style in two steps\u00b6","text":""},{"location":"notebooks/All%20In%20One/#uploading-a-style-from-an-sld-file","title":"Uploading a style from an SLD file\u00b6","text":""},{"location":"notebooks/All%20In%20One/#changing-an-existing-style","title":"Changing an existing style\u00b6","text":"<p>To update a style, use the <code>update_style</code> method.</p>"},{"location":"notebooks/All%20In%20One/#downloading-a-style","title":"Downloading a style\u00b6","text":"<p>The SLD itself can be downloaded using the <code>download_style</code> method.</p>"},{"location":"notebooks/All%20In%20One/#deleting-a-style","title":"Deleting a style\u00b6","text":"<p>To delete a style, use the <code>delete_style</code> method. You can use the <code>purge=True</code> argument to remove the style and all its references.</p>"},{"location":"notebooks/Fonts/","title":"Fonts","text":"In\u00a0[1]: Copied! <pre>from geoserver import GeoServer\n</pre> from geoserver import GeoServer In\u00a0[2]: Copied! <pre># Setup the geoserver instance\ngeoserver = GeoServer(\n    service_url=\"http://localhost:8080/geoserver\",\n    username=\"admin\",\n    password=\"geoserver\",\n)\n</pre> # Setup the geoserver instance geoserver = GeoServer(     service_url=\"http://localhost:8080/geoserver\",     username=\"admin\",     password=\"geoserver\", ) In\u00a0[3]: Copied! <pre>geoserver.get_fonts()\n</pre> geoserver.get_fonts() Out[3]: <pre>{'fonts': ['10.15 Saturday Night BRK',\n  '10.15 Saturday Night R BRK',\n  '18 Holes BRK',\n  '36 days ago BRK',\n  '36 days ago Thick BRK',\n  '3D LET BRK',\n  '8-bit Limit BRK',\n  '8-bit Limit O BRK',\n  '8-bit Limit R BRK',\n  '8-bit Limit RO BRK',\n  '90 Stars BRK',\n  'Acid Reflux BRK',\n  'Acknowledge TT BRK',\n  'Aftermath BRK',\n  'Alpha Beta BRK',\n  'Amalgamate BRK',\n  'Amalgamate O BRK',\n  'Amplitude BRK',\n  'Andale Mono',\n  'Arial',\n  'Arial Black',\n  'Arial Bold',\n  'Arial Bold Italic',\n  'Arial Italic',\n  'Arthritis BRK',\n  'Aspartame BRK',\n  'Ataxia BRK',\n  'Ataxia Outline BRK',\n  'Automatica BRK',\n  'Backlash BRK',\n  'Bandwidth BRK',\n  'Bandwidth Bandless BRK',\n  'Bandwidth Bandmess BRK',\n  'Bend 2 Squares BRK',\n  'Bend 2 Squares OL1 BRK',\n  'Bend 2 Squares OL2 BRK',\n  'Bendable BRK',\n  'Bewilder BRK',\n  'Bewilder Thick BRK',\n  'Binary 01s BRK',\n  'Binary BRK',\n  'Binary CHR BRK',\n  'Binary X 01s BRK',\n  'Binary X BRK',\n  'Binary X CHR BRK',\n  'Bit Blocks TTF BRK',\n  'Bitstream Vera Sans',\n  'Bitstream Vera Sans Bold',\n  'Bitstream Vera Sans Bold Oblique',\n  'Bitstream Vera Sans Mono',\n  'Bitstream Vera Sans Mono Bold',\n  'Bitstream Vera Sans Mono Bold Oblique',\n  'Bitstream Vera Sans Mono Oblique',\n  'Bitstream Vera Sans Oblique',\n  'Bitstream Vera Serif',\n  'Bitstream Vera Serif Bold',\n  'Blackoninaut BRK',\n  'Blackoninaut Bold BRK',\n  'Blackoninaut Redux BRK',\n  'Bleak Segments BRK',\n  'Block Tilt BRK',\n  'Blox BRK',\n  'Bobcaygeon BRK',\n  'Bobcaygeon Plain BRK',\n  'Bocuma Angle BRK',\n  'Bocuma Angle Dent BRK',\n  'Bocuma BRK',\n  'Bocuma Batty BRK',\n  'Bocuma Dent BRK',\n  'Brass Knuckle BRK',\n  'Brass Knuckle SS BRK',\n  'Brass Knuckle Star BRK',\n  'Brigadoom BRK',\n  'Brigadoom Wide BRK',\n  'Bumped BRK',\n  'CLAW 1 BRK',\n  'CLAW 2 BRK',\n  'Candy Stripe BRK',\n  'Cantarell',\n  'Cantarell Bold',\n  'Cantarell Extra Bold',\n  'Cantarell Light',\n  'Cantarell Regular',\n  'Cantarell Thin',\n  'Chemical Reaction A BRK',\n  'Chemical Reaction B BRK',\n  'Chintzy CPU BRK',\n  'Chintzy CPU Shadow BRK',\n  'Chumbly BRK',\n  'Circulate BRK',\n  'Classic Trash 1 BRK',\n  'Classic Trash 2 BRK',\n  'Cleaved TTR BRK',\n  'Code Of Life BRK',\n  'Collective O BRK',\n  'Collective RO BRK',\n  'Collective RS BRK',\n  'Collective S BRK',\n  'Combustion I BRK',\n  'Combustion II BRK',\n  'Combustion Plain BRK',\n  'Combustion Tall BRK',\n  'Combustion Wide BRK',\n  'Comic Sans MS',\n  'Comic Sans MS Bold',\n  'Compliant Confuse 1o BRK',\n  'Compliant Confuse 1s BRK',\n  'Compliant Confuse 2o BRK',\n  'Compliant Confuse 2s BRK',\n  'Compliant Confuse 3o BRK',\n  'Compliant Confuse 3s BRK',\n  'Conduit 2 BRK',\n  'Conduit 2 Italics BRK',\n  'Conduit BRK',\n  'Corpulent Caps BRK',\n  'Corpulent Caps Shadow BRK',\n  'Courier New',\n  'Courier New Bold',\n  'Courier New Bold Italic',\n  'Courier New Italic',\n  'Crackdown O1 BRK',\n  'Crackdown O2 BRK',\n  'Crackdown R BRK',\n  'Crackdown R2 BRK',\n  'DB Layer 1 BRK',\n  'DB Layer 2 BRK',\n  'DB Layer 3 BRK',\n  'DB Layer 4 BRK',\n  'Dark Side BRK',\n  'Dash Dot BRK',\n  'Dastardly BRK',\n  'Decrepit BRK',\n  'DejaVu Sans',\n  'DejaVu Sans Bold',\n  'DejaVu Sans Mono',\n  'DejaVu Sans Mono Bold',\n  'DejaVu Serif',\n  'DejaVu Serif Bold',\n  'Delphine',\n  'Dented BRK',\n  'Dephunked BRK',\n  'Detonate BRK',\n  'Dialog',\n  'Dialog.bold',\n  'Dialog.bolditalic',\n  'Dialog.italic',\n  'Dialog.plain',\n  'DialogInput',\n  'DialogInput.bold',\n  'DialogInput.bolditalic',\n  'DialogInput.italic',\n  'DialogInput.plain',\n  'Discordance BRK',\n  'Double Bogey BRK',\n  'Draggle BRK',\n  'Draggle over kerned BRK',\n  'Dynamic BRK',\n  'Dyphusion BRK',\n  'Dystorque BRK',\n  'Ecliptic BRK',\n  'Edit Undo BRK',\n  'Edit Undo Dot BRK',\n  'Edit Undo Line BRK',\n  'Elsewhere 2 BRK',\n  'Elsewhere BRK',\n  'Embossing Tape 1 BRK',\n  'Embossing Tape 2 BRK',\n  'Embossing Tape 3 BRK',\n  'Encapsulate BRK',\n  'Encapsulate Plain BRK',\n  'Entangled BRK',\n  'Entangled Layer A BRK',\n  'Entangled Layer B BRK',\n  'Entangled Plain BRK',\n  'Enthuse BRK',\n  'Enthuse Solid BRK',\n  'Euphoric 3D BRK',\n  'Euphoric BRK',\n  'Exaggerate BRK',\n  'Extraction BRK',\n  'False Positive BRK',\n  'False Positive Round BRK',\n  'Fascii BRK',\n  'Fascii Cross BRK',\n  'Fascii Scraggly BRK',\n  'Fascii Smudge BRK',\n  'Fascii Twigs BRK',\n  'Fatboy Slim BLTC 2 BRK',\n  'Fatboy Slim BLTC BRK',\n  'Faux Snow BRK',\n  'Fidgety BRK',\n  'Flipside BRK',\n  'Forcible BRK',\n  'Foreshadow BRK',\n  'Foreshadow OL BRK',\n  'Freak Turbulence BRK',\n  'Frizzed BRK',\n  'Fully Completely BRK',\n  'Galapogos BRK',\n  'Galvanize BRK',\n  'Gaposis Outline BRK',\n  'Gaposis Solid BRK',\n  'Gasping BRK',\n  'Gather BRK',\n  'Gather Gapped BRK',\n  'Georgia',\n  'Georgia Bold',\n  'Georgia Bold Italic',\n  'Georgia Italic',\n  'Gesture BRK',\n  'Gesture Slant BRK',\n  'Gesture Thin BRK',\n  'Gesture Thin Slant BRK',\n  'Goose Bumps BRK',\n  'Goose Bumps II BRK',\n  'Granular BRK',\n  'Grapple BRK',\n  'Graveyard BRK',\n  'Gravitate BRK',\n  'Gravitate Segments BRK',\n  'Graze BRK',\n  'Great Heights BRK',\n  'Grotesque BRK',\n  'Grudge 2 BRK',\n  'Grudge BRK',\n  'Gyneric 3D BRK',\n  'Gyneric BRK',\n  'Gyrose BRK',\n  'Gyrose Shift BRK',\n  'Gyrose Squeeze BRK',\n  'Hack &amp; Slash BRK',\n  'Hairball BRK',\n  'Hand Me Down O BRK',\n  'Hand Me Down S BRK',\n  'Hassle BRK',\n  'Head-Ding Maker BRK',\n  'Hearts BRK',\n  'Heavy Bevel BRK',\n  'Hillock BRK',\n  'Homespun TT BRK',\n  'Hyde BRK',\n  'Hyperion Sunset BRK',\n  'Impact',\n  'Impossibilium BRK',\n  'Inertia BRK',\n  'Inevitable BRK',\n  'Ink Swipes BRK',\n  'Ink Tank BRK',\n  'Intersect BRK',\n  'Intersect C BRK',\n  'Intersect O BRK',\n  'Irritate BRK',\n  'It Lives In The Swamp BRK',\n  'Jagged BRK',\n  'Janken BRK',\n  'Jargon BRK',\n  'Jasper BRK',\n  'Jasper Solid BRK',\n  'Jawbreaker BRK',\n  'Jawbreaker Hard BRK',\n  'Jawbreaker OL1 BRK',\n  'Jawbreaker OL2 BRK',\n  'Jekyll BRK',\n  'Jeopardize BRK',\n  'Jeopardize Thick BRK',\n  'Johnny Mac Scrawl BRK',\n  'Jolt Of Caffeine BRK',\n  'Jupiter Crash BRK',\n  'Kaliber Round BRK',\n  'Kaliber Solid BRK',\n  'Kaliber Xtreme BRK',\n  'Katalyst active BRK',\n  'Katalyst inactive BRK',\n  'Key Ridge BRK',\n  'Key Ridge alt BRK',\n  'Kickflip BRK',\n  'Kinkaid BRK',\n  'Kirby No Kira Kizzu BRK',\n  'Knot BRK',\n  'Konector BRK',\n  'Konector Eerie BRK',\n  'Konector O1 BRK',\n  'Konector O2 BRK',\n  'Kurvature BRK',\n  'LM Mono 10',\n  'LM Mono 12',\n  'LM Mono 8',\n  'LM Mono 9',\n  'LM Mono Caps 10',\n  'LM Mono Light 10',\n  'LM Mono Light Cond 10',\n  'LM Mono Prop 10',\n  'LM Mono Prop Light 10',\n  'LM Mono Slanted 10',\n  'LM Roman 10',\n  'LM Roman 12',\n  'LM Roman 17',\n  'LM Roman 5',\n  'LM Roman 6',\n  'LM Roman 7',\n  'LM Roman 8',\n  'LM Roman 9',\n  'LM Roman Caps 10',\n  'LM Roman Demi 10',\n  'LM Roman Dunhill 10',\n  'LM Roman Slanted 10',\n  'LM Roman Slanted 12',\n  'LM Roman Slanted 17',\n  'LM Roman Slanted 8',\n  'LM Roman Slanted 9',\n  'LM Roman Unslanted 10',\n  'LM Sans 10',\n  'LM Sans 12',\n  'LM Sans 17',\n  'LM Sans 8',\n  'LM Sans 9',\n  'LM Sans Demi Cond 10',\n  'LM Sans Quot 8',\n  'LMMono10-Italic',\n  'LMMono10-Regular',\n  'LMMono12-Regular',\n  'LMMono8-Regular',\n  'LMMono9-Regular',\n  'LMMonoCaps10-Oblique',\n  'LMMonoCaps10-Regular',\n  'LMMonoLt10-Bold',\n  'LMMonoLt10-BoldOblique',\n  'LMMonoLt10-Oblique',\n  'LMMonoLt10-Regular',\n  'LMMonoLtCond10-Oblique',\n  'LMMonoLtCond10-Regular',\n  'LMMonoProp10-Oblique',\n  'LMMonoProp10-Regular',\n  'LMMonoPropLt10-Bold',\n  'LMMonoPropLt10-BoldOblique',\n  'LMMonoPropLt10-Oblique',\n  'LMMonoPropLt10-Regular',\n  'LMMonoSlant10-Regular',\n  'LMRoman10-Bold',\n  'LMRoman10-BoldItalic',\n  'LMRoman10-Italic',\n  'LMRoman10-Regular',\n  'LMRoman12-Bold',\n  'LMRoman12-Italic',\n  'LMRoman12-Regular',\n  'LMRoman17-Regular',\n  'LMRoman5-Bold',\n  'LMRoman5-Regular',\n  'LMRoman6-Bold',\n  'LMRoman6-Regular',\n  'LMRoman7-Bold',\n  'LMRoman7-Italic',\n  'LMRoman7-Regular',\n  'LMRoman8-Bold',\n  'LMRoman8-Italic',\n  'LMRoman8-Regular',\n  'LMRoman9-Bold',\n  'LMRoman9-Italic',\n  'LMRoman9-Regular',\n  'LMRomanCaps10-Oblique',\n  'LMRomanCaps10-Regular',\n  'LMRomanDemi10-Oblique',\n  'LMRomanDemi10-Regular',\n  'LMRomanDunh10-Oblique',\n  'LMRomanDunh10-Regular',\n  'LMRomanSlant10-Bold',\n  'LMRomanSlant10-Regular',\n  'LMRomanSlant12-Regular',\n  'LMRomanSlant17-Regular',\n  'LMRomanSlant8-Regular',\n  'LMRomanSlant9-Regular',\n  'LMRomanUnsl10-Regular',\n  'LMSans10-Bold',\n  'LMSans10-BoldOblique',\n  'LMSans10-Oblique',\n  'LMSans10-Regular',\n  'LMSans12-Oblique',\n  'LMSans12-Regular',\n  'LMSans17-Oblique',\n  'LMSans17-Regular',\n  'LMSans8-Oblique',\n  'LMSans8-Regular',\n  'LMSans9-Oblique',\n  'LMSans9-Regular',\n  'LMSansDemiCond10-Oblique',\n  'LMSansDemiCond10-Regular',\n  'LMSansQuot8-Bold',\n  'LMSansQuot8-BoldOblique',\n  'LMSansQuot8-Oblique',\n  'LMSansQuot8-Regular',\n  'LYNX BRK',\n  'Lakeshore BRK',\n  'Lamebrain BRK',\n  'Larkspur BRK',\n  'Latin Modern Math',\n  'LatinModernMath-Regular',\n  'Lethargic BRK',\n  'Licorice Strings BRK',\n  'Lights Out BRK',\n  'Line Dings BRK',\n  'Loopy BRK',\n  'Lowdown BRK',\n  'Lucid Type A BRK',\n  'Lucid Type A Outline BRK',\n  'Lucid Type B BRK',\n  'Lucid Type B Outline BRK',\n  'Lyneous BRK',\n  'Lyneous Linear BRK',\n  'Macropsia BRK',\n  \"Mad's Scrawl BRK\",\n  'Mincer BRK',\n  'Mini Kaliber O TT BRK',\n  'Mini Kaliber S TT BRK',\n  'Mishmash 4x4i BRK',\n  'Mishmash 4x4o BRK',\n  'Mishmash ALT1 BRK',\n  'Mishmash ALT2 BRK',\n  'Mishmash BRK',\n  'Mishmash Fuse BRK',\n  'Mobilize BRK',\n  'Monkey Phonics BRK',\n  'Monospaced',\n  'Monospaced.bold',\n  'Monospaced.bolditalic',\n  'Monospaced.italic',\n  'Monospaced.plain',\n  'Moronic Misfire BRK',\n  'Mysterons BRK',\n  'Nanosecond Thick BRK',\n  'Nanosecond Thin BRK',\n  'Nanosecond Wide BRK',\n  'Naughts BRK',\n  'Neural BRK',\n  'Neural Outline BRK',\n  'Nominal BRK',\n  'Nostalgia BRK',\n  'Not Quite Right BRK',\n  'Nucleus BRK',\n  'Numskull BRK',\n  'Nymonak BRK',\n  'Obloquy Outline BRK',\n  'Obloquy Solid BRK',\n  'Obstacle BRK',\n  'Obstacle Lines BRK',\n  'Off Kilter L BRK',\n  'Off Kilter R BRK',\n  'Opiated BRK',\n  'Orbicular BRK',\n  'Outer Sider BRK',\n  'Overhead BRK',\n  'Perfect Dark BRK',\n  'Persuasion BRK',\n  'Phorfeit Regular BRK',\n  'Phorfeit Slant BRK',\n  'Pincers BRK',\n  'Pindown BRK',\n  'Pindown Plain BRK',\n  'Pindown X BRK',\n  'Pindown X Plain BRK',\n  'Pixel Krud BRK',\n  'Plasma Drip BRK',\n  'Plasma Drip Empty BRK',\n  'Pneumatics BRK',\n  'Pneumatics Tall BRK',\n  'Pneumatics Wide BRK',\n  'Powderworks BRK',\n  'Pseudo BRK',\n  'Qbicle 1 BRK',\n  'Qbicle 2 BRK',\n  'Qbicle 3 BRK',\n  'Qbicle 4 BRK',\n  'Qlumpy BRK',\n  'Qlumpy Shadow BRK',\n  'Quacksalver BRK',\n  'Quadratic BRK',\n  'Quadratic Cal BRK',\n  'Quandary BRK',\n  'Quantum Flat BRK',\n  'Quantum Flat Hollow BRK',\n  'Quantum Round BRK',\n  'Quantum Round Hollow BRK',\n  'Quantum Taper BRK',\n  'Quarantine BRK',\n  'Quarterly Thick BRK',\n  'Quarterly Thin BRK',\n  'Queasy BRK',\n  'Queasy Outline BRK',\n  'Quill Experimental O BRK',\n  'Quill Experimental S BRK',\n  'Rambling BRK',\n  'Ravaged By Years BRK',\n  'Ravenous Caterpillar BRK',\n  'Raydiate BRK',\n  'Reason BRK',\n  'Reason Shadow BRK',\n  'Redundant BRK',\n  'Regenerate BRK',\n  'Registry BRK',\n  'Rehearsal Curve BRK',\n  'Rehearsal Offset BRK',\n  'Rehearsal Point BRK',\n  'Relapse BRK',\n  'Revert BRK',\n  'Revert Round BRK',\n  'Rotund BRK',\n  'Rotund Outline BRK',\n  'Rough Day BRK',\n  'Ryuker BRK',\n  'SansSerif',\n  'SansSerif.bold',\n  'SansSerif.bolditalic',\n  'SansSerif.italic',\n  'SansSerif.plain',\n  'Sarcastic BRK',\n  'Saunder BRK',\n  'Scalelines BRK',\n  'Scalelines Maze BRK',\n  'Sequence BRK',\n  'Serif',\n  'Serif.bold',\n  'Serif.bolditalic',\n  'Serif.italic',\n  'Serif.plain',\n  'Setback TT BRK',\n  'Sideways BRK',\n  'Simpleton BRK',\n  'Skull Capz BRK',\n  'Slender BRK',\n  'Slender Mini BRK',\n  'Slender Stubby BRK',\n  'Slender Wide BRK',\n  'Snailets BRK',\n  'Spacious BRK',\n  'Spacious Outline BRK',\n  'Spastic BRK',\n  'Spheroids BRK',\n  'Spheroids X BRK',\n  'Splatz BRK',\n  'Square Route BRK',\n  'Stagnation BRK',\n  'Steve',\n  'SteveHand',\n  'Stranded BRK',\n  'Supra Genius Curves BRK',\n  'Supra Genius Lines BRK',\n  'Swirled BRK',\n  'Symmetry BRK',\n  'Syndrome BRK',\n  'Synthetic BRK',\n  'Syracuse BRK',\n  'TRAGIC BRK',\n  'Tearful BRK',\n  'Technique BRK',\n  'Technique OL BRK',\n  'Telephasic BRK',\n  'Tetricide BRK',\n  'Thwart BRK',\n  'Times New Roman',\n  'Times New Roman Bold',\n  'Times New Roman Bold Italic',\n  'Times New Roman Italic',\n  'Tonik BRK',\n  'Trebuchet MS',\n  'Trebuchet MS Bold',\n  'Trebuchet MS Bold Italic',\n  'Trebuchet MS Italic',\n  'Turmoil BRK',\n  'Typesource Extol O BRK',\n  'Typesource Extol S BRK',\n  'UNITED BRK',\n  'Ubiquity BRK',\n  'Unanimous BRK',\n  'Unanimous Inverted BRK',\n  'Underscore 2 BRK',\n  'Underscore BRK',\n  'Underwhelmed BRK',\n  'Underwhelmed Outline BRK',\n  'Unexplored Galaxies BRK',\n  'Unexplored Galaxies O BRK',\n  'Unexplored Galaxies W BRK',\n  'Unexplored Galaxies WO BRK',\n  'Unlearned 2 BRK',\n  'Unlearned BRK',\n  'Unresponsive BRK',\n  'Upheaval TT BRK',\n  'Upraise BRK',\n  'Vacant Capz BRK',\n  'Vanished BRK',\n  'Vantage BRK',\n  'Variance BRK',\n  'Verdana',\n  'Verdana Bold',\n  'Verdana Bold Italic',\n  'Verdana Italic',\n  'Vertigo 2 BRK',\n  'Vertigo BRK',\n  'Vertigo Upright 2 BRK',\n  'Vertigo Upright BRK',\n  'Vigilance BRK',\n  'Vindictive BRK',\n  'Visitor TT1 BRK',\n  'Visitor TT2 BRK',\n  'Volatile 1 BRK',\n  'Volatile 2 BRK',\n  'Wager BRK',\n  'Wager Lost BRK',\n  'Wager Won BRK',\n  'Wayward BRK',\n  'Wayward Shadow BRK',\n  'Weathered BRK',\n  'Weathered Solid BRK',\n  'Weaver BRK',\n  'Webdings',\n  'Whatever BRK',\n  'Whippersnapper BRK',\n  'Wiggly Squiggly BRK',\n  'Wincing BRK',\n  'Withstand BRK',\n  'Wobbly BRK',\n  'Wyvern Wings BRK',\n  'Wyvern Wings Wyde BRK',\n  'Xerox Malfunction BRK',\n  'Xhume BRK',\n  'Xipital BRK',\n  'Xmas Lights BRK',\n  'Xtrusion BRK',\n  'Yearend BRK',\n  'Yesterday BRK',\n  'Yielding BRK',\n  'Yonder BRK',\n  \"Yoshi's Story game text BRK\",\n  'Your Complex BRK',\n  'Your Complex I BRK',\n  'Your Complex O BRK',\n  'Zelda DX TT BRK',\n  'Zenith BRK',\n  'Zephyrean BRK',\n  'Zephyrean Gust BRK',\n  'Zero Velocity BRK',\n  'Zirconia BRK',\n  'Zirconia Cubic BRK',\n  'Zoetrope BRK',\n  'Zoidal BRK',\n  'Zurklez Outline BRK',\n  'Zurklez Solid BRK',\n  'genotype H BRK',\n  'genotype RH BRK',\n  'genotype RS BRK',\n  'genotype S BRK',\n  'techno overload BRK',\n  'waver BRK',\n  '\u00c6 Systematic TT BRK',\n  '\u00c6nigma Scrawl 4 BRK']}</pre> In\u00a0[4]: Copied! <pre>xml = geoserver.get_fonts(format=\"xml\")\nprint(xml)\n</pre> xml = geoserver.get_fonts(format=\"xml\") print(xml) <pre>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;root&gt;\n&lt;fonts&gt;\n&lt;entry&gt;10.15 Saturday Night BRK&lt;/entry&gt;\n&lt;entry&gt;10.15 Saturday Night R BRK&lt;/entry&gt;\n&lt;entry&gt;18 Holes BRK&lt;/entry&gt;\n&lt;entry&gt;36 days ago BRK&lt;/entry&gt;\n&lt;entry&gt;36 days ago Thick BRK&lt;/entry&gt;\n&lt;entry&gt;3D LET BRK&lt;/entry&gt;\n&lt;entry&gt;8-bit Limit BRK&lt;/entry&gt;\n&lt;entry&gt;8-bit Limit O BRK&lt;/entry&gt;\n&lt;entry&gt;8-bit Limit R BRK&lt;/entry&gt;\n&lt;entry&gt;8-bit Limit RO BRK&lt;/entry&gt;\n&lt;entry&gt;90 Stars BRK&lt;/entry&gt;\n&lt;entry&gt;Acid Reflux BRK&lt;/entry&gt;\n&lt;entry&gt;Acknowledge TT BRK&lt;/entry&gt;\n&lt;entry&gt;Aftermath BRK&lt;/entry&gt;\n&lt;entry&gt;Alpha Beta BRK&lt;/entry&gt;\n&lt;entry&gt;Amalgamate BRK&lt;/entry&gt;\n&lt;entry&gt;Amalgamate O BRK&lt;/entry&gt;\n&lt;entry&gt;Amplitude BRK&lt;/entry&gt;\n&lt;entry&gt;Andale Mono&lt;/entry&gt;\n&lt;entry&gt;Arial&lt;/entry&gt;\n&lt;entry&gt;Arial Black&lt;/entry&gt;\n&lt;entry&gt;Arial Bold&lt;/entry&gt;\n&lt;entry&gt;Arial Bold Italic&lt;/entry&gt;\n&lt;entry&gt;Arial Italic&lt;/entry&gt;\n&lt;entry&gt;Arthritis BRK&lt;/entry&gt;\n&lt;entry&gt;Aspartame BRK&lt;/entry&gt;\n&lt;entry&gt;Ataxia BRK&lt;/entry&gt;\n&lt;entry&gt;Ataxia Outline BRK&lt;/entry&gt;\n&lt;entry&gt;Automatica BRK&lt;/entry&gt;\n&lt;entry&gt;Backlash BRK&lt;/entry&gt;\n&lt;entry&gt;Bandwidth BRK&lt;/entry&gt;\n&lt;entry&gt;Bandwidth Bandless BRK&lt;/entry&gt;\n&lt;entry&gt;Bandwidth Bandmess BRK&lt;/entry&gt;\n&lt;entry&gt;Bend 2 Squares BRK&lt;/entry&gt;\n&lt;entry&gt;Bend 2 Squares OL1 BRK&lt;/entry&gt;\n&lt;entry&gt;Bend 2 Squares OL2 BRK&lt;/entry&gt;\n&lt;entry&gt;Bendable BRK&lt;/entry&gt;\n&lt;entry&gt;Bewilder BRK&lt;/entry&gt;\n&lt;entry&gt;Bewilder Thick BRK&lt;/entry&gt;\n&lt;entry&gt;Binary 01s BRK&lt;/entry&gt;\n&lt;entry&gt;Binary BRK&lt;/entry&gt;\n&lt;entry&gt;Binary CHR BRK&lt;/entry&gt;\n&lt;entry&gt;Binary X 01s BRK&lt;/entry&gt;\n&lt;entry&gt;Binary X BRK&lt;/entry&gt;\n&lt;entry&gt;Binary X CHR BRK&lt;/entry&gt;\n&lt;entry&gt;Bit Blocks TTF BRK&lt;/entry&gt;\n&lt;entry&gt;Bitstream Vera Sans&lt;/entry&gt;\n&lt;entry&gt;Bitstream Vera Sans Bold&lt;/entry&gt;\n&lt;entry&gt;Bitstream Vera Sans Bold Oblique&lt;/entry&gt;\n&lt;entry&gt;Bitstream Vera Sans Mono&lt;/entry&gt;\n&lt;entry&gt;Bitstream Vera Sans Mono Bold&lt;/entry&gt;\n&lt;entry&gt;Bitstream Vera Sans Mono Bold Oblique&lt;/entry&gt;\n&lt;entry&gt;Bitstream Vera Sans Mono Oblique&lt;/entry&gt;\n&lt;entry&gt;Bitstream Vera Sans Oblique&lt;/entry&gt;\n&lt;entry&gt;Bitstream Vera Serif&lt;/entry&gt;\n&lt;entry&gt;Bitstream Vera Serif Bold&lt;/entry&gt;\n&lt;entry&gt;Blackoninaut BRK&lt;/entry&gt;\n&lt;entry&gt;Blackoninaut Bold BRK&lt;/entry&gt;\n&lt;entry&gt;Blackoninaut Redux BRK&lt;/entry&gt;\n&lt;entry&gt;Bleak Segments BRK&lt;/entry&gt;\n&lt;entry&gt;Block Tilt BRK&lt;/entry&gt;\n&lt;entry&gt;Blox BRK&lt;/entry&gt;\n&lt;entry&gt;Bobcaygeon BRK&lt;/entry&gt;\n&lt;entry&gt;Bobcaygeon Plain BRK&lt;/entry&gt;\n&lt;entry&gt;Bocuma Angle BRK&lt;/entry&gt;\n&lt;entry&gt;Bocuma Angle Dent BRK&lt;/entry&gt;\n&lt;entry&gt;Bocuma BRK&lt;/entry&gt;\n&lt;entry&gt;Bocuma Batty BRK&lt;/entry&gt;\n&lt;entry&gt;Bocuma Dent BRK&lt;/entry&gt;\n&lt;entry&gt;Brass Knuckle BRK&lt;/entry&gt;\n&lt;entry&gt;Brass Knuckle SS BRK&lt;/entry&gt;\n&lt;entry&gt;Brass Knuckle Star BRK&lt;/entry&gt;\n&lt;entry&gt;Brigadoom BRK&lt;/entry&gt;\n&lt;entry&gt;Brigadoom Wide BRK&lt;/entry&gt;\n&lt;entry&gt;Bumped BRK&lt;/entry&gt;\n&lt;entry&gt;CLAW 1 BRK&lt;/entry&gt;\n&lt;entry&gt;CLAW 2 BRK&lt;/entry&gt;\n&lt;entry&gt;Candy Stripe BRK&lt;/entry&gt;\n&lt;entry&gt;Cantarell&lt;/entry&gt;\n&lt;entry&gt;Cantarell Bold&lt;/entry&gt;\n&lt;entry&gt;Cantarell Extra Bold&lt;/entry&gt;\n&lt;entry&gt;Cantarell Light&lt;/entry&gt;\n&lt;entry&gt;Cantarell Regular&lt;/entry&gt;\n&lt;entry&gt;Cantarell Thin&lt;/entry&gt;\n&lt;entry&gt;Chemical Reaction A BRK&lt;/entry&gt;\n&lt;entry&gt;Chemical Reaction B BRK&lt;/entry&gt;\n&lt;entry&gt;Chintzy CPU BRK&lt;/entry&gt;\n&lt;entry&gt;Chintzy CPU Shadow BRK&lt;/entry&gt;\n&lt;entry&gt;Chumbly BRK&lt;/entry&gt;\n&lt;entry&gt;Circulate BRK&lt;/entry&gt;\n&lt;entry&gt;Classic Trash 1 BRK&lt;/entry&gt;\n&lt;entry&gt;Classic Trash 2 BRK&lt;/entry&gt;\n&lt;entry&gt;Cleaved TTR BRK&lt;/entry&gt;\n&lt;entry&gt;Code Of Life BRK&lt;/entry&gt;\n&lt;entry&gt;Collective O BRK&lt;/entry&gt;\n&lt;entry&gt;Collective RO BRK&lt;/entry&gt;\n&lt;entry&gt;Collective RS BRK&lt;/entry&gt;\n&lt;entry&gt;Collective S BRK&lt;/entry&gt;\n&lt;entry&gt;Combustion I BRK&lt;/entry&gt;\n&lt;entry&gt;Combustion II BRK&lt;/entry&gt;\n&lt;entry&gt;Combustion Plain BRK&lt;/entry&gt;\n&lt;entry&gt;Combustion Tall BRK&lt;/entry&gt;\n&lt;entry&gt;Combustion Wide BRK&lt;/entry&gt;\n&lt;entry&gt;Comic Sans MS&lt;/entry&gt;\n&lt;entry&gt;Comic Sans MS Bold&lt;/entry&gt;\n&lt;entry&gt;Compliant Confuse 1o BRK&lt;/entry&gt;\n&lt;entry&gt;Compliant Confuse 1s BRK&lt;/entry&gt;\n&lt;entry&gt;Compliant Confuse 2o BRK&lt;/entry&gt;\n&lt;entry&gt;Compliant Confuse 2s BRK&lt;/entry&gt;\n&lt;entry&gt;Compliant Confuse 3o BRK&lt;/entry&gt;\n&lt;entry&gt;Compliant Confuse 3s BRK&lt;/entry&gt;\n&lt;entry&gt;Conduit 2 BRK&lt;/entry&gt;\n&lt;entry&gt;Conduit 2 Italics BRK&lt;/entry&gt;\n&lt;entry&gt;Conduit BRK&lt;/entry&gt;\n&lt;entry&gt;Corpulent Caps BRK&lt;/entry&gt;\n&lt;entry&gt;Corpulent Caps Shadow BRK&lt;/entry&gt;\n&lt;entry&gt;Courier New&lt;/entry&gt;\n&lt;entry&gt;Courier New Bold&lt;/entry&gt;\n&lt;entry&gt;Courier New Bold Italic&lt;/entry&gt;\n&lt;entry&gt;Courier New Italic&lt;/entry&gt;\n&lt;entry&gt;Crackdown O1 BRK&lt;/entry&gt;\n&lt;entry&gt;Crackdown O2 BRK&lt;/entry&gt;\n&lt;entry&gt;Crackdown R BRK&lt;/entry&gt;\n&lt;entry&gt;Crackdown R2 BRK&lt;/entry&gt;\n&lt;entry&gt;DB Layer 1 BRK&lt;/entry&gt;\n&lt;entry&gt;DB Layer 2 BRK&lt;/entry&gt;\n&lt;entry&gt;DB Layer 3 BRK&lt;/entry&gt;\n&lt;entry&gt;DB Layer 4 BRK&lt;/entry&gt;\n&lt;entry&gt;Dark Side BRK&lt;/entry&gt;\n&lt;entry&gt;Dash Dot BRK&lt;/entry&gt;\n&lt;entry&gt;Dastardly BRK&lt;/entry&gt;\n&lt;entry&gt;Decrepit BRK&lt;/entry&gt;\n&lt;entry&gt;DejaVu Sans&lt;/entry&gt;\n&lt;entry&gt;DejaVu Sans Bold&lt;/entry&gt;\n&lt;entry&gt;DejaVu Sans Mono&lt;/entry&gt;\n&lt;entry&gt;DejaVu Sans Mono Bold&lt;/entry&gt;\n&lt;entry&gt;DejaVu Serif&lt;/entry&gt;\n&lt;entry&gt;DejaVu Serif Bold&lt;/entry&gt;\n&lt;entry&gt;Delphine&lt;/entry&gt;\n&lt;entry&gt;Dented BRK&lt;/entry&gt;\n&lt;entry&gt;Dephunked BRK&lt;/entry&gt;\n&lt;entry&gt;Detonate BRK&lt;/entry&gt;\n&lt;entry&gt;Dialog&lt;/entry&gt;\n&lt;entry&gt;Dialog.bold&lt;/entry&gt;\n&lt;entry&gt;Dialog.bolditalic&lt;/entry&gt;\n&lt;entry&gt;Dialog.italic&lt;/entry&gt;\n&lt;entry&gt;Dialog.plain&lt;/entry&gt;\n&lt;entry&gt;DialogInput&lt;/entry&gt;\n&lt;entry&gt;DialogInput.bold&lt;/entry&gt;\n&lt;entry&gt;DialogInput.bolditalic&lt;/entry&gt;\n&lt;entry&gt;DialogInput.italic&lt;/entry&gt;\n&lt;entry&gt;DialogInput.plain&lt;/entry&gt;\n&lt;entry&gt;Discordance BRK&lt;/entry&gt;\n&lt;entry&gt;Double Bogey BRK&lt;/entry&gt;\n&lt;entry&gt;Draggle BRK&lt;/entry&gt;\n&lt;entry&gt;Draggle over kerned BRK&lt;/entry&gt;\n&lt;entry&gt;Dynamic BRK&lt;/entry&gt;\n&lt;entry&gt;Dyphusion BRK&lt;/entry&gt;\n&lt;entry&gt;Dystorque BRK&lt;/entry&gt;\n&lt;entry&gt;Ecliptic BRK&lt;/entry&gt;\n&lt;entry&gt;Edit Undo BRK&lt;/entry&gt;\n&lt;entry&gt;Edit Undo Dot BRK&lt;/entry&gt;\n&lt;entry&gt;Edit Undo Line BRK&lt;/entry&gt;\n&lt;entry&gt;Elsewhere 2 BRK&lt;/entry&gt;\n&lt;entry&gt;Elsewhere BRK&lt;/entry&gt;\n&lt;entry&gt;Embossing Tape 1 BRK&lt;/entry&gt;\n&lt;entry&gt;Embossing Tape 2 BRK&lt;/entry&gt;\n&lt;entry&gt;Embossing Tape 3 BRK&lt;/entry&gt;\n&lt;entry&gt;Encapsulate BRK&lt;/entry&gt;\n&lt;entry&gt;Encapsulate Plain BRK&lt;/entry&gt;\n&lt;entry&gt;Entangled BRK&lt;/entry&gt;\n&lt;entry&gt;Entangled Layer A BRK&lt;/entry&gt;\n&lt;entry&gt;Entangled Layer B BRK&lt;/entry&gt;\n&lt;entry&gt;Entangled Plain BRK&lt;/entry&gt;\n&lt;entry&gt;Enthuse BRK&lt;/entry&gt;\n&lt;entry&gt;Enthuse Solid BRK&lt;/entry&gt;\n&lt;entry&gt;Euphoric 3D BRK&lt;/entry&gt;\n&lt;entry&gt;Euphoric BRK&lt;/entry&gt;\n&lt;entry&gt;Exaggerate BRK&lt;/entry&gt;\n&lt;entry&gt;Extraction BRK&lt;/entry&gt;\n&lt;entry&gt;False Positive BRK&lt;/entry&gt;\n&lt;entry&gt;False Positive Round BRK&lt;/entry&gt;\n&lt;entry&gt;Fascii BRK&lt;/entry&gt;\n&lt;entry&gt;Fascii Cross BRK&lt;/entry&gt;\n&lt;entry&gt;Fascii Scraggly BRK&lt;/entry&gt;\n&lt;entry&gt;Fascii Smudge BRK&lt;/entry&gt;\n&lt;entry&gt;Fascii Twigs BRK&lt;/entry&gt;\n&lt;entry&gt;Fatboy Slim BLTC 2 BRK&lt;/entry&gt;\n&lt;entry&gt;Fatboy Slim BLTC BRK&lt;/entry&gt;\n&lt;entry&gt;Faux Snow BRK&lt;/entry&gt;\n&lt;entry&gt;Fidgety BRK&lt;/entry&gt;\n&lt;entry&gt;Flipside BRK&lt;/entry&gt;\n&lt;entry&gt;Forcible BRK&lt;/entry&gt;\n&lt;entry&gt;Foreshadow BRK&lt;/entry&gt;\n&lt;entry&gt;Foreshadow OL BRK&lt;/entry&gt;\n&lt;entry&gt;Freak Turbulence BRK&lt;/entry&gt;\n&lt;entry&gt;Frizzed BRK&lt;/entry&gt;\n&lt;entry&gt;Fully Completely BRK&lt;/entry&gt;\n&lt;entry&gt;Galapogos BRK&lt;/entry&gt;\n&lt;entry&gt;Galvanize BRK&lt;/entry&gt;\n&lt;entry&gt;Gaposis Outline BRK&lt;/entry&gt;\n&lt;entry&gt;Gaposis Solid BRK&lt;/entry&gt;\n&lt;entry&gt;Gasping BRK&lt;/entry&gt;\n&lt;entry&gt;Gather BRK&lt;/entry&gt;\n&lt;entry&gt;Gather Gapped BRK&lt;/entry&gt;\n&lt;entry&gt;Georgia&lt;/entry&gt;\n&lt;entry&gt;Georgia Bold&lt;/entry&gt;\n&lt;entry&gt;Georgia Bold Italic&lt;/entry&gt;\n&lt;entry&gt;Georgia Italic&lt;/entry&gt;\n&lt;entry&gt;Gesture BRK&lt;/entry&gt;\n&lt;entry&gt;Gesture Slant BRK&lt;/entry&gt;\n&lt;entry&gt;Gesture Thin BRK&lt;/entry&gt;\n&lt;entry&gt;Gesture Thin Slant BRK&lt;/entry&gt;\n&lt;entry&gt;Goose Bumps BRK&lt;/entry&gt;\n&lt;entry&gt;Goose Bumps II BRK&lt;/entry&gt;\n&lt;entry&gt;Granular BRK&lt;/entry&gt;\n&lt;entry&gt;Grapple BRK&lt;/entry&gt;\n&lt;entry&gt;Graveyard BRK&lt;/entry&gt;\n&lt;entry&gt;Gravitate BRK&lt;/entry&gt;\n&lt;entry&gt;Gravitate Segments BRK&lt;/entry&gt;\n&lt;entry&gt;Graze BRK&lt;/entry&gt;\n&lt;entry&gt;Great Heights BRK&lt;/entry&gt;\n&lt;entry&gt;Grotesque BRK&lt;/entry&gt;\n&lt;entry&gt;Grudge 2 BRK&lt;/entry&gt;\n&lt;entry&gt;Grudge BRK&lt;/entry&gt;\n&lt;entry&gt;Gyneric 3D BRK&lt;/entry&gt;\n&lt;entry&gt;Gyneric BRK&lt;/entry&gt;\n&lt;entry&gt;Gyrose BRK&lt;/entry&gt;\n&lt;entry&gt;Gyrose Shift BRK&lt;/entry&gt;\n&lt;entry&gt;Gyrose Squeeze BRK&lt;/entry&gt;\n&lt;entry&gt;Hack &amp;amp; Slash BRK&lt;/entry&gt;\n&lt;entry&gt;Hairball BRK&lt;/entry&gt;\n&lt;entry&gt;Hand Me Down O BRK&lt;/entry&gt;\n&lt;entry&gt;Hand Me Down S BRK&lt;/entry&gt;\n&lt;entry&gt;Hassle BRK&lt;/entry&gt;\n&lt;entry&gt;Head-Ding Maker BRK&lt;/entry&gt;\n&lt;entry&gt;Hearts BRK&lt;/entry&gt;\n&lt;entry&gt;Heavy Bevel BRK&lt;/entry&gt;\n&lt;entry&gt;Hillock BRK&lt;/entry&gt;\n&lt;entry&gt;Homespun TT BRK&lt;/entry&gt;\n&lt;entry&gt;Hyde BRK&lt;/entry&gt;\n&lt;entry&gt;Hyperion Sunset BRK&lt;/entry&gt;\n&lt;entry&gt;Impact&lt;/entry&gt;\n&lt;entry&gt;Impossibilium BRK&lt;/entry&gt;\n&lt;entry&gt;Inertia BRK&lt;/entry&gt;\n&lt;entry&gt;Inevitable BRK&lt;/entry&gt;\n&lt;entry&gt;Ink Swipes BRK&lt;/entry&gt;\n&lt;entry&gt;Ink Tank BRK&lt;/entry&gt;\n&lt;entry&gt;Intersect BRK&lt;/entry&gt;\n&lt;entry&gt;Intersect C BRK&lt;/entry&gt;\n&lt;entry&gt;Intersect O BRK&lt;/entry&gt;\n&lt;entry&gt;Irritate BRK&lt;/entry&gt;\n&lt;entry&gt;It Lives In The Swamp BRK&lt;/entry&gt;\n&lt;entry&gt;Jagged BRK&lt;/entry&gt;\n&lt;entry&gt;Janken BRK&lt;/entry&gt;\n&lt;entry&gt;Jargon BRK&lt;/entry&gt;\n&lt;entry&gt;Jasper BRK&lt;/entry&gt;\n&lt;entry&gt;Jasper Solid BRK&lt;/entry&gt;\n&lt;entry&gt;Jawbreaker BRK&lt;/entry&gt;\n&lt;entry&gt;Jawbreaker Hard BRK&lt;/entry&gt;\n&lt;entry&gt;Jawbreaker OL1 BRK&lt;/entry&gt;\n&lt;entry&gt;Jawbreaker OL2 BRK&lt;/entry&gt;\n&lt;entry&gt;Jekyll BRK&lt;/entry&gt;\n&lt;entry&gt;Jeopardize BRK&lt;/entry&gt;\n&lt;entry&gt;Jeopardize Thick BRK&lt;/entry&gt;\n&lt;entry&gt;Johnny Mac Scrawl BRK&lt;/entry&gt;\n&lt;entry&gt;Jolt Of Caffeine BRK&lt;/entry&gt;\n&lt;entry&gt;Jupiter Crash BRK&lt;/entry&gt;\n&lt;entry&gt;Kaliber Round BRK&lt;/entry&gt;\n&lt;entry&gt;Kaliber Solid BRK&lt;/entry&gt;\n&lt;entry&gt;Kaliber Xtreme BRK&lt;/entry&gt;\n&lt;entry&gt;Katalyst active BRK&lt;/entry&gt;\n&lt;entry&gt;Katalyst inactive BRK&lt;/entry&gt;\n&lt;entry&gt;Key Ridge BRK&lt;/entry&gt;\n&lt;entry&gt;Key Ridge alt BRK&lt;/entry&gt;\n&lt;entry&gt;Kickflip BRK&lt;/entry&gt;\n&lt;entry&gt;Kinkaid BRK&lt;/entry&gt;\n&lt;entry&gt;Kirby No Kira Kizzu BRK&lt;/entry&gt;\n&lt;entry&gt;Knot BRK&lt;/entry&gt;\n&lt;entry&gt;Konector BRK&lt;/entry&gt;\n&lt;entry&gt;Konector Eerie BRK&lt;/entry&gt;\n&lt;entry&gt;Konector O1 BRK&lt;/entry&gt;\n&lt;entry&gt;Konector O2 BRK&lt;/entry&gt;\n&lt;entry&gt;Kurvature BRK&lt;/entry&gt;\n&lt;entry&gt;LM Mono 10&lt;/entry&gt;\n&lt;entry&gt;LM Mono 12&lt;/entry&gt;\n&lt;entry&gt;LM Mono 8&lt;/entry&gt;\n&lt;entry&gt;LM Mono 9&lt;/entry&gt;\n&lt;entry&gt;LM Mono Caps 10&lt;/entry&gt;\n&lt;entry&gt;LM Mono Light 10&lt;/entry&gt;\n&lt;entry&gt;LM Mono Light Cond 10&lt;/entry&gt;\n&lt;entry&gt;LM Mono Prop 10&lt;/entry&gt;\n&lt;entry&gt;LM Mono Prop Light 10&lt;/entry&gt;\n&lt;entry&gt;LM Mono Slanted 10&lt;/entry&gt;\n&lt;entry&gt;LM Roman 10&lt;/entry&gt;\n&lt;entry&gt;LM Roman 12&lt;/entry&gt;\n&lt;entry&gt;LM Roman 17&lt;/entry&gt;\n&lt;entry&gt;LM Roman 5&lt;/entry&gt;\n&lt;entry&gt;LM Roman 6&lt;/entry&gt;\n&lt;entry&gt;LM Roman 7&lt;/entry&gt;\n&lt;entry&gt;LM Roman 8&lt;/entry&gt;\n&lt;entry&gt;LM Roman 9&lt;/entry&gt;\n&lt;entry&gt;LM Roman Caps 10&lt;/entry&gt;\n&lt;entry&gt;LM Roman Demi 10&lt;/entry&gt;\n&lt;entry&gt;LM Roman Dunhill 10&lt;/entry&gt;\n&lt;entry&gt;LM Roman Slanted 10&lt;/entry&gt;\n&lt;entry&gt;LM Roman Slanted 12&lt;/entry&gt;\n&lt;entry&gt;LM Roman Slanted 17&lt;/entry&gt;\n&lt;entry&gt;LM Roman Slanted 8&lt;/entry&gt;\n&lt;entry&gt;LM Roman Slanted 9&lt;/entry&gt;\n&lt;entry&gt;LM Roman Unslanted 10&lt;/entry&gt;\n&lt;entry&gt;LM Sans 10&lt;/entry&gt;\n&lt;entry&gt;LM Sans 12&lt;/entry&gt;\n&lt;entry&gt;LM Sans 17&lt;/entry&gt;\n&lt;entry&gt;LM Sans 8&lt;/entry&gt;\n&lt;entry&gt;LM Sans 9&lt;/entry&gt;\n&lt;entry&gt;LM Sans Demi Cond 10&lt;/entry&gt;\n&lt;entry&gt;LM Sans Quot 8&lt;/entry&gt;\n&lt;entry&gt;LMMono10-Italic&lt;/entry&gt;\n&lt;entry&gt;LMMono10-Regular&lt;/entry&gt;\n&lt;entry&gt;LMMono12-Regular&lt;/entry&gt;\n&lt;entry&gt;LMMono8-Regular&lt;/entry&gt;\n&lt;entry&gt;LMMono9-Regular&lt;/entry&gt;\n&lt;entry&gt;LMMonoCaps10-Oblique&lt;/entry&gt;\n&lt;entry&gt;LMMonoCaps10-Regular&lt;/entry&gt;\n&lt;entry&gt;LMMonoLt10-Bold&lt;/entry&gt;\n&lt;entry&gt;LMMonoLt10-BoldOblique&lt;/entry&gt;\n&lt;entry&gt;LMMonoLt10-Oblique&lt;/entry&gt;\n&lt;entry&gt;LMMonoLt10-Regular&lt;/entry&gt;\n&lt;entry&gt;LMMonoLtCond10-Oblique&lt;/entry&gt;\n&lt;entry&gt;LMMonoLtCond10-Regular&lt;/entry&gt;\n&lt;entry&gt;LMMonoProp10-Oblique&lt;/entry&gt;\n&lt;entry&gt;LMMonoProp10-Regular&lt;/entry&gt;\n&lt;entry&gt;LMMonoPropLt10-Bold&lt;/entry&gt;\n&lt;entry&gt;LMMonoPropLt10-BoldOblique&lt;/entry&gt;\n&lt;entry&gt;LMMonoPropLt10-Oblique&lt;/entry&gt;\n&lt;entry&gt;LMMonoPropLt10-Regular&lt;/entry&gt;\n&lt;entry&gt;LMMonoSlant10-Regular&lt;/entry&gt;\n&lt;entry&gt;LMRoman10-Bold&lt;/entry&gt;\n&lt;entry&gt;LMRoman10-BoldItalic&lt;/entry&gt;\n&lt;entry&gt;LMRoman10-Italic&lt;/entry&gt;\n&lt;entry&gt;LMRoman10-Regular&lt;/entry&gt;\n&lt;entry&gt;LMRoman12-Bold&lt;/entry&gt;\n&lt;entry&gt;LMRoman12-Italic&lt;/entry&gt;\n&lt;entry&gt;LMRoman12-Regular&lt;/entry&gt;\n&lt;entry&gt;LMRoman17-Regular&lt;/entry&gt;\n&lt;entry&gt;LMRoman5-Bold&lt;/entry&gt;\n&lt;entry&gt;LMRoman5-Regular&lt;/entry&gt;\n&lt;entry&gt;LMRoman6-Bold&lt;/entry&gt;\n&lt;entry&gt;LMRoman6-Regular&lt;/entry&gt;\n&lt;entry&gt;LMRoman7-Bold&lt;/entry&gt;\n&lt;entry&gt;LMRoman7-Italic&lt;/entry&gt;\n&lt;entry&gt;LMRoman7-Regular&lt;/entry&gt;\n&lt;entry&gt;LMRoman8-Bold&lt;/entry&gt;\n&lt;entry&gt;LMRoman8-Italic&lt;/entry&gt;\n&lt;entry&gt;LMRoman8-Regular&lt;/entry&gt;\n&lt;entry&gt;LMRoman9-Bold&lt;/entry&gt;\n&lt;entry&gt;LMRoman9-Italic&lt;/entry&gt;\n&lt;entry&gt;LMRoman9-Regular&lt;/entry&gt;\n&lt;entry&gt;LMRomanCaps10-Oblique&lt;/entry&gt;\n&lt;entry&gt;LMRomanCaps10-Regular&lt;/entry&gt;\n&lt;entry&gt;LMRomanDemi10-Oblique&lt;/entry&gt;\n&lt;entry&gt;LMRomanDemi10-Regular&lt;/entry&gt;\n&lt;entry&gt;LMRomanDunh10-Oblique&lt;/entry&gt;\n&lt;entry&gt;LMRomanDunh10-Regular&lt;/entry&gt;\n&lt;entry&gt;LMRomanSlant10-Bold&lt;/entry&gt;\n&lt;entry&gt;LMRomanSlant10-Regular&lt;/entry&gt;\n&lt;entry&gt;LMRomanSlant12-Regular&lt;/entry&gt;\n&lt;entry&gt;LMRomanSlant17-Regular&lt;/entry&gt;\n&lt;entry&gt;LMRomanSlant8-Regular&lt;/entry&gt;\n&lt;entry&gt;LMRomanSlant9-Regular&lt;/entry&gt;\n&lt;entry&gt;LMRomanUnsl10-Regular&lt;/entry&gt;\n&lt;entry&gt;LMSans10-Bold&lt;/entry&gt;\n&lt;entry&gt;LMSans10-BoldOblique&lt;/entry&gt;\n&lt;entry&gt;LMSans10-Oblique&lt;/entry&gt;\n&lt;entry&gt;LMSans10-Regular&lt;/entry&gt;\n&lt;entry&gt;LMSans12-Oblique&lt;/entry&gt;\n&lt;entry&gt;LMSans12-Regular&lt;/entry&gt;\n&lt;entry&gt;LMSans17-Oblique&lt;/entry&gt;\n&lt;entry&gt;LMSans17-Regular&lt;/entry&gt;\n&lt;entry&gt;LMSans8-Oblique&lt;/entry&gt;\n&lt;entry&gt;LMSans8-Regular&lt;/entry&gt;\n&lt;entry&gt;LMSans9-Oblique&lt;/entry&gt;\n&lt;entry&gt;LMSans9-Regular&lt;/entry&gt;\n&lt;entry&gt;LMSansDemiCond10-Oblique&lt;/entry&gt;\n&lt;entry&gt;LMSansDemiCond10-Regular&lt;/entry&gt;\n&lt;entry&gt;LMSansQuot8-Bold&lt;/entry&gt;\n&lt;entry&gt;LMSansQuot8-BoldOblique&lt;/entry&gt;\n&lt;entry&gt;LMSansQuot8-Oblique&lt;/entry&gt;\n&lt;entry&gt;LMSansQuot8-Regular&lt;/entry&gt;\n&lt;entry&gt;LYNX BRK&lt;/entry&gt;\n&lt;entry&gt;Lakeshore BRK&lt;/entry&gt;\n&lt;entry&gt;Lamebrain BRK&lt;/entry&gt;\n&lt;entry&gt;Larkspur BRK&lt;/entry&gt;\n&lt;entry&gt;Latin Modern Math&lt;/entry&gt;\n&lt;entry&gt;LatinModernMath-Regular&lt;/entry&gt;\n&lt;entry&gt;Lethargic BRK&lt;/entry&gt;\n&lt;entry&gt;Licorice Strings BRK&lt;/entry&gt;\n&lt;entry&gt;Lights Out BRK&lt;/entry&gt;\n&lt;entry&gt;Line Dings BRK&lt;/entry&gt;\n&lt;entry&gt;Loopy BRK&lt;/entry&gt;\n&lt;entry&gt;Lowdown BRK&lt;/entry&gt;\n&lt;entry&gt;Lucid Type A BRK&lt;/entry&gt;\n&lt;entry&gt;Lucid Type A Outline BRK&lt;/entry&gt;\n&lt;entry&gt;Lucid Type B BRK&lt;/entry&gt;\n&lt;entry&gt;Lucid Type B Outline BRK&lt;/entry&gt;\n&lt;entry&gt;Lyneous BRK&lt;/entry&gt;\n&lt;entry&gt;Lyneous Linear BRK&lt;/entry&gt;\n&lt;entry&gt;Macropsia BRK&lt;/entry&gt;\n&lt;entry&gt;Mad's Scrawl BRK&lt;/entry&gt;\n&lt;entry&gt;Mincer BRK&lt;/entry&gt;\n&lt;entry&gt;Mini Kaliber O TT BRK&lt;/entry&gt;\n&lt;entry&gt;Mini Kaliber S TT BRK&lt;/entry&gt;\n&lt;entry&gt;Mishmash 4x4i BRK&lt;/entry&gt;\n&lt;entry&gt;Mishmash 4x4o BRK&lt;/entry&gt;\n&lt;entry&gt;Mishmash ALT1 BRK&lt;/entry&gt;\n&lt;entry&gt;Mishmash ALT2 BRK&lt;/entry&gt;\n&lt;entry&gt;Mishmash BRK&lt;/entry&gt;\n&lt;entry&gt;Mishmash Fuse BRK&lt;/entry&gt;\n&lt;entry&gt;Mobilize BRK&lt;/entry&gt;\n&lt;entry&gt;Monkey Phonics BRK&lt;/entry&gt;\n&lt;entry&gt;Monospaced&lt;/entry&gt;\n&lt;entry&gt;Monospaced.bold&lt;/entry&gt;\n&lt;entry&gt;Monospaced.bolditalic&lt;/entry&gt;\n&lt;entry&gt;Monospaced.italic&lt;/entry&gt;\n&lt;entry&gt;Monospaced.plain&lt;/entry&gt;\n&lt;entry&gt;Moronic Misfire BRK&lt;/entry&gt;\n&lt;entry&gt;Mysterons BRK&lt;/entry&gt;\n&lt;entry&gt;Nanosecond Thick BRK&lt;/entry&gt;\n&lt;entry&gt;Nanosecond Thin BRK&lt;/entry&gt;\n&lt;entry&gt;Nanosecond Wide BRK&lt;/entry&gt;\n&lt;entry&gt;Naughts BRK&lt;/entry&gt;\n&lt;entry&gt;Neural BRK&lt;/entry&gt;\n&lt;entry&gt;Neural Outline BRK&lt;/entry&gt;\n&lt;entry&gt;Nominal BRK&lt;/entry&gt;\n&lt;entry&gt;Nostalgia BRK&lt;/entry&gt;\n&lt;entry&gt;Not Quite Right BRK&lt;/entry&gt;\n&lt;entry&gt;Nucleus BRK&lt;/entry&gt;\n&lt;entry&gt;Numskull BRK&lt;/entry&gt;\n&lt;entry&gt;Nymonak BRK&lt;/entry&gt;\n&lt;entry&gt;Obloquy Outline BRK&lt;/entry&gt;\n&lt;entry&gt;Obloquy Solid BRK&lt;/entry&gt;\n&lt;entry&gt;Obstacle BRK&lt;/entry&gt;\n&lt;entry&gt;Obstacle Lines BRK&lt;/entry&gt;\n&lt;entry&gt;Off Kilter L BRK&lt;/entry&gt;\n&lt;entry&gt;Off Kilter R BRK&lt;/entry&gt;\n&lt;entry&gt;Opiated BRK&lt;/entry&gt;\n&lt;entry&gt;Orbicular BRK&lt;/entry&gt;\n&lt;entry&gt;Outer Sider BRK&lt;/entry&gt;\n&lt;entry&gt;Overhead BRK&lt;/entry&gt;\n&lt;entry&gt;Perfect Dark BRK&lt;/entry&gt;\n&lt;entry&gt;Persuasion BRK&lt;/entry&gt;\n&lt;entry&gt;Phorfeit Regular BRK&lt;/entry&gt;\n&lt;entry&gt;Phorfeit Slant BRK&lt;/entry&gt;\n&lt;entry&gt;Pincers BRK&lt;/entry&gt;\n&lt;entry&gt;Pindown BRK&lt;/entry&gt;\n&lt;entry&gt;Pindown Plain BRK&lt;/entry&gt;\n&lt;entry&gt;Pindown X BRK&lt;/entry&gt;\n&lt;entry&gt;Pindown X Plain BRK&lt;/entry&gt;\n&lt;entry&gt;Pixel Krud BRK&lt;/entry&gt;\n&lt;entry&gt;Plasma Drip BRK&lt;/entry&gt;\n&lt;entry&gt;Plasma Drip Empty BRK&lt;/entry&gt;\n&lt;entry&gt;Pneumatics BRK&lt;/entry&gt;\n&lt;entry&gt;Pneumatics Tall BRK&lt;/entry&gt;\n&lt;entry&gt;Pneumatics Wide BRK&lt;/entry&gt;\n&lt;entry&gt;Powderworks BRK&lt;/entry&gt;\n&lt;entry&gt;Pseudo BRK&lt;/entry&gt;\n&lt;entry&gt;Qbicle 1 BRK&lt;/entry&gt;\n&lt;entry&gt;Qbicle 2 BRK&lt;/entry&gt;\n&lt;entry&gt;Qbicle 3 BRK&lt;/entry&gt;\n&lt;entry&gt;Qbicle 4 BRK&lt;/entry&gt;\n&lt;entry&gt;Qlumpy BRK&lt;/entry&gt;\n&lt;entry&gt;Qlumpy Shadow BRK&lt;/entry&gt;\n&lt;entry&gt;Quacksalver BRK&lt;/entry&gt;\n&lt;entry&gt;Quadratic BRK&lt;/entry&gt;\n&lt;entry&gt;Quadratic Cal BRK&lt;/entry&gt;\n&lt;entry&gt;Quandary BRK&lt;/entry&gt;\n&lt;entry&gt;Quantum Flat BRK&lt;/entry&gt;\n&lt;entry&gt;Quantum Flat Hollow BRK&lt;/entry&gt;\n&lt;entry&gt;Quantum Round BRK&lt;/entry&gt;\n&lt;entry&gt;Quantum Round Hollow BRK&lt;/entry&gt;\n&lt;entry&gt;Quantum Taper BRK&lt;/entry&gt;\n&lt;entry&gt;Quarantine BRK&lt;/entry&gt;\n&lt;entry&gt;Quarterly Thick BRK&lt;/entry&gt;\n&lt;entry&gt;Quarterly Thin BRK&lt;/entry&gt;\n&lt;entry&gt;Queasy BRK&lt;/entry&gt;\n&lt;entry&gt;Queasy Outline BRK&lt;/entry&gt;\n&lt;entry&gt;Quill Experimental O BRK&lt;/entry&gt;\n&lt;entry&gt;Quill Experimental S BRK&lt;/entry&gt;\n&lt;entry&gt;Rambling BRK&lt;/entry&gt;\n&lt;entry&gt;Ravaged By Years BRK&lt;/entry&gt;\n&lt;entry&gt;Ravenous Caterpillar BRK&lt;/entry&gt;\n&lt;entry&gt;Raydiate BRK&lt;/entry&gt;\n&lt;entry&gt;Reason BRK&lt;/entry&gt;\n&lt;entry&gt;Reason Shadow BRK&lt;/entry&gt;\n&lt;entry&gt;Redundant BRK&lt;/entry&gt;\n&lt;entry&gt;Regenerate BRK&lt;/entry&gt;\n&lt;entry&gt;Registry BRK&lt;/entry&gt;\n&lt;entry&gt;Rehearsal Curve BRK&lt;/entry&gt;\n&lt;entry&gt;Rehearsal Offset BRK&lt;/entry&gt;\n&lt;entry&gt;Rehearsal Point BRK&lt;/entry&gt;\n&lt;entry&gt;Relapse BRK&lt;/entry&gt;\n&lt;entry&gt;Revert BRK&lt;/entry&gt;\n&lt;entry&gt;Revert Round BRK&lt;/entry&gt;\n&lt;entry&gt;Rotund BRK&lt;/entry&gt;\n&lt;entry&gt;Rotund Outline BRK&lt;/entry&gt;\n&lt;entry&gt;Rough Day BRK&lt;/entry&gt;\n&lt;entry&gt;Ryuker BRK&lt;/entry&gt;\n&lt;entry&gt;SansSerif&lt;/entry&gt;\n&lt;entry&gt;SansSerif.bold&lt;/entry&gt;\n&lt;entry&gt;SansSerif.bolditalic&lt;/entry&gt;\n&lt;entry&gt;SansSerif.italic&lt;/entry&gt;\n&lt;entry&gt;SansSerif.plain&lt;/entry&gt;\n&lt;entry&gt;Sarcastic BRK&lt;/entry&gt;\n&lt;entry&gt;Saunder BRK&lt;/entry&gt;\n&lt;entry&gt;Scalelines BRK&lt;/entry&gt;\n&lt;entry&gt;Scalelines Maze BRK&lt;/entry&gt;\n&lt;entry&gt;Sequence BRK&lt;/entry&gt;\n&lt;entry&gt;Serif&lt;/entry&gt;\n&lt;entry&gt;Serif.bold&lt;/entry&gt;\n&lt;entry&gt;Serif.bolditalic&lt;/entry&gt;\n&lt;entry&gt;Serif.italic&lt;/entry&gt;\n&lt;entry&gt;Serif.plain&lt;/entry&gt;\n&lt;entry&gt;Setback TT BRK&lt;/entry&gt;\n&lt;entry&gt;Sideways BRK&lt;/entry&gt;\n&lt;entry&gt;Simpleton BRK&lt;/entry&gt;\n&lt;entry&gt;Skull Capz BRK&lt;/entry&gt;\n&lt;entry&gt;Slender BRK&lt;/entry&gt;\n&lt;entry&gt;Slender Mini BRK&lt;/entry&gt;\n&lt;entry&gt;Slender Stubby BRK&lt;/entry&gt;\n&lt;entry&gt;Slender Wide BRK&lt;/entry&gt;\n&lt;entry&gt;Snailets BRK&lt;/entry&gt;\n&lt;entry&gt;Spacious BRK&lt;/entry&gt;\n&lt;entry&gt;Spacious Outline BRK&lt;/entry&gt;\n&lt;entry&gt;Spastic BRK&lt;/entry&gt;\n&lt;entry&gt;Spheroids BRK&lt;/entry&gt;\n&lt;entry&gt;Spheroids X BRK&lt;/entry&gt;\n&lt;entry&gt;Splatz BRK&lt;/entry&gt;\n&lt;entry&gt;Square Route BRK&lt;/entry&gt;\n&lt;entry&gt;Stagnation BRK&lt;/entry&gt;\n&lt;entry&gt;Steve&lt;/entry&gt;\n&lt;entry&gt;SteveHand&lt;/entry&gt;\n&lt;entry&gt;Stranded BRK&lt;/entry&gt;\n&lt;entry&gt;Supra Genius Curves BRK&lt;/entry&gt;\n&lt;entry&gt;Supra Genius Lines BRK&lt;/entry&gt;\n&lt;entry&gt;Swirled BRK&lt;/entry&gt;\n&lt;entry&gt;Symmetry BRK&lt;/entry&gt;\n&lt;entry&gt;Syndrome BRK&lt;/entry&gt;\n&lt;entry&gt;Synthetic BRK&lt;/entry&gt;\n&lt;entry&gt;Syracuse BRK&lt;/entry&gt;\n&lt;entry&gt;TRAGIC BRK&lt;/entry&gt;\n&lt;entry&gt;Tearful BRK&lt;/entry&gt;\n&lt;entry&gt;Technique BRK&lt;/entry&gt;\n&lt;entry&gt;Technique OL BRK&lt;/entry&gt;\n&lt;entry&gt;Telephasic BRK&lt;/entry&gt;\n&lt;entry&gt;Tetricide BRK&lt;/entry&gt;\n&lt;entry&gt;Thwart BRK&lt;/entry&gt;\n&lt;entry&gt;Times New Roman&lt;/entry&gt;\n&lt;entry&gt;Times New Roman Bold&lt;/entry&gt;\n&lt;entry&gt;Times New Roman Bold Italic&lt;/entry&gt;\n&lt;entry&gt;Times New Roman Italic&lt;/entry&gt;\n&lt;entry&gt;Tonik BRK&lt;/entry&gt;\n&lt;entry&gt;Trebuchet MS&lt;/entry&gt;\n&lt;entry&gt;Trebuchet MS Bold&lt;/entry&gt;\n&lt;entry&gt;Trebuchet MS Bold Italic&lt;/entry&gt;\n&lt;entry&gt;Trebuchet MS Italic&lt;/entry&gt;\n&lt;entry&gt;Turmoil BRK&lt;/entry&gt;\n&lt;entry&gt;Typesource Extol O BRK&lt;/entry&gt;\n&lt;entry&gt;Typesource Extol S BRK&lt;/entry&gt;\n&lt;entry&gt;UNITED BRK&lt;/entry&gt;\n&lt;entry&gt;Ubiquity BRK&lt;/entry&gt;\n&lt;entry&gt;Unanimous BRK&lt;/entry&gt;\n&lt;entry&gt;Unanimous Inverted BRK&lt;/entry&gt;\n&lt;entry&gt;Underscore 2 BRK&lt;/entry&gt;\n&lt;entry&gt;Underscore BRK&lt;/entry&gt;\n&lt;entry&gt;Underwhelmed BRK&lt;/entry&gt;\n&lt;entry&gt;Underwhelmed Outline BRK&lt;/entry&gt;\n&lt;entry&gt;Unexplored Galaxies BRK&lt;/entry&gt;\n&lt;entry&gt;Unexplored Galaxies O BRK&lt;/entry&gt;\n&lt;entry&gt;Unexplored Galaxies W BRK&lt;/entry&gt;\n&lt;entry&gt;Unexplored Galaxies WO BRK&lt;/entry&gt;\n&lt;entry&gt;Unlearned 2 BRK&lt;/entry&gt;\n&lt;entry&gt;Unlearned BRK&lt;/entry&gt;\n&lt;entry&gt;Unresponsive BRK&lt;/entry&gt;\n&lt;entry&gt;Upheaval TT BRK&lt;/entry&gt;\n&lt;entry&gt;Upraise BRK&lt;/entry&gt;\n&lt;entry&gt;Vacant Capz BRK&lt;/entry&gt;\n&lt;entry&gt;Vanished BRK&lt;/entry&gt;\n&lt;entry&gt;Vantage BRK&lt;/entry&gt;\n&lt;entry&gt;Variance BRK&lt;/entry&gt;\n&lt;entry&gt;Verdana&lt;/entry&gt;\n&lt;entry&gt;Verdana Bold&lt;/entry&gt;\n&lt;entry&gt;Verdana Bold Italic&lt;/entry&gt;\n&lt;entry&gt;Verdana Italic&lt;/entry&gt;\n&lt;entry&gt;Vertigo 2 BRK&lt;/entry&gt;\n&lt;entry&gt;Vertigo BRK&lt;/entry&gt;\n&lt;entry&gt;Vertigo Upright 2 BRK&lt;/entry&gt;\n&lt;entry&gt;Vertigo Upright BRK&lt;/entry&gt;\n&lt;entry&gt;Vigilance BRK&lt;/entry&gt;\n&lt;entry&gt;Vindictive BRK&lt;/entry&gt;\n&lt;entry&gt;Visitor TT1 BRK&lt;/entry&gt;\n&lt;entry&gt;Visitor TT2 BRK&lt;/entry&gt;\n&lt;entry&gt;Volatile 1 BRK&lt;/entry&gt;\n&lt;entry&gt;Volatile 2 BRK&lt;/entry&gt;\n&lt;entry&gt;Wager BRK&lt;/entry&gt;\n&lt;entry&gt;Wager Lost BRK&lt;/entry&gt;\n&lt;entry&gt;Wager Won BRK&lt;/entry&gt;\n&lt;entry&gt;Wayward BRK&lt;/entry&gt;\n&lt;entry&gt;Wayward Shadow BRK&lt;/entry&gt;\n&lt;entry&gt;Weathered BRK&lt;/entry&gt;\n&lt;entry&gt;Weathered Solid BRK&lt;/entry&gt;\n&lt;entry&gt;Weaver BRK&lt;/entry&gt;\n&lt;entry&gt;Webdings&lt;/entry&gt;\n&lt;entry&gt;Whatever BRK&lt;/entry&gt;\n&lt;entry&gt;Whippersnapper BRK&lt;/entry&gt;\n&lt;entry&gt;Wiggly Squiggly BRK&lt;/entry&gt;\n&lt;entry&gt;Wincing BRK&lt;/entry&gt;\n&lt;entry&gt;Withstand BRK&lt;/entry&gt;\n&lt;entry&gt;Wobbly BRK&lt;/entry&gt;\n&lt;entry&gt;Wyvern Wings BRK&lt;/entry&gt;\n&lt;entry&gt;Wyvern Wings Wyde BRK&lt;/entry&gt;\n&lt;entry&gt;Xerox Malfunction BRK&lt;/entry&gt;\n&lt;entry&gt;Xhume BRK&lt;/entry&gt;\n&lt;entry&gt;Xipital BRK&lt;/entry&gt;\n&lt;entry&gt;Xmas Lights BRK&lt;/entry&gt;\n&lt;entry&gt;Xtrusion BRK&lt;/entry&gt;\n&lt;entry&gt;Yearend BRK&lt;/entry&gt;\n&lt;entry&gt;Yesterday BRK&lt;/entry&gt;\n&lt;entry&gt;Yielding BRK&lt;/entry&gt;\n&lt;entry&gt;Yonder BRK&lt;/entry&gt;\n&lt;entry&gt;Yoshi's Story game text BRK&lt;/entry&gt;\n&lt;entry&gt;Your Complex BRK&lt;/entry&gt;\n&lt;entry&gt;Your Complex I BRK&lt;/entry&gt;\n&lt;entry&gt;Your Complex O BRK&lt;/entry&gt;\n&lt;entry&gt;Zelda DX TT BRK&lt;/entry&gt;\n&lt;entry&gt;Zenith BRK&lt;/entry&gt;\n&lt;entry&gt;Zephyrean BRK&lt;/entry&gt;\n&lt;entry&gt;Zephyrean Gust BRK&lt;/entry&gt;\n&lt;entry&gt;Zero Velocity BRK&lt;/entry&gt;\n&lt;entry&gt;Zirconia BRK&lt;/entry&gt;\n&lt;entry&gt;Zirconia Cubic BRK&lt;/entry&gt;\n&lt;entry&gt;Zoetrope BRK&lt;/entry&gt;\n&lt;entry&gt;Zoidal BRK&lt;/entry&gt;\n&lt;entry&gt;Zurklez Outline BRK&lt;/entry&gt;\n&lt;entry&gt;Zurklez Solid BRK&lt;/entry&gt;\n&lt;entry&gt;genotype H BRK&lt;/entry&gt;\n&lt;entry&gt;genotype RH BRK&lt;/entry&gt;\n&lt;entry&gt;genotype RS BRK&lt;/entry&gt;\n&lt;entry&gt;genotype S BRK&lt;/entry&gt;\n&lt;entry&gt;techno overload BRK&lt;/entry&gt;\n&lt;entry&gt;waver BRK&lt;/entry&gt;\n&lt;entry&gt;\u00c6 Systematic TT BRK&lt;/entry&gt;\n&lt;entry&gt;\u00c6nigma Scrawl 4 BRK&lt;/entry&gt;\n&lt;/fonts&gt;\n&lt;/root&gt;\n\n</pre>"},{"location":"notebooks/Fonts/#fonts","title":"Fonts\u00b6","text":"<p>The REST API allows you to list\u2014but not modify\u2014fonts available in GeoServer. It can be useful to use this operation to verify if a font used in a style file is available before uploading it.</p> <p>Note:  You can find the official example at https://docs.geoserver.org/2.25.x/en/user/rest/fonts.html</p>"},{"location":"notebooks/Fonts/#setup","title":"Setup\u00b6","text":""},{"location":"notebooks/Fonts/#imports","title":"Imports\u00b6","text":"<p>First, we need to import the necessary modules and classes.</p>"},{"location":"notebooks/Fonts/#geoserver-connection","title":"GeoServer Connection\u00b6","text":"<p>Connect to the running GeoServer instance and create a workspace and a store.</p>"},{"location":"notebooks/Fonts/#listing-all-fonts","title":"Listing all fonts\u00b6","text":"<p>You can retrieve all fonts available in GeoServer with the <code>get_fonts</code> method. Additionnaly, you can specify the response format (JSON or XML) with the <code>format</code> parameter.</p>"},{"location":"notebooks/Image%20Mosaic/","title":"Image Mosaic","text":"In\u00a0[1]: Copied! <pre>from pathlib import Path\nfrom geoserver import GeoServer\n</pre> from pathlib import Path from geoserver import GeoServer In\u00a0[2]: Copied! <pre># Setup the geoserver instance\ngeoserver = GeoServer(\n    service_url=\"http://localhost:8080/geoserver\",\n    username=\"admin\",\n    password=\"geoserver\",\n)\n</pre> # Setup the geoserver instance geoserver = GeoServer(     service_url=\"http://localhost:8080/geoserver\",     username=\"admin\",     password=\"geoserver\", ) <p>Let's clean up the workspace and remove created data.</p> In\u00a0[3]: Copied! <pre>if geoserver.workspace_exists(\"demo\"):\n    geoserver.delete_workspace(\"demo\", recurse=True)\n\ngeoserver.create_workspace_from_name(\"demo\")\n</pre> if geoserver.workspace_exists(\"demo\"):     geoserver.delete_workspace(\"demo\", recurse=True)  geoserver.create_workspace_from_name(\"demo\") Out[3]: <pre>'Created'</pre> In\u00a0[4]: Copied! <pre># Directory containing sample data\nDATA_DIR = Path(\"../tests/data\")\nassert DATA_DIR.exists(), f\"The directory {DATA_DIR} does not exist.\"\n</pre> # Directory containing sample data DATA_DIR = Path(\"../tests/data\") assert DATA_DIR.exists(), f\"The directory {DATA_DIR} does not exist.\" In\u00a0[5]: Copied! <pre>file_path = DATA_DIR / \"mosaics\" / \"polyphemus.zip\"\nassert file_path.exists(), f\"File not found: {file_path.as_posix()!r}\"\n\n\n# If the store already exists, it will be overwritten\ngeoserver.upload_coverage_store(file=file_path, format=\"imagemosaic\", workspace=\"demo\", name=\"polyphemus\")\n</pre> file_path = DATA_DIR / \"mosaics\" / \"polyphemus.zip\" assert file_path.exists(), f\"File not found: {file_path.as_posix()!r}\"   # If the store already exists, it will be overwritten geoserver.upload_coverage_store(file=file_path, format=\"imagemosaic\", workspace=\"demo\", name=\"polyphemus\") Out[5]: <pre>'Created'</pre> In\u00a0[6]: Copied! <pre>xml = geoserver.get_coverages(workspace=\"demo\", store=\"polyphemus\", format=\"xml\")\nprint(xml)\n</pre> xml = geoserver.get_coverages(workspace=\"demo\", store=\"polyphemus\", format=\"xml\") print(xml) <pre>&lt;coverages&gt;\n  &lt;coverage&gt;\n    &lt;name&gt;O3&lt;/name&gt;\n    &lt;atom:link xmlns:atom=\"http://www.w3.org/2005/Atom\" rel=\"alternate\" href=\"http://localhost:8080/geoserver/rest/workspaces/demo/coveragestores/polyphemus/coverages/O3.xml\" type=\"application/atom+xml\"/&gt;\n  &lt;/coverage&gt;\n&lt;/coverages&gt;\n</pre> In\u00a0[7]: Copied! <pre>xml = geoserver.get_coverage(name=\"O3\", workspace=\"demo\", store=\"polyphemus\", format=\"xml\")\nprint(xml)\n</pre> xml = geoserver.get_coverage(name=\"O3\", workspace=\"demo\", store=\"polyphemus\", format=\"xml\") print(xml) <pre>&lt;coverage&gt;\n  &lt;name&gt;O3&lt;/name&gt;\n  &lt;nativeName&gt;O3&lt;/nativeName&gt;\n  &lt;namespace&gt;\n    &lt;name&gt;demo&lt;/name&gt;\n    &lt;atom:link xmlns:atom=\"http://www.w3.org/2005/Atom\" rel=\"alternate\" href=\"http://localhost:8080/geoserver/rest/namespaces/demo.xml\" type=\"application/xml\"/&gt;\n  &lt;/namespace&gt;\n  &lt;title&gt;O3&lt;/title&gt;\n  &lt;description&gt;Generated from ImageMosaic&lt;/description&gt;\n  &lt;keywords&gt;\n    &lt;string&gt;O3&lt;/string&gt;\n    &lt;string&gt;WCS&lt;/string&gt;\n    &lt;string&gt;ImageMosaic&lt;/string&gt;\n  &lt;/keywords&gt;\n  &lt;nativeCRS&gt;GEOGCS[&amp;quot;WGS 84&amp;quot;, \n  DATUM[&amp;quot;World Geodetic System 1984&amp;quot;, \n    SPHEROID[&amp;quot;WGS 84&amp;quot;, 6378137.0, 298.257223563, AUTHORITY[&amp;quot;EPSG&amp;quot;,&amp;quot;7030&amp;quot;]], \n    AUTHORITY[&amp;quot;EPSG&amp;quot;,&amp;quot;6326&amp;quot;]], \n  PRIMEM[&amp;quot;Greenwich&amp;quot;, 0.0, AUTHORITY[&amp;quot;EPSG&amp;quot;,&amp;quot;8901&amp;quot;]], \n  UNIT[&amp;quot;degree&amp;quot;, 0.017453292519943295], \n  AXIS[&amp;quot;Geodetic longitude&amp;quot;, EAST], \n  AXIS[&amp;quot;Geodetic latitude&amp;quot;, NORTH], \n  AUTHORITY[&amp;quot;EPSG&amp;quot;,&amp;quot;4326&amp;quot;]]&lt;/nativeCRS&gt;\n  &lt;srs&gt;EPSG:4326&lt;/srs&gt;\n  &lt;nativeBoundingBox&gt;\n    &lt;minx&gt;4.9375&lt;/minx&gt;\n    &lt;maxx&gt;14.9375&lt;/maxx&gt;\n    &lt;miny&gt;44.96875&lt;/miny&gt;\n    &lt;maxy&gt;50.96875&lt;/maxy&gt;\n    &lt;crs&gt;EPSG:4326&lt;/crs&gt;\n  &lt;/nativeBoundingBox&gt;\n  &lt;latLonBoundingBox&gt;\n    &lt;minx&gt;4.9375&lt;/minx&gt;\n    &lt;maxx&gt;14.9375&lt;/maxx&gt;\n    &lt;miny&gt;44.96875&lt;/miny&gt;\n    &lt;maxy&gt;50.96875&lt;/maxy&gt;\n    &lt;crs&gt;EPSG:4326&lt;/crs&gt;\n  &lt;/latLonBoundingBox&gt;\n  &lt;projectionPolicy&gt;REPROJECT_TO_DECLARED&lt;/projectionPolicy&gt;\n  &lt;enabled&gt;true&lt;/enabled&gt;\n  &lt;metadata&gt;\n    &lt;entry key=\"dirName\"&gt;polyphemus_null&lt;/entry&gt;\n  &lt;/metadata&gt;\n  &lt;store class=\"coverageStore\"&gt;\n    &lt;name&gt;demo:polyphemus&lt;/name&gt;\n    &lt;atom:link xmlns:atom=\"http://www.w3.org/2005/Atom\" rel=\"alternate\" href=\"http://localhost:8080/geoserver/rest/workspaces/demo/coveragestores/polyphemus.xml\" type=\"application/xml\"/&gt;\n  &lt;/store&gt;\n  &lt;serviceConfiguration&gt;false&lt;/serviceConfiguration&gt;\n  &lt;simpleConversionEnabled&gt;false&lt;/simpleConversionEnabled&gt;\n  &lt;nativeFormat&gt;ImageMosaic&lt;/nativeFormat&gt;\n  &lt;grid dimension=\"2\"&gt;\n    &lt;range&gt;\n      &lt;low&gt;0 0&lt;/low&gt;\n      &lt;high&gt;80 96&lt;/high&gt;\n    &lt;/range&gt;\n    &lt;transform&gt;\n      &lt;scaleX&gt;0.125&lt;/scaleX&gt;\n      &lt;scaleY&gt;-0.0625&lt;/scaleY&gt;\n      &lt;shearX&gt;0.0&lt;/shearX&gt;\n      &lt;shearY&gt;0.0&lt;/shearY&gt;\n      &lt;translateX&gt;5.0&lt;/translateX&gt;\n      &lt;translateY&gt;50.9375&lt;/translateY&gt;\n    &lt;/transform&gt;\n    &lt;crs&gt;EPSG:4326&lt;/crs&gt;\n  &lt;/grid&gt;\n  &lt;supportedFormats&gt;\n    &lt;string&gt;GIF&lt;/string&gt;\n    &lt;string&gt;PNG&lt;/string&gt;\n    &lt;string&gt;JPEG&lt;/string&gt;\n    &lt;string&gt;TIFF&lt;/string&gt;\n    &lt;string&gt;NetCDF&lt;/string&gt;\n    &lt;string&gt;EHdr&lt;/string&gt;\n    &lt;string&gt;VRT&lt;/string&gt;\n    &lt;string&gt;GEOTIFF&lt;/string&gt;\n    &lt;string&gt;DTED&lt;/string&gt;\n    &lt;string&gt;ArcGrid&lt;/string&gt;\n    &lt;string&gt;RST&lt;/string&gt;\n    &lt;string&gt;GeoPackage (mosaic)&lt;/string&gt;\n    &lt;string&gt;ImageMosaic&lt;/string&gt;\n    &lt;string&gt;SRP&lt;/string&gt;\n    &lt;string&gt;ENVIHdr&lt;/string&gt;\n    &lt;string&gt;ERDASImg&lt;/string&gt;\n    &lt;string&gt;ImagePyramid&lt;/string&gt;\n    &lt;string&gt;AIG&lt;/string&gt;\n    &lt;string&gt;RPFTOC&lt;/string&gt;\n    &lt;string&gt;NITF&lt;/string&gt;\n  &lt;/supportedFormats&gt;\n  &lt;interpolationMethods&gt;\n    &lt;string&gt;nearest neighbor&lt;/string&gt;\n    &lt;string&gt;bilinear&lt;/string&gt;\n    &lt;string&gt;bicubic&lt;/string&gt;\n  &lt;/interpolationMethods&gt;\n  &lt;defaultInterpolationMethod&gt;nearest neighbor&lt;/defaultInterpolationMethod&gt;\n  &lt;dimensions&gt;\n    &lt;coverageDimension&gt;\n      &lt;name&gt;GRAY_INDEX&lt;/name&gt;\n      &lt;description&gt;GridSampleDimension[-Infinity,Infinity]&lt;/description&gt;\n      &lt;range&gt;\n        &lt;min&gt;-inf&lt;/min&gt;\n        &lt;max&gt;inf&lt;/max&gt;\n      &lt;/range&gt;\n      &lt;dimensionType&gt;\n        &lt;name&gt;REAL_32BITS&lt;/name&gt;\n      &lt;/dimensionType&gt;\n    &lt;/coverageDimension&gt;\n  &lt;/dimensions&gt;\n  &lt;requestSRS&gt;\n    &lt;string&gt;EPSG:4326&lt;/string&gt;\n  &lt;/requestSRS&gt;\n  &lt;responseSRS&gt;\n    &lt;string&gt;EPSG:4326&lt;/string&gt;\n  &lt;/responseSRS&gt;\n  &lt;parameters&gt;\n    &lt;entry&gt;\n      &lt;string&gt;BackgroundValues&lt;/string&gt;\n      &lt;string&gt;&lt;/string&gt;\n    &lt;/entry&gt;\n    &lt;entry&gt;\n      &lt;string&gt;OVERVIEW_POLICY&lt;/string&gt;\n      &lt;string&gt;QUALITY&lt;/string&gt;\n    &lt;/entry&gt;\n    &lt;entry&gt;\n      &lt;string&gt;MergeBehavior&lt;/string&gt;\n      &lt;string&gt;FLAT&lt;/string&gt;\n    &lt;/entry&gt;\n    &lt;entry&gt;\n      &lt;string&gt;AllowMultithreading&lt;/string&gt;\n      &lt;string&gt;false&lt;/string&gt;\n    &lt;/entry&gt;\n    &lt;entry&gt;\n      &lt;string&gt;MaxAllowedTiles&lt;/string&gt;\n      &lt;string&gt;-1&lt;/string&gt;\n    &lt;/entry&gt;\n    &lt;entry&gt;\n      &lt;string&gt;ExcessGranuleRemoval&lt;/string&gt;\n      &lt;string&gt;NONE&lt;/string&gt;\n    &lt;/entry&gt;\n    &lt;entry&gt;\n      &lt;string&gt;OutputTransparentColor&lt;/string&gt;\n      &lt;string&gt;&lt;/string&gt;\n    &lt;/entry&gt;\n    &lt;entry&gt;\n      &lt;string&gt;USE_JAI_IMAGEREAD&lt;/string&gt;\n      &lt;string&gt;true&lt;/string&gt;\n    &lt;/entry&gt;\n    &lt;entry&gt;\n      &lt;string&gt;Bands&lt;/string&gt;\n      &lt;string&gt;&lt;/string&gt;\n    &lt;/entry&gt;\n    &lt;entry&gt;\n      &lt;string&gt;RescalePixels&lt;/string&gt;\n      &lt;string&gt;true&lt;/string&gt;\n    &lt;/entry&gt;\n    &lt;entry&gt;\n      &lt;string&gt;Filter&lt;/string&gt;\n      &lt;string&gt;&lt;/string&gt;\n    &lt;/entry&gt;\n    &lt;entry&gt;\n      &lt;string&gt;InputTransparentColor&lt;/string&gt;\n      &lt;string&gt;&lt;/string&gt;\n    &lt;/entry&gt;\n    &lt;entry&gt;\n      &lt;string&gt;SUGGESTED_TILE_SIZE&lt;/string&gt;\n      &lt;string&gt;512,512&lt;/string&gt;\n    &lt;/entry&gt;\n    &lt;entry&gt;\n      &lt;string&gt;Accurate resolution computation&lt;/string&gt;\n      &lt;string&gt;false&lt;/string&gt;\n    &lt;/entry&gt;\n    &lt;entry&gt;\n      &lt;string&gt;SORTING&lt;/string&gt;\n      &lt;string&gt;&lt;/string&gt;\n    &lt;/entry&gt;\n    &lt;entry&gt;\n      &lt;string&gt;FootprintBehavior&lt;/string&gt;\n      &lt;string&gt;None&lt;/string&gt;\n    &lt;/entry&gt;\n  &lt;/parameters&gt;\n  &lt;nativeCoverageName&gt;O3&lt;/nativeCoverageName&gt;\n&lt;/coverage&gt;\n</pre> In\u00a0[8]: Copied! <pre>xml = geoserver.get_coverage_index(name=\"O3\", workspace=\"demo\", store=\"polyphemus\", format=\"xml\")\nprint(xml)\n</pre> xml = geoserver.get_coverage_index(name=\"O3\", workspace=\"demo\", store=\"polyphemus\", format=\"xml\") print(xml) <pre>&lt;Schema&gt;\n  &lt;attributes&gt;\n    &lt;Attribute&gt;\n      &lt;name&gt;the_geom&lt;/name&gt;\n      &lt;minOccurs&gt;0&lt;/minOccurs&gt;\n      &lt;maxOccurs&gt;1&lt;/maxOccurs&gt;\n      &lt;nillable&gt;true&lt;/nillable&gt;\n      &lt;binding&gt;org.locationtech.jts.geom.Polygon&lt;/binding&gt;\n    &lt;/Attribute&gt;\n    &lt;Attribute&gt;\n      &lt;name&gt;location&lt;/name&gt;\n      &lt;minOccurs&gt;0&lt;/minOccurs&gt;\n      &lt;maxOccurs&gt;1&lt;/maxOccurs&gt;\n      &lt;nillable&gt;true&lt;/nillable&gt;\n      &lt;binding&gt;java.lang.String&lt;/binding&gt;\n    &lt;/Attribute&gt;\n    &lt;Attribute&gt;\n      &lt;name&gt;imageindex&lt;/name&gt;\n      &lt;minOccurs&gt;0&lt;/minOccurs&gt;\n      &lt;maxOccurs&gt;1&lt;/maxOccurs&gt;\n      &lt;nillable&gt;true&lt;/nillable&gt;\n      &lt;binding&gt;java.lang.Integer&lt;/binding&gt;\n    &lt;/Attribute&gt;\n    &lt;Attribute&gt;\n      &lt;name&gt;time&lt;/name&gt;\n      &lt;minOccurs&gt;0&lt;/minOccurs&gt;\n      &lt;maxOccurs&gt;1&lt;/maxOccurs&gt;\n      &lt;nillable&gt;true&lt;/nillable&gt;\n      &lt;binding&gt;java.sql.Timestamp&lt;/binding&gt;\n    &lt;/Attribute&gt;\n  &lt;/attributes&gt;\n  &lt;atom:link xmlns:atom=\"http://www.w3.org/2005/Atom\" rel=\"alternate\" href=\"http://localhost:8080/geoserver/rest/workspaces/demo/coveragestores/polyphemus/coverages/O3/index/granules.xml\" type=\"application/xml\"/&gt;\n&lt;/Schema&gt;\n</pre> <p>Retrieve the existing granule information:</p> In\u00a0[9]: Copied! <pre>xml = geoserver.get_coverage_granules(name=\"O3\", workspace=\"demo\", store=\"polyphemus\", format=\"xml\")\nprint(xml)\n</pre> xml = geoserver.get_coverage_granules(name=\"O3\", workspace=\"demo\", store=\"polyphemus\", format=\"xml\") print(xml) <pre>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;wfs:FeatureCollection xmlns:xs=\"http://www.w3.org/2001/XMLSchema\" xmlns:gf=\"http://www.geoserver.org/rest/granules\" xmlns:wfs=\"http://www.opengis.net/wfs\" xmlns:gml=\"http://www.opengis.net/gml\" xmlns:ogc=\"http://www.opengis.net/ogc\"&gt;\n&lt;gml:boundedBy&gt;\n&lt;gml:Box srsName=\"http://www.opengis.net/gml/srs/epsg.xml#4326\"&gt;\n&lt;gml:coord&gt;\n&lt;gml:X&gt;4.9375&lt;/gml:X&gt;\n&lt;gml:Y&gt;44.96875&lt;/gml:Y&gt;\n&lt;/gml:coord&gt;\n&lt;gml:coord&gt;\n&lt;gml:X&gt;14.9375&lt;/gml:X&gt;\n&lt;gml:Y&gt;50.96875&lt;/gml:Y&gt;\n&lt;/gml:coord&gt;\n&lt;/gml:Box&gt;\n&lt;/gml:boundedBy&gt;\n&lt;gml:featureMember&gt;\n&lt;gf:O3 fid=\"O3.1\"&gt;\n&lt;gml:boundedBy&gt;\n&lt;gml:Box srsName=\"http://www.opengis.net/gml/srs/epsg.xml#4326\"&gt;\n&lt;gml:coordinates&gt;4.9375,44.96875 14.9375,50.96875&lt;/gml:coordinates&gt;\n&lt;/gml:Box&gt;\n&lt;/gml:boundedBy&gt;\n&lt;gf:the_geom&gt;\n&lt;gml:Polygon srsName=\"http://www.opengis.net/gml/srs/epsg.xml#4326\"&gt;\n&lt;gml:outerBoundaryIs&gt;\n&lt;gml:LinearRing&gt;\n&lt;gml:coordinates&gt;4.9375,44.96875 4.9375,50.96875 14.9375,50.96875 14.9375,44.96875 4.9375,44.96875&lt;/gml:coordinates&gt;\n&lt;/gml:LinearRing&gt;\n&lt;/gml:outerBoundaryIs&gt;\n&lt;/gml:Polygon&gt;\n&lt;/gf:the_geom&gt;\n&lt;gf:location&gt;polyphemus_20130301_test.nc&lt;/gf:location&gt;\n&lt;gf:imageindex&gt;0&lt;/gf:imageindex&gt;\n&lt;gf:time&gt;2013-03-01T00:00:00Z&lt;/gf:time&gt;\n&lt;/gf:O3&gt;\n&lt;/gml:featureMember&gt;\n&lt;gml:featureMember&gt;\n&lt;gf:O3 fid=\"O3.2\"&gt;\n&lt;gml:boundedBy&gt;\n&lt;gml:Box srsName=\"http://www.opengis.net/gml/srs/epsg.xml#4326\"&gt;\n&lt;gml:coordinates&gt;4.9375,44.96875 14.9375,50.96875&lt;/gml:coordinates&gt;\n&lt;/gml:Box&gt;\n&lt;/gml:boundedBy&gt;\n&lt;gf:the_geom&gt;\n&lt;gml:Polygon srsName=\"http://www.opengis.net/gml/srs/epsg.xml#4326\"&gt;\n&lt;gml:outerBoundaryIs&gt;\n&lt;gml:LinearRing&gt;\n&lt;gml:coordinates&gt;4.9375,44.96875 4.9375,50.96875 14.9375,50.96875 14.9375,44.96875 4.9375,44.96875&lt;/gml:coordinates&gt;\n&lt;/gml:LinearRing&gt;\n&lt;/gml:outerBoundaryIs&gt;\n&lt;/gml:Polygon&gt;\n&lt;/gf:the_geom&gt;\n&lt;gf:location&gt;polyphemus_20130301_test.nc&lt;/gf:location&gt;\n&lt;gf:imageindex&gt;1&lt;/gf:imageindex&gt;\n&lt;gf:time&gt;2013-03-01T01:00:00Z&lt;/gf:time&gt;\n&lt;/gf:O3&gt;\n&lt;/gml:featureMember&gt;\n&lt;/wfs:FeatureCollection&gt;\n\n</pre> In\u00a0[10]: Copied! <pre>geoserver.delete_coverage_granules(name=\"O3\", workspace=\"demo\", store=\"polyphemus\", filter=\"location='polyphemus_20130301.nc'\")\n</pre> geoserver.delete_coverage_granules(name=\"O3\", workspace=\"demo\", store=\"polyphemus\", filter=\"location='polyphemus_20130301.nc'\") Out[10]: <pre>'Deleted'</pre> <pre>file_path = EXAMPLES_DIR / \"mosaics\" / \"empty.zip\"\nassert file_path.exists(), f\"File not found: {file_path.as_posix()!r}\"\n\n\ngeoserver.upload_coverage_store(file=file_path, format=\"imagemosaic\", workspace=\"demo\", store=\"empty\", configure=\"none\")\n</pre> <p>Note:  The <code>configure=\"none\"</code> parameter allows for future configuration after harvesting</p> In\u00a0[\u00a0]: Copied! <pre>\n</pre> <p>Note:  When specifying only the coverage name, the coverage will be automatically configured.</p>"},{"location":"notebooks/Image%20Mosaic/#image-mosaic","title":"Image Mosaic\u00b6","text":""},{"location":"notebooks/Image%20Mosaic/#setup","title":"Setup\u00b6","text":""},{"location":"notebooks/Image%20Mosaic/#imports","title":"Imports\u00b6","text":"<p>First, we need to import the necessary modules and classes.</p>"},{"location":"notebooks/Image%20Mosaic/#geoserver-connection","title":"GeoServer Connection\u00b6","text":"<p>Connect to the running GeoServer instance and create a workspace and a store.</p>"},{"location":"notebooks/Image%20Mosaic/#config","title":"Config\u00b6","text":"<p>We'll set up the configuration for the notebook:</p>"},{"location":"notebooks/Image%20Mosaic/#uploading-a-new-image-mosaic","title":"Uploading a new image mosaic\u00b6","text":"<p>Upload a ZIP file containing a mosaic definition and granule(s).</p>"},{"location":"notebooks/Image%20Mosaic/#updating-an-image-mosaic-contents","title":"Updating an image mosaic contents\u00b6","text":"<p>Harvest (or reharvest) a single file into the mosaic and update the mosaic index.</p> <pre>geoserver.upload_coverage_store(\n    file=\"file:/path/to/the/file/polyphemus_20130302.nc\", \n    format=\"imagemosaic\", \n    workspace=\"demo\", \n    name=\"poly-incremental\",\n)\n</pre> <p>Harvest (or reharvest) a whole directory into the mosaic and update the mosaic index.</p> <pre>geoserver.upload_coverage_store(\n    file=\"file:/path/to/the/mosaic/folder\", \n    format=\"imagemosaic\", \n    workspace=\"demo\", \n    name=\"poly-incremental\",\n)\n</pre>"},{"location":"notebooks/Image%20Mosaic/#listing-image-mosaic-details","title":"Listing image mosaic details\u00b6","text":"<p>Retrieve the image mosaic index structure.</p>"},{"location":"notebooks/Image%20Mosaic/#removing-image-mosaic-granules","title":"Removing image mosaic granules\u00b6","text":"<p>Remove all the granules originating from a particular file.</p>"},{"location":"notebooks/Image%20Mosaic/#uploading-an-empty-mosaic","title":"Uploading an empty mosaic\u00b6","text":"<p>Upload an archive with the definition of an mosaic, but with no granules.</p> <p>Given a empty.zip file containing:</p> <ul> <li><code>datastore.properties</code> (PostGIS connection parameters)</li> <li><code>indexer.xml</code> (Mosaic indexer; note the CanBeEmpty=true parameter)</li> <li><code>polyphemus-test.xml</code> (Auxiliary file used by the NetCDF reader to parse schemas and tables)</li> </ul> <p>Warning:  Make sure to update the <code>datastore.properties</code> file with your connection parameters and refresh the ZIP before uploading it.</p>"},{"location":"notebooks/Layer%20Groups/","title":"Layer Groups","text":"In\u00a0[1]: Copied! <pre>from pathlib import Path\nfrom geoserver import GeoServer\n</pre> from pathlib import Path from geoserver import GeoServer In\u00a0[2]: Copied! <pre># Setup the geoserver instance\ngeoserver = GeoServer(\n    service_url=\"http://localhost:8080/geoserver\",\n    username=\"admin\",\n    password=\"geoserver\",\n)\n</pre> # Setup the geoserver instance geoserver = GeoServer(     service_url=\"http://localhost:8080/geoserver\",     username=\"admin\",     password=\"geoserver\", ) <p>Let's clean up existing layer groups before we start.</p> In\u00a0[3]: Copied! <pre>if geoserver.workspace_exists(\"demo\"):\n    geoserver.delete_workspace(\"demo\", recurse=True)\n\ngeoserver.create_workspace_from_name(\"demo\")\n</pre> if geoserver.workspace_exists(\"demo\"):     geoserver.delete_workspace(\"demo\", recurse=True)  geoserver.create_workspace_from_name(\"demo\") Out[3]: <pre>'Created'</pre> In\u00a0[4]: Copied! <pre># Directory containing sample data\nDATA_DIR = Path(\"../tests/data\")\nassert DATA_DIR.exists(), f\"The directory {DATA_DIR} does not exist.\"\n</pre> # Directory containing sample data DATA_DIR = Path(\"../tests/data\") assert DATA_DIR.exists(), f\"The directory {DATA_DIR} does not exist.\" In\u00a0[5]: Copied! <pre>geoserver.get_layer_groups(workspace=\"demo\")\n</pre> geoserver.get_layer_groups(workspace=\"demo\") Out[5]: <pre>{'layerGroups': ''}</pre> <p>First, make sure you have setup the layers you want to include in the layer group.</p> In\u00a0[6]: Copied! <pre># Add a coverage store\nfile_path = DATA_DIR / \"rasters\" / \"raster.tif\"\nassert file_path.exists(), f\"File not found: {file_path.as_posix()!r}\"\n\ngeoserver.upload_coverage_store(file=file_path, workspace=\"demo\", format=\"geotiff\")\n\n\n# Add a vector store\nfile_path = DATA_DIR / \"vectors\" / \"buildings.shp\"\nassert file_path.exists(), f\"File not found: {file_path.as_posix()!r}\"\n\ngeoserver.upload_data_store(file=file_path, workspace=\"demo\", format=\"shp\")\n</pre> # Add a coverage store file_path = DATA_DIR / \"rasters\" / \"raster.tif\" assert file_path.exists(), f\"File not found: {file_path.as_posix()!r}\"  geoserver.upload_coverage_store(file=file_path, workspace=\"demo\", format=\"geotiff\")   # Add a vector store file_path = DATA_DIR / \"vectors\" / \"buildings.shp\" assert file_path.exists(), f\"File not found: {file_path.as_posix()!r}\"  geoserver.upload_data_store(file=file_path, workspace=\"demo\", format=\"shp\") Out[6]: <pre>'Created'</pre> In\u00a0[7]: Copied! <pre># Using XML format\nbody = \"\"\"\n&lt;layerGroup&gt;\n  &lt;name&gt;my_group&lt;/name&gt;\n  &lt;layers&gt;\n    &lt;layer&gt;buildings&lt;/layer&gt;\n    &lt;layer&gt;raster&lt;/layer&gt;\n  &lt;/layers&gt;\n  &lt;styles&gt;\n    &lt;style&gt;polygon&lt;/style&gt;\n    &lt;style&gt;raster&lt;/style&gt;\n  &lt;/styles&gt;\n&lt;/layerGroup&gt;\n\"\"\"\n\ngeoserver.create_layer_group(body=body, workspace=\"demo\")\n</pre> # Using XML format body = \"\"\"  my_group buildings raster  \"\"\"  geoserver.create_layer_group(body=body, workspace=\"demo\") Out[7]: <pre>'Created'</pre> In\u00a0[8]: Copied! <pre>geoserver.get_layer_group(name=\"my_group\", workspace=\"demo\")\n</pre> geoserver.get_layer_group(name=\"my_group\", workspace=\"demo\") Out[8]: <pre>{'layerGroup': {'name': 'my_group',\n  'mode': 'SINGLE',\n  'workspace': {'name': 'demo'},\n  'publishables': {'published': [{'@type': 'layer',\n     'name': 'demo:buildings',\n     'href': 'http://localhost:8080/geoserver/rest/workspaces/demo/layers/buildings.json'},\n    {'@type': 'layer',\n     'name': 'demo:raster',\n     'href': 'http://localhost:8080/geoserver/rest/workspaces/demo/layers/raster.json'}]},\n  'styles': {'style': [{'name': 'polygon',\n     'href': 'http://localhost:8080/geoserver/rest/styles/polygon.json'},\n    {'name': 'raster',\n     'href': 'http://localhost:8080/geoserver/rest/styles/raster.json'}]},\n  'bounds': {'minx': -1.514093836,\n   'maxx': -1.508900084,\n   'miny': 48.63391919,\n   'maxy': 48.638064247,\n   'crs': {'@class': 'org.geotools.referencing.crs.DefaultEngineeringCRS',\n    '$': 'EPSG:404000'}},\n  'dateCreated': '2024-06-12 22:31:31.591 UTC'}}</pre> In\u00a0[9]: Copied! <pre># Using XML format\nbody = \"\"\"\n&lt;layerGroup&gt;\n    &lt;name&gt;my_group&lt;/name&gt;\n    &lt;layers&gt;\n        &lt;layer&gt;buildings&lt;/layer&gt;\n    &lt;/layers&gt;\n    &lt;styles&gt;\n        &lt;style&gt;polygon&lt;/style&gt;\n    &lt;/styles&gt;\n&lt;/layerGroup&gt;\n\"\"\"\n\ngeoserver.update_layer_group(name=\"my_group\", body=body, workspace=\"demo\")\n</pre> # Using XML format body = \"\"\"  my_group buildings  \"\"\"  geoserver.update_layer_group(name=\"my_group\", body=body, workspace=\"demo\") Out[9]: <pre>'Updated'</pre> In\u00a0[10]: Copied! <pre>geoserver.delete_layer_group(name=\"my_group\", workspace=\"demo\")\n</pre> geoserver.delete_layer_group(name=\"my_group\", workspace=\"demo\") Out[10]: <pre>'Deleted'</pre>"},{"location":"notebooks/Layer%20Groups/#layer-groups","title":"Layer Groups\u00b6","text":"<p>The REST API allows you to create and modify layer groups in GeoServer.</p> <p>Note:  You can find the official example at https://docs.geoserver.org/2.25.x/en/user/rest/layergroups.html</p>"},{"location":"notebooks/Layer%20Groups/#setup","title":"Setup\u00b6","text":""},{"location":"notebooks/Layer%20Groups/#imports","title":"Imports\u00b6","text":"<p>First, we need to import the necessary modules and classes.</p>"},{"location":"notebooks/Layer%20Groups/#geoserver-connection","title":"GeoServer Connection\u00b6","text":"<p>Connect to the running GeoServer instance and create a workspace and a store.</p>"},{"location":"notebooks/Layer%20Groups/#config","title":"Config\u00b6","text":"<p>We'll set up the configuration for the notebook:</p>"},{"location":"notebooks/Layer%20Groups/#listing-layer-groups","title":"Listing layer groups\u00b6","text":"<p>To list all layer groups, use the <code>get_layer_groups</code> method.</p>"},{"location":"notebooks/Layer%20Groups/#creating-a-layer-group","title":"Creating a layer group\u00b6","text":"<p>To create a layer group, use the <code>create_layer_group</code> method.</p>"},{"location":"notebooks/Layer%20Groups/#retrieving-a-layer-group","title":"Retrieving a layer group\u00b6","text":"<p>To retrieve a layer group, use the <code>get_layer_group</code> method.</p>"},{"location":"notebooks/Layer%20Groups/#changing-a-layer-group","title":"Changing a layer group\u00b6","text":"<p>To update a layer group, use the <code>update_layer_group</code> method.</p>"},{"location":"notebooks/Layer%20Groups/#removing-a-layer-group","title":"Removing a layer group\u00b6","text":"<p>To remove a layer group, use the <code>delete_layer_group</code> method.</p>"},{"location":"notebooks/Layers/","title":"Layers","text":"In\u00a0[1]: Copied! <pre>from pathlib import Path\nfrom geoserver import GeoServer\n</pre> from pathlib import Path from geoserver import GeoServer In\u00a0[2]: Copied! <pre># Setup the geoserver instance\ngeoserver = GeoServer(\n    service_url=\"http://localhost:8080/geoserver\",\n    username=\"admin\",\n    password=\"geoserver\",\n)\n</pre> # Setup the geoserver instance geoserver = GeoServer(     service_url=\"http://localhost:8080/geoserver\",     username=\"admin\",     password=\"geoserver\", ) <p>Clean up the workspace and store after running the examples.</p> In\u00a0[3]: Copied! <pre>if geoserver.workspace_exists(\"demo\"):\n    geoserver.delete_workspace(\"demo\", recurse=True)\n\ngeoserver.create_workspace_from_name(\"demo\")\n</pre> if geoserver.workspace_exists(\"demo\"):     geoserver.delete_workspace(\"demo\", recurse=True)  geoserver.create_workspace_from_name(\"demo\") Out[3]: <pre>'Created'</pre> In\u00a0[4]: Copied! <pre># Directory containing sample data\nDATA_DIR = Path(\"../tests/data\")\nassert DATA_DIR.exists(), f\"The directory {DATA_DIR} does not exist.\"\n</pre> # Directory containing sample data DATA_DIR = Path(\"../tests/data\") assert DATA_DIR.exists(), f\"The directory {DATA_DIR} does not exist.\" In\u00a0[5]: Copied! <pre>file_path = DATA_DIR / \"vectors\" / \"buildings.shp\"\nassert file_path.exists(), f\"File not found: {file_path.as_posix()!r}\"\n\n\ngeoserver.upload_data_store(workspace=\"demo\", file=file_path)\n</pre> file_path = DATA_DIR / \"vectors\" / \"buildings.shp\" assert file_path.exists(), f\"File not found: {file_path.as_posix()!r}\"   geoserver.upload_data_store(workspace=\"demo\", file=file_path) Out[5]: <pre>'Created'</pre> In\u00a0[6]: Copied! <pre>geoserver.get_layers(workspace=\"demo\")\n</pre> geoserver.get_layers(workspace=\"demo\") Out[6]: <pre>{'layers': {'layer': [{'name': 'buildings',\n    'href': 'http://localhost:8080/geoserver/rest/workspaces/demo/layers/buildings.json'}]}}</pre> In\u00a0[7]: Copied! <pre>xml = geoserver.get_layers(workspace=\"demo\", format=\"xml\")\nprint(xml)\n</pre> xml = geoserver.get_layers(workspace=\"demo\", format=\"xml\") print(xml) <pre>&lt;layers&gt;\n  &lt;layer&gt;\n    &lt;name&gt;buildings&lt;/name&gt;\n    &lt;atom:link xmlns:atom=\"http://www.w3.org/2005/Atom\" rel=\"alternate\" href=\"http://localhost:8080/geoserver/rest/workspaces/demo/layers/buildings.xml\" type=\"application/atom+xml\"/&gt;\n  &lt;/layer&gt;\n&lt;/layers&gt;\n</pre> In\u00a0[8]: Copied! <pre>geoserver.get_layer(name=\"buildings\", workspace=\"demo\")\n</pre> geoserver.get_layer(name=\"buildings\", workspace=\"demo\") Out[8]: <pre>{'layer': {'name': 'buildings',\n  'type': 'VECTOR',\n  'defaultStyle': {'name': 'polygon',\n   'href': 'http://localhost:8080/geoserver/rest/styles/polygon.json'},\n  'resource': {'@class': 'featureType',\n   'name': 'demo:buildings',\n   'href': 'http://localhost:8080/geoserver/rest/workspaces/demo/datastores/buildings/featuretypes/buildings.json'},\n  'attribution': {'logoWidth': 0, 'logoHeight': 0},\n  'dateCreated': '2024-06-12 22:31:59.747 UTC'}}</pre> In\u00a0[9]: Copied! <pre># Using JSON format\nbody = {\n    \"layer\": {\n        \"defaultStyle\": {\"name\": \"polygon\"},\n    }\n}\n\n# Using XML format\nbody = \"\"\"\n&lt;layer&gt;\n    &lt;defaultStyle&gt;\n        &lt;name&gt;polygon&lt;/name&gt;\n    &lt;/defaultStyle&gt;\n&lt;/layer&gt;\n\"\"\"\n\ngeoserver.update_layer(name=\"buildings\", workspace=\"demo\", body=body)\n</pre> # Using JSON format body = {     \"layer\": {         \"defaultStyle\": {\"name\": \"polygon\"},     } }  # Using XML format body = \"\"\"  polygon  \"\"\"  geoserver.update_layer(name=\"buildings\", workspace=\"demo\", body=body) Out[9]: <pre>'Updated'</pre>"},{"location":"notebooks/Layers/#layers","title":"Layers\u00b6","text":"<p>The REST API allows you to list, create, upload, update, and delete layers in GeoServer.</p> <p>Note:  You can find the official example at https://docs.geoserver.org/2.25.x/en/user/rest/layers.html</p>"},{"location":"notebooks/Layers/#setup","title":"Setup\u00b6","text":""},{"location":"notebooks/Layers/#imports","title":"Imports\u00b6","text":"<p>First, we need to import the necessary modules and classes.</p>"},{"location":"notebooks/Layers/#geoserver-connection","title":"GeoServer Connection\u00b6","text":"<p>Connect to the running GeoServer instance and create a workspace and a store.</p>"},{"location":"notebooks/Layers/#config","title":"Config\u00b6","text":"<p>We'll set up the configuration for the notebook:</p>"},{"location":"notebooks/Layers/#adding-a-layer","title":"Adding a Layer\u00b6","text":"<p>Usually you should setup a layer using the <code>upload_data_store</code> method for feature-based layers or the <code>upload_coverage_store</code> method for raster-based layers.</p>"},{"location":"notebooks/Layers/#listing-all-layers","title":"Listing all layers\u00b6","text":"<p>To list all layers in GeoServer, use the <code>get_layers</code> method. You can specify the response format as JSON or XML (default to JSON).</p>"},{"location":"notebooks/Layers/#retrieve-a-layer","title":"Retrieve a layer\u00b6","text":"<p>To retrieve a layer, use the <code>get_layer</code> method. You must specify the layer name.</p>"},{"location":"notebooks/Layers/#changing-a-layer","title":"Changing a layer\u00b6","text":"<p>To update a layer, use the <code>update_layer</code> method. You must specify the layer name and the new layer configuration.</p>"},{"location":"notebooks/Security/","title":"Security","text":"In\u00a0[1]: Copied! <pre>from geoserver import GeoServer\n</pre> from geoserver import GeoServer In\u00a0[2]: Copied! <pre># Setup the geoserver instance\ngeoserver = GeoServer(\n    service_url=\"http://localhost:8080/geoserver\",\n    username=\"admin\",\n    password=\"geoserver\",\n)\n</pre> # Setup the geoserver instance geoserver = GeoServer(     service_url=\"http://localhost:8080/geoserver\",     username=\"admin\",     password=\"geoserver\", ) <p>Let's clean up the security rules before we start.</p> In\u00a0[3]: Copied! <pre>if geoserver.security_layer_exists(rule=\"topp.*.r\"):\n    geoserver.delete_security_layer()\n    \nif geoserver.security_layer_exists(rule=\"topp.*.r\"):\n    geoserver.delete_security_layer(rule=\"topp.mylayer.w\")\n</pre> if geoserver.security_layer_exists(rule=\"topp.*.r\"):     geoserver.delete_security_layer()      if geoserver.security_layer_exists(rule=\"topp.*.r\"):     geoserver.delete_security_layer(rule=\"topp.mylayer.w\") In\u00a0[4]: Copied! <pre>geoserver.get_master_password()\n</pre> geoserver.get_master_password() Out[4]: <pre>{'oldMasterPassword': 'geoserver'}</pre> In\u00a0[5]: Copied! <pre># Using JSON format\nbody = {\n    \"masterPassword\": {\n        \"oldMasterPassword\": \"geoserver\",\n        \"newMasterPassword\": \"geoserver2\",\n    }\n}\n\n# Using XML format\nbody = \"\"\"\n&lt;masterPassword&gt;\n    &lt;oldMasterPassword&gt;geoserver&lt;/oldMasterPassword&gt;\n    &lt;newMasterPassword&gt;geoserver2&lt;/newMasterPassword&gt;\n&lt;/masterPassword&gt;\n\"\"\"\n\ngeoserver.update_master_password(body=body)\n</pre> # Using JSON format body = {     \"masterPassword\": {         \"oldMasterPassword\": \"geoserver\",         \"newMasterPassword\": \"geoserver2\",     } }  # Using XML format body = \"\"\"  geoserver geoserver2  \"\"\"  geoserver.update_master_password(body=body) Out[5]: <pre>'Updated'</pre> In\u00a0[6]: Copied! <pre># Revert back to the original password\nbody = \"\"\"\n&lt;masterPassword&gt;\n    &lt;oldMasterPassword&gt;geoserver2&lt;/oldMasterPassword&gt;\n    &lt;newMasterPassword&gt;geoserver&lt;/newMasterPassword&gt;\n&lt;/masterPassword&gt;\n\"\"\"\n\ngeoserver.update_master_password(body=body)\n</pre> # Revert back to the original password body = \"\"\"  geoserver2 geoserver  \"\"\"  geoserver.update_master_password(body=body) Out[6]: <pre>'Updated'</pre> In\u00a0[7]: Copied! <pre>geoserver.get_catalog_mode()\n</pre> geoserver.get_catalog_mode() Out[7]: <pre>{'mode': 'MIXED'}</pre> In\u00a0[8]: Copied! <pre># Using JSON format\nbody = {\n    \"catalog\": {\n        \"mode\": \"HIDE\"\n    }\n}\n\n# Using XML format\nbody = \"\"\"\n&lt;catalog&gt;\n    &lt;mode&gt;HIDE&lt;/mode&gt;\n&lt;/catalog&gt;\n\"\"\"\n\ngeoserver.update_catalog_mode(body=body)\n</pre> # Using JSON format body = {     \"catalog\": {         \"mode\": \"HIDE\"     } }  # Using XML format body = \"\"\"  HIDE  \"\"\"  geoserver.update_catalog_mode(body=body) Out[8]: <pre>'Updated'</pre> In\u00a0[9]: Copied! <pre>geoserver.get_security_layers()\n</pre> geoserver.get_security_layers() Out[9]: <pre>{'*.*.r': '*', '*.*.w': 'GROUP_ADMIN,ADMIN'}</pre> In\u00a0[10]: Copied! <pre># Using JSON format\nbody = {\n    \"rules\": [\n        {\"resource\": \"topp.*.r\", \"auth\": \"ROLE_AUTHORIZED\"},\n        {\"resource\": \"topp.mylayer.w\", \"auth\": \"ROLE_1,ROLE_2\"},\n    ]\n}\n\n# Using XML format\nbody = \"\"\"\n&lt;rules&gt;\n   &lt;rule resource=\"topp.*.r\"&gt;ROLE_AUTHORIZED&lt;/rule&gt;\n   &lt;rule resource=\"topp.mylayer.w\"&gt;ROLE_1,ROLE_2&lt;/rule&gt;\n&lt;/rules&gt;\n\"\"\"\n\ngeoserver.create_security_layers(body=body)\n</pre> # Using JSON format body = {     \"rules\": [         {\"resource\": \"topp.*.r\", \"auth\": \"ROLE_AUTHORIZED\"},         {\"resource\": \"topp.mylayer.w\", \"auth\": \"ROLE_1,ROLE_2\"},     ] }  # Using XML format body = \"\"\"  ROLE_AUTHORIZED ROLE_1,ROLE_2  \"\"\"  geoserver.create_security_layers(body=body) Out[10]: <pre>'Created'</pre> In\u00a0[11]: Copied! <pre>geoserver.delete_security_layer(rule=\"topp.*.r\")\ngeoserver.delete_security_layer(rule=\"topp.mylayer.w\")\n</pre> geoserver.delete_security_layer(rule=\"topp.*.r\") geoserver.delete_security_layer(rule=\"topp.mylayer.w\") Out[11]: <pre>'Deleted'</pre>"},{"location":"notebooks/Security/#security","title":"Security\u00b6","text":"<p>The REST API allows you to adjust GeoServer security settings.</p> <p>Note:  You can find the official example at https://docs.geoserver.org/2.25.x/en/user/rest/security.html</p>"},{"location":"notebooks/Security/#setup","title":"Setup\u00b6","text":""},{"location":"notebooks/Security/#imports","title":"Imports\u00b6","text":"<p>First, we need to import the necessary modules and classes.</p>"},{"location":"notebooks/Security/#geoserver-connection","title":"GeoServer Connection\u00b6","text":"<p>Connect to the running GeoServer instance and create a workspace and a store.</p>"},{"location":"notebooks/Security/#listing-the-keystore-password","title":"Listing the keystore password\u00b6","text":"<p>Retrieve the keystore password for the \u201croot\u201d account.</p>"},{"location":"notebooks/Security/#changing-the-keystore-password","title":"Changing the keystore password\u00b6","text":"<p>Change to a new keystore password.</p> <p>Note:  Requires knowledge of the current keystore password.</p>"},{"location":"notebooks/Security/#listing-the-catalog-mode","title":"Listing the catalog mode\u00b6","text":"<p>Fetch the current catalog mode.</p>"},{"location":"notebooks/Security/#changing-the-catalog-mode","title":"Changing the catalog mode\u00b6","text":"<p>Set a new catalog mode.</p>"},{"location":"notebooks/Security/#listing-access-control-rules","title":"Listing access control rules\u00b6","text":"<p>Retrieve current list of access control rules.</p>"},{"location":"notebooks/Security/#changing-access-control-rules","title":"Changing access control rules\u00b6","text":"<p>Set a new list of access control rules.</p>"},{"location":"notebooks/Security/#deleting-access-control-rules","title":"Deleting access control rules\u00b6","text":"<p>Delete individual access control rule.</p>"},{"location":"notebooks/Stores/","title":"Stores","text":"In\u00a0[1]: Copied! <pre>from pathlib import Path\nfrom geoserver import GeoServer\nfrom geoserver.exceptions import GeoServerError\n</pre> from pathlib import Path from geoserver import GeoServer from geoserver.exceptions import GeoServerError In\u00a0[2]: Copied! <pre># Setup the geoserver instance\ngeoserver = GeoServer(\n    service_url=\"http://localhost:8080/geoserver\",\n    username=\"admin\",\n    password=\"geoserver\",\n)\n</pre> # Setup the geoserver instance geoserver = GeoServer(     service_url=\"http://localhost:8080/geoserver\",     username=\"admin\",     password=\"geoserver\", ) <p>Clean up the workspace and store after running the examples.</p> In\u00a0[3]: Copied! <pre>if geoserver.workspace_exists(\"demo\"):\n    geoserver.delete_workspace(\"demo\", recurse=True)\n\ngeoserver.create_workspace_from_name(\"demo\")\n</pre> if geoserver.workspace_exists(\"demo\"):     geoserver.delete_workspace(\"demo\", recurse=True)  geoserver.create_workspace_from_name(\"demo\") Out[3]: <pre>'Created'</pre> In\u00a0[4]: Copied! <pre># Directory containing sample data\nDATA_DIR = Path(\"../tests/data\")\nassert DATA_DIR.exists(), f\"The directory {DATA_DIR} does not exist.\"\n</pre> # Directory containing sample data DATA_DIR = Path(\"../tests/data\") assert DATA_DIR.exists(), f\"The directory {DATA_DIR} does not exist.\" In\u00a0[5]: Copied! <pre>file_path = DATA_DIR / \"vectors\" / \"buildings.zip\"\nassert file_path.exists(), f\"The file {file_path.as_posix()!r} does not exist.\"\n\n\ngeoserver.upload_data_store(file=file_path, workspace=\"demo\")\n</pre> file_path = DATA_DIR / \"vectors\" / \"buildings.zip\" assert file_path.exists(), f\"The file {file_path.as_posix()!r} does not exist.\"   geoserver.upload_data_store(file=file_path, workspace=\"demo\") Out[5]: <pre>'Created'</pre> In\u00a0[6]: Copied! <pre>geoserver.get_data_store(name=\"buildings\", workspace=\"demo\")\n</pre> geoserver.get_data_store(name=\"buildings\", workspace=\"demo\") Out[6]: <pre>{'dataStore': {'name': 'buildings',\n  'type': 'Shapefile',\n  'enabled': True,\n  'workspace': {'name': 'demo',\n   'href': 'http://localhost:8080/geoserver/rest/workspaces/demo.json'},\n  'connectionParameters': {'entry': [{'@key': 'namespace', '$': 'http://demo'},\n    {'@key': 'url',\n     '$': 'file:/opt/geoserver/data_dir/data/demo/buildings/'}]},\n  '_default': False,\n  'dateCreated': '2024-06-12 22:36:06.144 UTC',\n  'disableOnConnFailure': False,\n  'featureTypes': 'http://localhost:8080/geoserver/rest/workspaces/demo/datastores/buildings/featuretypes.json'}}</pre> In\u00a0[7]: Copied! <pre>xml = geoserver.get_data_store(name=\"buildings\", workspace=\"demo\", format=\"xml\")\nprint(xml)\n</pre> xml = geoserver.get_data_store(name=\"buildings\", workspace=\"demo\", format=\"xml\") print(xml) <pre>&lt;dataStore&gt;\n  &lt;name&gt;buildings&lt;/name&gt;\n  &lt;type&gt;Shapefile&lt;/type&gt;\n  &lt;enabled&gt;true&lt;/enabled&gt;\n  &lt;workspace&gt;\n    &lt;name&gt;demo&lt;/name&gt;\n    &lt;atom:link xmlns:atom=\"http://www.w3.org/2005/Atom\" rel=\"alternate\" href=\"http://localhost:8080/geoserver/rest/workspaces/demo.xml\" type=\"application/xml\"/&gt;\n  &lt;/workspace&gt;\n  &lt;connectionParameters&gt;\n    &lt;entry key=\"namespace\"&gt;http://demo&lt;/entry&gt;\n    &lt;entry key=\"url\"&gt;file:/opt/geoserver/data_dir/data/demo/buildings/&lt;/entry&gt;\n  &lt;/connectionParameters&gt;\n  &lt;__default&gt;false&lt;/__default&gt;\n  &lt;dateCreated&gt;2024-06-12 22:36:06.144 UTC&lt;/dateCreated&gt;\n  &lt;disableOnConnFailure&gt;false&lt;/disableOnConnFailure&gt;\n  &lt;featureTypes&gt;\n    &lt;atom:link xmlns:atom=\"http://www.w3.org/2005/Atom\" rel=\"alternate\" href=\"http://localhost:8080/geoserver/rest/workspaces/demo/datastores/buildings/featuretypes.xml\" type=\"application/xml\"/&gt;\n  &lt;/featureTypes&gt;\n&lt;/dataStore&gt;\n</pre> In\u00a0[8]: Copied! <pre>geoserver.get_feature_type(name=\"buildings\", workspace=\"demo\")\n</pre> geoserver.get_feature_type(name=\"buildings\", workspace=\"demo\") Out[8]: <pre>{'featureType': {'name': 'buildings',\n  'nativeName': 'buildings',\n  'namespace': {'name': 'demo',\n   'href': 'http://localhost:8080/geoserver/rest/namespaces/demo.json'},\n  'title': 'buildings',\n  'keywords': {'string': ['features', 'buildings']},\n  'nativeCRS': 'GEOGCS[\"GCS_WGS_1984\", \\n  DATUM[\"D_WGS_1984\", \\n    SPHEROID[\"WGS_1984\", 6378137.0, 298.257223563]], \\n  PRIMEM[\"Greenwich\", 0.0], \\n  UNIT[\"degree\", 0.017453292519943295], \\n  AXIS[\"Longitude\", EAST], \\n  AXIS[\"Latitude\", NORTH]]',\n  'srs': 'EPSG:4326',\n  'nativeBoundingBox': {'minx': -1.5132908,\n   'maxx': -1.5094796,\n   'miny': 48.6349371,\n   'maxy': 48.636897,\n   'crs': 'EPSG:4326'},\n  'latLonBoundingBox': {'minx': -1.5132908,\n   'maxx': -1.5094796,\n   'miny': 48.6349371,\n   'maxy': 48.636897,\n   'crs': 'EPSG:4326'},\n  'projectionPolicy': 'FORCE_DECLARED',\n  'enabled': True,\n  'store': {'@class': 'dataStore',\n   'name': 'demo:buildings',\n   'href': 'http://localhost:8080/geoserver/rest/workspaces/demo/datastores/buildings.json'},\n  'serviceConfiguration': False,\n  'simpleConversionEnabled': False,\n  'maxFeatures': 0,\n  'numDecimals': 0,\n  'padWithZeros': False,\n  'forcedDecimal': False,\n  'overridingServiceSRS': False,\n  'skipNumberMatched': False,\n  'circularArcPresent': False,\n  'attributes': {'attribute': [{'name': 'the_geom',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'org.locationtech.jts.geom.MultiPolygon'},\n    {'name': 'id',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': '@id',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'access',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'addr_city',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'addr_postc',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'addr_stree',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'alt_name',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'amenity',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'area',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'barrier',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'building',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'building_l',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'building_m',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'building_p',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'check_date',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.util.Date',\n     'length': 8},\n    {'name': 'contact_em',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'contact_fa',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'contact_ph',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'contact_we',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'content',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'cuisine',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'denominati',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'descriptio',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'email',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'entrance',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'fax',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'fee',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'fire_stati',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'fixme',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'heritage',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'heritage_o',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'highway',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'historic',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'image',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'indoor',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'internet_a',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'internet_1',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'layer',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'level',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'location',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'man_made',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'mhs_inscri',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.util.Date',\n     'length': 8},\n    {'name': 'name',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'name_cs',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'name_en',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'name_fr',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'note',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'official_n',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'opening_ho',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'operator',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'payment_ap',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'payment_co',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'payment_cr',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'phone',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'ref_FR_CEF',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'ref_FR_SDI',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'ref_mhs',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'religion',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'room',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'rooms',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'service_ti',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'short_name',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'source',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': '@relations',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'source_her',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'stars',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'start_date',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'tourism',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'tower_cons',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'tower_type',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'type',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'was_amenit',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'was_name',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'website',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'wheelchair',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'wikidata',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254},\n    {'name': 'wikipedia',\n     'minOccurs': 0,\n     'maxOccurs': 1,\n     'nillable': True,\n     'binding': 'java.lang.String',\n     'length': 254}]}}}</pre> In\u00a0[9]: Copied! <pre># Using JSON format\nbody = {\n    \"dataStore\": {\n        \"name\": \"db\",\n        \"description\": \"PostGIS connection\",\n        \"connectionParameters\": {\n            \"host\": \"postgis\",\n            \"port\": \"5432\",\n            \"database\": \"db\",\n            \"user\": \"admin\",\n            \"passwd\": \"postgres\",\n            \"dbtype\": \"postgis\",\n            \"schema\": \"public\",\n            \"Expose primary keys\": \"true\",\n            \"Loose bbox\": \"true\",\n            \"Estimated extends\": \"true\",\n            \"fetch size\": \"1000\",\n            \"Max open prepared statements\": \"50\",\n            \"preparedStatements\": \"false\",\n            \"validate connections\": \"true\",\n            \"validate connections on borrow\": \"true\",\n            \"validate connections on return\": \"true\",\n            \"Connection timeout\": \"20\",\n            \"Eviction run periodicity\": \"3600\",\n            \"Min evictable idle time\": \"300\",\n            \"Max active\": \"50\",\n            \"Max idle\": \"10\",\n            \"Max wait\": \"10000\",\n            \"Test on borrow\": \"true\",\n            \"Test while idle\": \"true\",\n            \"Time between eviction runs\": \"60000\",\n        }\n    }\n}\n\n# Using XML format\nbody = \"\"\"\n&lt;dataStore&gt;\n    &lt;name&gt;db&lt;/name&gt;\n    &lt;description&gt;PostGIS database&lt;/description&gt;\n    &lt;connectionParameters&gt;\n        &lt;entry key=\"host\"&gt;postgis&lt;/entry&gt;\n        &lt;entry key=\"port\"&gt;5432&lt;/entry&gt;\n        &lt;entry key=\"database\"&gt;db&lt;/entry&gt;\n        &lt;entry key=\"user\"&gt;admin&lt;/entry&gt;\n        &lt;entry key=\"passwd\"&gt;postgres&lt;/entry&gt;\n        &lt;entry key=\"dbtype\"&gt;postgis&lt;/entry&gt;\n        &lt;entry key=\"schema\"&gt;public&lt;/entry&gt;\n        &lt;entry key=\"Expose primary keys\"&gt;true&lt;/entry&gt;\n        &lt;entry key=\"Loose bbox\"&gt;true&lt;/entry&gt;\n        &lt;entry key=\"Estimated extends\"&gt;true&lt;/entry&gt;\n        &lt;entry key=\"fetch size\"&gt;1000&lt;/entry&gt;\n        &lt;entry key=\"Max open prepared statements\"&gt;50&lt;/entry&gt;\n        &lt;entry key=\"preparedStatements\"&gt;false&lt;/entry&gt;\n        &lt;entry key=\"validate connections\"&gt;true&lt;/entry&gt;\n        &lt;entry key=\"validate connections on borrow\"&gt;true&lt;/entry&gt;\n        &lt;entry key=\"validate connections on return\"&gt;true&lt;/entry&gt;\n        &lt;entry key=\"Connection timeout\"&gt;20&lt;/entry&gt;\n        &lt;entry key=\"Eviction run periodicity\"&gt;3600&lt;/entry&gt;\n        &lt;entry key=\"Min evictable idle time\"&gt;300&lt;/entry&gt;\n        &lt;entry key=\"Max active\"&gt;50&lt;/entry&gt;\n        &lt;entry key=\"Max idle\"&gt;10&lt;/entry&gt;\n        &lt;entry key=\"Max wait\"&gt;10000&lt;/entry&gt;\n        &lt;entry key=\"Test on borrow\"&gt;true&lt;/entry&gt;\n        &lt;entry key=\"Test while idle\"&gt;true&lt;/entry&gt;\n        &lt;entry key=\"Time between eviction runs\"&gt;60000&lt;/entry&gt;\n    &lt;/connectionParameters&gt;\n&lt;/dataStore&gt;\n\"\"\"\n\n\ngeoserver.create_data_store(body=body, workspace=\"demo\")\n</pre> # Using JSON format body = {     \"dataStore\": {         \"name\": \"db\",         \"description\": \"PostGIS connection\",         \"connectionParameters\": {             \"host\": \"postgis\",             \"port\": \"5432\",             \"database\": \"db\",             \"user\": \"admin\",             \"passwd\": \"postgres\",             \"dbtype\": \"postgis\",             \"schema\": \"public\",             \"Expose primary keys\": \"true\",             \"Loose bbox\": \"true\",             \"Estimated extends\": \"true\",             \"fetch size\": \"1000\",             \"Max open prepared statements\": \"50\",             \"preparedStatements\": \"false\",             \"validate connections\": \"true\",             \"validate connections on borrow\": \"true\",             \"validate connections on return\": \"true\",             \"Connection timeout\": \"20\",             \"Eviction run periodicity\": \"3600\",             \"Min evictable idle time\": \"300\",             \"Max active\": \"50\",             \"Max idle\": \"10\",             \"Max wait\": \"10000\",             \"Test on borrow\": \"true\",             \"Test while idle\": \"true\",             \"Time between eviction runs\": \"60000\",         }     } }  # Using XML format body = \"\"\"  db PostGIS database postgis 5432 db admin postgres postgis public true true true 1000 50 false true true true 20 3600 300 50 10 10000 true true 60000  \"\"\"   geoserver.create_data_store(body=body, workspace=\"demo\") Out[9]: <pre>'Created'</pre> In\u00a0[10]: Copied! <pre>xml = geoserver.get_data_store(name=\"db\", workspace=\"demo\", format=\"xml\")\nprint(xml)\n</pre> xml = geoserver.get_data_store(name=\"db\", workspace=\"demo\", format=\"xml\") print(xml) <pre>&lt;dataStore&gt;\n  &lt;name&gt;db&lt;/name&gt;\n  &lt;description&gt;PostGIS database&lt;/description&gt;\n  &lt;type&gt;PostGIS&lt;/type&gt;\n  &lt;enabled&gt;true&lt;/enabled&gt;\n  &lt;workspace&gt;\n    &lt;name&gt;demo&lt;/name&gt;\n    &lt;atom:link xmlns:atom=\"http://www.w3.org/2005/Atom\" rel=\"alternate\" href=\"http://localhost:8080/geoserver/rest/workspaces/demo.xml\" type=\"application/xml\"/&gt;\n  &lt;/workspace&gt;\n  &lt;connectionParameters&gt;\n    &lt;entry key=\"schema\"&gt;public&lt;/entry&gt;\n    &lt;entry key=\"Max idle\"&gt;10&lt;/entry&gt;\n    &lt;entry key=\"Max open prepared statements\"&gt;50&lt;/entry&gt;\n    &lt;entry key=\"preparedStatements\"&gt;false&lt;/entry&gt;\n    &lt;entry key=\"database\"&gt;db&lt;/entry&gt;\n    &lt;entry key=\"validate connections on borrow\"&gt;true&lt;/entry&gt;\n    &lt;entry key=\"host\"&gt;postgis&lt;/entry&gt;\n    &lt;entry key=\"Loose bbox\"&gt;true&lt;/entry&gt;\n    &lt;entry key=\"Min evictable idle time\"&gt;300&lt;/entry&gt;\n    &lt;entry key=\"Estimated extends\"&gt;true&lt;/entry&gt;\n    &lt;entry key=\"fetch size\"&gt;1000&lt;/entry&gt;\n    &lt;entry key=\"Eviction run periodicity\"&gt;3600&lt;/entry&gt;\n    &lt;entry key=\"Expose primary keys\"&gt;true&lt;/entry&gt;\n    &lt;entry key=\"validate connections\"&gt;true&lt;/entry&gt;\n    &lt;entry key=\"Max wait\"&gt;10000&lt;/entry&gt;\n    &lt;entry key=\"Connection timeout\"&gt;20&lt;/entry&gt;\n    &lt;entry key=\"Time between eviction runs\"&gt;60000&lt;/entry&gt;\n    &lt;entry key=\"validate connections on return\"&gt;true&lt;/entry&gt;\n    &lt;entry key=\"Max active\"&gt;50&lt;/entry&gt;\n    &lt;entry key=\"port\"&gt;5432&lt;/entry&gt;\n    &lt;entry key=\"passwd\"&gt;crypt2:lxZ7pgVY09l9utgaQLLpL1einM41hhp3CAkpZoU7alc=&lt;/entry&gt;\n    &lt;entry key=\"dbtype\"&gt;postgis&lt;/entry&gt;\n    &lt;entry key=\"namespace\"&gt;http://demo&lt;/entry&gt;\n    &lt;entry key=\"Test while idle\"&gt;true&lt;/entry&gt;\n    &lt;entry key=\"user\"&gt;admin&lt;/entry&gt;\n    &lt;entry key=\"Test on borrow\"&gt;true&lt;/entry&gt;\n  &lt;/connectionParameters&gt;\n  &lt;__default&gt;false&lt;/__default&gt;\n  &lt;dateCreated&gt;2024-06-12 22:36:06.227 UTC&lt;/dateCreated&gt;\n  &lt;disableOnConnFailure&gt;false&lt;/disableOnConnFailure&gt;\n  &lt;featureTypes&gt;\n    &lt;atom:link xmlns:atom=\"http://www.w3.org/2005/Atom\" rel=\"alternate\" href=\"http://localhost:8080/geoserver/rest/workspaces/demo/datastores/db/featuretypes.xml\" type=\"application/xml\"/&gt;\n  &lt;/featureTypes&gt;\n&lt;/dataStore&gt;\n</pre> In\u00a0[11]: Copied! <pre>!ogr2ogr -f PostgreSQL PG:\"host=localhost port=5432 user=admin dbname=db password=postgres\" ../tests/data/vectors/landuse.shp -nlt PROMOTE_TO_MULTI -lco OVERWRITE=YES\n</pre> !ogr2ogr -f PostgreSQL PG:\"host=localhost port=5432 user=admin dbname=db password=postgres\" ../tests/data/vectors/landuse.shp -nlt PROMOTE_TO_MULTI -lco OVERWRITE=YES <pre>Warning 1: Layer creation options ignored since an existing layer is\n         being appended to.\n</pre> In\u00a0[12]: Copied! <pre># Using JSON format\nbody = {\n    \"featureType\": {\n        \"name\": \"landuse\",\n        \"title\": \"landuse\",\n        \"advertised\": \"true\",\n    }\n}\n\n# Using XML format\nbody = \"\"\"\n&lt;featureType&gt;\n    &lt;name&gt;landuse&lt;/name&gt;\n    &lt;title&gt;landuse&lt;/title&gt;\n    &lt;advertised&gt;true&lt;/advertised&gt;\n&lt;/featureType&gt;\n\"\"\"\n\n\ngeoserver.create_feature_type(body=body, workspace=\"demo\", store=\"db\")\n</pre> # Using JSON format body = {     \"featureType\": {         \"name\": \"landuse\",         \"title\": \"landuse\",         \"advertised\": \"true\",     } }  # Using XML format body = \"\"\"  landuse landuse true  \"\"\"   geoserver.create_feature_type(body=body, workspace=\"demo\", store=\"db\") Out[12]: <pre>'Created'</pre> <p>Note:  This layer can viewed with a WMS GetMap request at the following URL:</p> <pre><code>http://localhost:8080/geoserver/wms/reflect?layers=demo:landuse\n</code></pre> In\u00a0[13]: Copied! <pre># Using XML format\nbody = \"\"\"\n&lt;featureType&gt;\n  &lt;name&gt;annotations&lt;/name&gt;\n  &lt;nativeName&gt;annotations&lt;/nativeName&gt;\n  &lt;title&gt;Annotations&lt;/title&gt;\n  &lt;srs&gt;EPSG:4326&lt;/srs&gt;\n  &lt;attributes&gt;\n    &lt;attribute&gt;\n      &lt;name&gt;the_geom&lt;/name&gt;\n      &lt;binding&gt;org.locationtech.jts.geom.Point&lt;/binding&gt;\n    &lt;/attribute&gt;\n    &lt;attribute&gt;\n      &lt;name&gt;description&lt;/name&gt;\n      &lt;binding&gt;java.lang.String&lt;/binding&gt;\n    &lt;/attribute&gt;\n    &lt;attribute&gt;\n      &lt;name&gt;timestamp&lt;/name&gt;\n      &lt;binding&gt;java.util.Date&lt;/binding&gt;\n    &lt;/attribute&gt;\n  &lt;/attributes&gt;\n&lt;/featureType&gt;\n\"\"\"\n\n\ntry:\n  geoserver.create_feature_type(body=body, workspace=\"demo\", store=\"db\")\nexcept GeoServerError as e:\n  if e.status_code == 500:\n    print(f\"[WARNING] Could not add feature_type: {e}\")\n    print(\"[WARNING] It is possible that the feature_type already exists in the database.\")\n</pre> # Using XML format body = \"\"\"  annotations annotations Annotations EPSG:4326 the_geom org.locationtech.jts.geom.Point description java.lang.String timestamp java.util.Date  \"\"\"   try:   geoserver.create_feature_type(body=body, workspace=\"demo\", store=\"db\") except GeoServerError as e:   if e.status_code == 500:     print(f\"[WARNING] Could not add feature_type: {e}\")     print(\"[WARNING] It is possible that the feature_type already exists in the database.\") <pre>[WARNING] Could not add feature_type: Error 500: \n[WARNING] It is possible that the feature_type already exists in the database.\n</pre> <p>A new and empty table named <code>annotations</code> in the <code>db</code> database will be created as well.</p> In\u00a0[14]: Copied! <pre># Using JSON format\nbody = {\n    \"wmtsStore\": {\n        \"name\": \"basemap-nat-geo-datastore\",\n        \"description\": \"esri-street-map\",\n        \"capabilitiesURL\": \"https://services.arcgisonline.com/arcgis/rest/services/NatGeo_World_Map/MapServer/WMTS/1.0.0/WMTSCapabilities.xml\",\n        \"type\": \"WMTS\",\n    }\n}\n\n# Using XML format\nbody = \"\"\"\n&lt;wmtsStore&gt;\n  &lt;name&gt;basemap-nat-geo-datastore&lt;/name&gt;\n  &lt;description&gt;esri-street-map&lt;/description&gt;\n  &lt;capabilitiesURL&gt;https://services.arcgisonline.com/arcgis/rest/services/NatGeo_World_Map/MapServer/WMTS/1.0.0/WMTSCapabilities.xml&lt;/capabilitiesURL&gt;\n  &lt;type&gt;WMTS&lt;/type&gt;\n&lt;/wmtsStore&gt;\n\"\"\"\n\n\ngeoserver.create_wmts_store(body=body, workspace=\"demo\")\n</pre> # Using JSON format body = {     \"wmtsStore\": {         \"name\": \"basemap-nat-geo-datastore\",         \"description\": \"esri-street-map\",         \"capabilitiesURL\": \"https://services.arcgisonline.com/arcgis/rest/services/NatGeo_World_Map/MapServer/WMTS/1.0.0/WMTSCapabilities.xml\",         \"type\": \"WMTS\",     } }  # Using XML format body = \"\"\"  basemap-nat-geo-datastore esri-street-map https://services.arcgisonline.com/arcgis/rest/services/NatGeo_World_Map/MapServer/WMTS/1.0.0/WMTSCapabilities.xml WMTS  \"\"\"   geoserver.create_wmts_store(body=body, workspace=\"demo\") Out[14]: <pre>'Created'</pre> In\u00a0[15]: Copied! <pre>geoserver.get_wmts_layers(workspace=\"demo\")\n</pre> geoserver.get_wmts_layers(workspace=\"demo\") Out[15]: <pre>{'layers': {'layer': [{'name': 'buildings',\n    'href': 'http://localhost:8080/geoserver/rest/workspaces/demo/layers/buildings.json'},\n   {'name': 'landuse',\n    'href': 'http://localhost:8080/geoserver/rest/workspaces/demo/layers/landuse.json'}]}}</pre> In\u00a0[16]: Copied! <pre># Using JSON format\nbody = {\n    \"wmtsLayer\": {\n        \"name\": \"NatGeo_World_Map\",\n    }\n}\n\n# Using XML format\nbody = \"\"\"\n&lt;wmtsLayer&gt;\n  &lt;name&gt;NatGeo_World_Map&lt;/name&gt;\n&lt;/wmtsLayer&gt;\n\"\"\"\n\n\ngeoserver.create_wmts_layer(body=body, workspace=\"demo\", store=\"basemap-nat-geo-datastore\")\n</pre> # Using JSON format body = {     \"wmtsLayer\": {         \"name\": \"NatGeo_World_Map\",     } }  # Using XML format body = \"\"\"  NatGeo_World_Map  \"\"\"   geoserver.create_wmts_layer(body=body, workspace=\"demo\", store=\"basemap-nat-geo-datastore\") Out[16]: <pre>'Created'</pre>"},{"location":"notebooks/Stores/#stores","title":"Stores\u00b6","text":"<p>Note:  You can find the official example at https://docs.geoserver.org/2.25.x/en/user/rest/stores.html</p>"},{"location":"notebooks/Stores/#setup","title":"Setup\u00b6","text":""},{"location":"notebooks/Stores/#imports","title":"Imports\u00b6","text":"<p>First, we need to import the necessary modules and classes.</p>"},{"location":"notebooks/Stores/#geoserver-connection","title":"GeoServer Connection\u00b6","text":"<p>Connect to the running GeoServer instance and create a workspace and a store.</p>"},{"location":"notebooks/Stores/#config","title":"Config\u00b6","text":"<p>We'll set up the configuration for the notebook:</p>"},{"location":"notebooks/Stores/#uploading-a-shapefile","title":"Uploading a shapefile\u00b6","text":"<p>Create a new store <code>buildings</code> by uploading a shapefile <code>buildings.zip</code>.</p>"},{"location":"notebooks/Stores/#retrieving-a-store","title":"Retrieving a store\u00b6","text":"<p>Retrieve information about a specific store. You can specify the response format as JSON or XML using the <code>format</code> parameter.</p>"},{"location":"notebooks/Stores/#listing-feature-type-details","title":"Listing feature type details\u00b6","text":"<p>By default when a shapefile is uploaded, a feature type is automatically created. This is true only if you use the <code>upload_data_store</code> method. If you use the <code>create_data_store</code> method, you will have to create the feature type manually.</p>"},{"location":"notebooks/Stores/#adding-an-existing-shapefile","title":"Adding an existing shapefile\u00b6","text":"<p>Publish a shapefile that already exists on the server without needing to be uploaded. We will use the <code>roads</code> store that we created earlier.</p> <pre>geoserver.upload_data_store(\n    file=\"file:/opt/geoserver/data_dir/data/demo/buildings/buildings.shp\", \n    workspace=\"demo\", \n    store=\"buildings_v2\",\n    filename=\"buildings_v2.shp\",\n)\n</pre>"},{"location":"notebooks/Stores/#adding-a-directory-of-existing-shapefiles","title":"Adding a directory of existing shapefiles\u00b6","text":"<p>Create a store containing a directory of shapefiles that already exists on the server without needing to be uploaded.</p> <pre>geoserver.upload_data_store(\n    file=\"file:/opt/geoserver/data_dir/data/demo\", \n    name=\"buildings_v2\",\n    workspace=\"demo\", \n    configure=\"all\"\n)\n</pre>"},{"location":"notebooks/Stores/#adding-a-postgis-database-store","title":"Adding a PostGIS database store\u00b6","text":"<p>Add an existing PostGIS database as a new store. The connection parameters available from the <code>docker-compose.yml</code> file are:</p> <ul> <li>host: <code>postgis</code></li> <li>port: <code>5432</code></li> <li>database: <code>db</code></li> <li>user: <code>admin</code></li> <li>password: <code>postgres</code></li> <li>dbtype: <code>postgis</code></li> </ul> <p>Note:  This example assumes that a PostGIS database named <code>db</code> is present on the local system and is accessible by the user <code>admin</code>.</p>"},{"location":"notebooks/Stores/#listing-a-postgis-database-store-details","title":"Listing a PostGIS database store details\u00b6","text":"<p>Retrieve information about a PostGIS store.</p>"},{"location":"notebooks/Stores/#publishing-a-table-from-an-existing-postgis-store","title":"Publishing a table from an existing PostGIS store\u00b6","text":"<p>Publish a new featuretype from a PostGIS store table <code>buildings</code>.</p> <p>Note:  This example assumes the table has already been created. You can create the table using the following command:</p> <pre>ogr2ogr -f PostgreSQL PG:\"host=localhost port=5432 user=admin dbname=db password=postgres\" ../data/vectors/landuse.shp -nlt PROMOTE_TO_MULTI -lco OVERWRITE=YES\n</pre>"},{"location":"notebooks/Stores/#creating-a-postgis-table","title":"Creating a PostGIS table\u00b6","text":"<p>Create a new featuretype in GeoServer and simultaneously create a table in PostGIS.</p> <p>Note:  The <code>db</code> store must be a PostGIS store for this to succeed.</p>"},{"location":"notebooks/Stores/#adding-an-external-wmts-store","title":"Adding an external WMTS Store\u00b6","text":"<p>Create a new WMTS store <code>Basemap-Nat-Geo-Datastore</code>.</p>"},{"location":"notebooks/Stores/#adding-an-external-wmts-layer","title":"Adding an external WMTS Layer\u00b6","text":"<p>Publish a new WMTS Layer <code>NatGeo_World_Map</code> from the WMTS store <code>Basemap-Nat-Geo-Datastore</code>.</p>"},{"location":"notebooks/Styles/","title":"Styles","text":"In\u00a0[1]: Copied! <pre>from pathlib import Path\nfrom geoserver import GeoServer\n</pre> from pathlib import Path from geoserver import GeoServer In\u00a0[2]: Copied! <pre># Setup the geoserver instance\ngeoserver = GeoServer(\n    service_url=\"http://localhost:8080/geoserver\",\n    username=\"admin\",\n    password=\"geoserver\",\n)\n</pre> # Setup the geoserver instance geoserver = GeoServer(     service_url=\"http://localhost:8080/geoserver\",     username=\"admin\",     password=\"geoserver\", ) <p>Let's cleanup the previous styles:</p> In\u00a0[3]: Copied! <pre>if geoserver.workspace_exists(\"demo\"):\n    geoserver.delete_workspace(\"demo\", recurse=True)\n\ngeoserver.create_workspace_from_name(\"demo\")\n</pre> if geoserver.workspace_exists(\"demo\"):     geoserver.delete_workspace(\"demo\", recurse=True)  geoserver.create_workspace_from_name(\"demo\") Out[3]: <pre>'Created'</pre> In\u00a0[4]: Copied! <pre># Directory containing sample data\nDATA_DIR = Path(\"../tests/data\")\nassert DATA_DIR.exists(), f\"The directory {DATA_DIR} does not exist.\"\n</pre> # Directory containing sample data DATA_DIR = Path(\"../tests/data\") assert DATA_DIR.exists(), f\"The directory {DATA_DIR} does not exist.\" In\u00a0[5]: Copied! <pre>geoserver.get_styles()\n</pre> geoserver.get_styles() Out[5]: <pre>{'styles': {'style': [{'name': 'generic',\n    'href': 'http://localhost:8080/geoserver/rest/styles/generic.json'},\n   {'name': 'line',\n    'href': 'http://localhost:8080/geoserver/rest/styles/line.json'},\n   {'name': 'point',\n    'href': 'http://localhost:8080/geoserver/rest/styles/point.json'},\n   {'name': 'polygon',\n    'href': 'http://localhost:8080/geoserver/rest/styles/polygon.json'},\n   {'name': 'raster',\n    'href': 'http://localhost:8080/geoserver/rest/styles/raster.json'}]}}</pre> In\u00a0[6]: Copied! <pre>geoserver.get_style(\"point\")\n</pre> geoserver.get_style(\"point\") Out[6]: <pre>{'style': {'name': 'point',\n  'format': 'sld',\n  'languageVersion': {'version': '1.0.0'},\n  'filename': 'default_point.sld'}}</pre> In\u00a0[7]: Copied! <pre># Using XML format\nbody = \"\"\"\n&lt;style&gt;\n    &lt;name&gt;elevation&lt;/name&gt;\n    &lt;filename&gt;elevation.sld&lt;/filename&gt;\n&lt;/style&gt;\n\"\"\"\n\ngeoserver.create_style(body=body, workspace=\"demo\")\n</pre> # Using XML format body = \"\"\"  \"\"\"  geoserver.create_style(body=body, workspace=\"demo\") Out[7]: <pre>'Created'</pre> In\u00a0[8]: Copied! <pre># Get the styles associated to the raster layer\nfile_path = DATA_DIR / \"styles\" / \"elevation.sld\"\nassert file_path.exists(), f\"File not found: {file_path.as_posix()!r}\"\n\n\nwith open(file_path, \"r\") as file:\n    body = file.read()\n\n\ngeoserver.update_style(\"elevation\", body=body, workspace=\"demo\")\n</pre> # Get the styles associated to the raster layer file_path = DATA_DIR / \"styles\" / \"elevation.sld\" assert file_path.exists(), f\"File not found: {file_path.as_posix()!r}\"   with open(file_path, \"r\") as file:     body = file.read()   geoserver.update_style(\"elevation\", body=body, workspace=\"demo\") Out[8]: <pre>'Updated'</pre> In\u00a0[9]: Copied! <pre># Get the styles associated to the raster layer\nfile_path = DATA_DIR / \"styles\" / \"elevation.sld\"\nassert file_path.exists(), f\"File not found: {file_path.as_posix()!r}\"\n\n\ngeoserver.upload_style(file=file_path, workspace=\"demo\", name=\"elevation\", overwrite=True)\n</pre> # Get the styles associated to the raster layer file_path = DATA_DIR / \"styles\" / \"elevation.sld\" assert file_path.exists(), f\"File not found: {file_path.as_posix()!r}\"   geoserver.upload_style(file=file_path, workspace=\"demo\", name=\"elevation\", overwrite=True) Out[9]: <pre>'Created'</pre> In\u00a0[10]: Copied! <pre># Get the styles associated to the raster layer\nfile_path = DATA_DIR / \"styles\" / \"elevation.sld\"\nassert file_path.exists(), f\"File not found: {file_path.as_posix()!r}\"\n\n\nwith open(file_path, \"r\") as file:\n    body = file.read()\n\n\ngeoserver.update_style(\"elevation\", body=body, workspace=\"demo\")\n</pre> # Get the styles associated to the raster layer file_path = DATA_DIR / \"styles\" / \"elevation.sld\" assert file_path.exists(), f\"File not found: {file_path.as_posix()!r}\"   with open(file_path, \"r\") as file:     body = file.read()   geoserver.update_style(\"elevation\", body=body, workspace=\"demo\") Out[10]: <pre>'Updated'</pre> In\u00a0[11]: Copied! <pre>geoserver.upload_style(file=file_path, workspace=\"demo\", name=\"elevation\", overwrite=True)\n</pre> geoserver.upload_style(file=file_path, workspace=\"demo\", name=\"elevation\", overwrite=True) Out[11]: <pre>'Created'</pre> In\u00a0[12]: Copied! <pre>xml = geoserver.download_style(name=\"elevation\", workspace=\"demo\")\nprint(xml)\n</pre> xml = geoserver.download_style(name=\"elevation\", workspace=\"demo\") print(xml) <pre>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;sld:StyledLayerDescriptor xmlns=\"http://www.opengis.net/sld\" xmlns:sld=\"http://www.opengis.net/sld\" xmlns:gml=\"http://www.opengis.net/gml\" xmlns:ogc=\"http://www.opengis.net/ogc\" version=\"1.0.0\"&gt;\n  &lt;sld:NamedLayer&gt;\n    &lt;sld:Name&gt;raster&lt;/sld:Name&gt;\n    &lt;sld:UserStyle&gt;\n      &lt;sld:Name&gt;raster&lt;/sld:Name&gt;\n      &lt;sld:FeatureTypeStyle&gt;\n        &lt;sld:Name&gt;name&lt;/sld:Name&gt;\n        &lt;sld:Rule&gt;\n          &lt;sld:RasterSymbolizer&gt;\n            &lt;sld:ChannelSelection&gt;\n              &lt;sld:GrayChannel&gt;\n                &lt;sld:SourceChannelName&gt;1&lt;/sld:SourceChannelName&gt;\n                &lt;sld:ContrastEnhancement&gt;\n                  &lt;sld:GammaValue&gt;1.0&lt;/sld:GammaValue&gt;\n                &lt;/sld:ContrastEnhancement&gt;\n              &lt;/sld:GrayChannel&gt;\n            &lt;/sld:ChannelSelection&gt;\n            &lt;sld:ColorMap&gt;\n              &lt;sld:ColorMapEntry color=\"#FFFFFF\" opacity=\"0\" quantity=\"-1\" label=\"label\"/&gt;\n              &lt;sld:ColorMapEntry color=\"#0000FF\" opacity=\"1\" quantity=\"0\" label=\"label\"/&gt;\n              &lt;sld:ColorMapEntry color=\"#FF0000\" opacity=\"1\" quantity=\"110\" label=\"label\"/&gt;\n            &lt;/sld:ColorMap&gt;\n            &lt;sld:ContrastEnhancement/&gt;\n          &lt;/sld:RasterSymbolizer&gt;\n        &lt;/sld:Rule&gt;\n      &lt;/sld:FeatureTypeStyle&gt;\n    &lt;/sld:UserStyle&gt;\n  &lt;/sld:NamedLayer&gt;\n&lt;/sld:StyledLayerDescriptor&gt;\n\n\n</pre> In\u00a0[13]: Copied! <pre>file_path = DATA_DIR / \"rasters\" / \"elevation.tif\"\nassert file_path.exists(), f\"File not found: {file_path.as_posix()!r}\"\n\n\ngeoserver.upload_coverage_store(file=file_path, workspace=\"demo\", format=\"geotiff\")\n</pre> file_path = DATA_DIR / \"rasters\" / \"elevation.tif\" assert file_path.exists(), f\"File not found: {file_path.as_posix()!r}\"   geoserver.upload_coverage_store(file=file_path, workspace=\"demo\", format=\"geotiff\") Out[13]: <pre>'Created'</pre> In\u00a0[14]: Copied! <pre>geoserver.publish_style(layer=\"elevation\", style=\"elevation\", workspace=\"demo\")\n</pre> geoserver.publish_style(layer=\"elevation\", style=\"elevation\", workspace=\"demo\") Out[14]: <pre>'Updated'</pre> In\u00a0[15]: Copied! <pre>geoserver.get_styles(workspace=\"demo\")\n</pre> geoserver.get_styles(workspace=\"demo\") Out[15]: <pre>{'styles': {'style': [{'name': 'elevation',\n    'href': 'http://localhost:8080/geoserver/rest/workspaces/demo/styles/elevation.json'}]}}</pre> In\u00a0[16]: Copied! <pre>geoserver.delete_style(name=\"elevation\", workspace=\"demo\", recurse=True)\n</pre> geoserver.delete_style(name=\"elevation\", workspace=\"demo\", recurse=True) Out[16]: <pre>'Deleted'</pre>"},{"location":"notebooks/Styles/#styles","title":"Styles\u00b6","text":"<p>The REST API allows you to list, create, upload, update, and delete styles in GeoServer.</p> <p>Note:  You can find the official example at https://docs.geoserver.org/2.25.x/en/user/rest/styles.html</p>"},{"location":"notebooks/Styles/#setup","title":"Setup\u00b6","text":""},{"location":"notebooks/Styles/#imports","title":"Imports\u00b6","text":"<p>First, we need to import the necessary modules and classes.</p>"},{"location":"notebooks/Styles/#geoserver-connection","title":"GeoServer Connection\u00b6","text":"<p>Connect to the running GeoServer instance and create a workspace and a store.</p>"},{"location":"notebooks/Styles/#utils","title":"Utils\u00b6","text":"<p>For this tutorial, styles are located in the examples directory.</p>"},{"location":"notebooks/Styles/#listing-all-styles","title":"Listing all styles\u00b6","text":"<p>To list all the styles in the GeoServer instance, use the <code>get_styles</code> method.</p>"},{"location":"notebooks/Styles/#retrieve-a-style","title":"Retrieve a style\u00b6","text":"<p>To get a specific style, use the <code>get_style</code> method.</p>"},{"location":"notebooks/Styles/#creating-a-style","title":"Creating a style\u00b6","text":"<p>You can create a new style on the server in two ways. In the first way, the creation is done in two steps: the style entry is created in the catalog, and then the style content is uploaded. The second way can add the style to the server in a single step by uploading a file containing the style content.</p>"},{"location":"notebooks/Styles/#create-a-new-style-in-two-steps","title":"Create a new style in two steps\u00b6","text":""},{"location":"notebooks/Styles/#uploading-a-style-from-a-file","title":"Uploading a style from a file\u00b6","text":"<p>You can upload a style from a file using the <code>upload_style</code> method. The method supports both SLD and ZIP files.</p>"},{"location":"notebooks/Styles/#changing-an-existing-style","title":"Changing an existing style\u00b6","text":"<p>To update a style, use the <code>update_style</code> method.</p>"},{"location":"notebooks/Styles/#reupload-the-content-of-an-existing-style","title":"Reupload the content of an existing style\u00b6","text":"<p>By default, you cannot reupload the content of an existing style. You can use the <code>overwrite=True</code> parameter to allow the content to be reuploaded.</p>"},{"location":"notebooks/Styles/#downloading-a-style","title":"Downloading a style\u00b6","text":"<p>The SLD itself can be downloaded using the <code>download_style</code> method.</p>"},{"location":"notebooks/Styles/#publishing-a-style","title":"Publishing a style\u00b6","text":"<p>To style an existing layer, use the <code>publish_style</code> method. This method is just a shortcut to the <code>update_layer</code> method, which allows you to update the style of a layer.</p>"},{"location":"notebooks/Styles/#deleting-a-style","title":"Deleting a style\u00b6","text":"<p>To delete a style, use the <code>delete_style</code> method. You can use the <code>purge=True</code> argument to remove the style and all its references.</p>"},{"location":"notebooks/Workspaces/","title":"Workspaces","text":"In\u00a0[1]: Copied! <pre>from geoserver import GeoServer\n</pre> from geoserver import GeoServer In\u00a0[2]: Copied! <pre># Setup the geoserver instance\ngeoserver = GeoServer(\n    service_url=\"http://localhost:8080/geoserver\",\n    username=\"admin\",\n    password=\"geoserver\",\n)\n\n# If the workspace does not exist, create it\nif geoserver.workspace_exists(\"demo\"):\n    geoserver.delete_workspace(\"demo\", recurse=True)\n</pre> # Setup the geoserver instance geoserver = GeoServer(     service_url=\"http://localhost:8080/geoserver\",     username=\"admin\",     password=\"geoserver\", )  # If the workspace does not exist, create it if geoserver.workspace_exists(\"demo\"):     geoserver.delete_workspace(\"demo\", recurse=True) In\u00a0[3]: Copied! <pre># Using JSON format\nbody = {\n    \"workspace\": {\n        \"name\": \"demo\",\n    }\n}\n\n# Using XML format\nbody = \"\"\"\n&lt;workspace&gt;\n    &lt;name&gt;demo&lt;/name&gt;\n&lt;/workspace&gt;\n\"\"\"\n\n# Create the workspace\ngeoserver.create_workspace(body=body)\n</pre> # Using JSON format body = {     \"workspace\": {         \"name\": \"demo\",     } }  # Using XML format body = \"\"\"  demo  \"\"\"  # Create the workspace geoserver.create_workspace(body=body) Out[3]: <pre>'Created'</pre> <p>Because it can be verbose to create the workspace by providing the full XML, we can use the <code>create_workspace_by_name</code> method to create a workspace by providing only the name.</p> In\u00a0[4]: Copied! <pre># geoserver.create_workspace_by_name(name=\"demo\")\n</pre> # geoserver.create_workspace_by_name(name=\"demo\") In\u00a0[5]: Copied! <pre>geoserver.get_workspace(name=\"demo\")\n</pre> geoserver.get_workspace(name=\"demo\") Out[5]: <pre>{'workspace': {'name': 'demo',\n  'isolated': False,\n  'dateCreated': '2024-06-12 22:37:19.313 UTC',\n  'dataStores': 'http://localhost:8080/geoserver/rest/workspaces/demo/datastores.json',\n  'coverageStores': 'http://localhost:8080/geoserver/rest/workspaces/demo/coveragestores.json',\n  'wmsStores': 'http://localhost:8080/geoserver/rest/workspaces/demo/wmsstores.json',\n  'wmtsStores': 'http://localhost:8080/geoserver/rest/workspaces/demo/wmtsstores.json'}}</pre> In\u00a0[6]: Copied! <pre>data = geoserver.get_workspace(name=\"demo\", format=\"xml\")\nprint(data)\n</pre> data = geoserver.get_workspace(name=\"demo\", format=\"xml\") print(data) <pre>&lt;workspace&gt;\n  &lt;name&gt;demo&lt;/name&gt;\n  &lt;isolated&gt;false&lt;/isolated&gt;\n  &lt;dateCreated&gt;2024-06-12 22:37:19.313 UTC&lt;/dateCreated&gt;\n  &lt;dataStores&gt;\n    &lt;atom:link xmlns:atom=\"http://www.w3.org/2005/Atom\" rel=\"alternate\" href=\"http://localhost:8080/geoserver/rest/workspaces/demo/datastores.xml\" type=\"application/xml\"/&gt;\n  &lt;/dataStores&gt;\n  &lt;coverageStores&gt;\n    &lt;atom:link xmlns:atom=\"http://www.w3.org/2005/Atom\" rel=\"alternate\" href=\"http://localhost:8080/geoserver/rest/workspaces/demo/coveragestores.xml\" type=\"application/xml\"/&gt;\n  &lt;/coverageStores&gt;\n  &lt;wmsStores&gt;\n    &lt;atom:link xmlns:atom=\"http://www.w3.org/2005/Atom\" rel=\"alternate\" href=\"http://localhost:8080/geoserver/rest/workspaces/demo/wmsstores.xml\" type=\"application/xml\"/&gt;\n  &lt;/wmsStores&gt;\n  &lt;wmtsStores&gt;\n    &lt;atom:link xmlns:atom=\"http://www.w3.org/2005/Atom\" rel=\"alternate\" href=\"http://localhost:8080/geoserver/rest/workspaces/demo/wmtsstores.xml\" type=\"application/xml\"/&gt;\n  &lt;/wmtsStores&gt;\n&lt;/workspace&gt;\n</pre> <p>This shows that the workspace can contain <code>\"dataStores\"</code> (for vector data), <code>\"coverageStores\"</code> (for raster data), and <code>\"wmsStores\"</code> (for cascaded WMS servers).</p>"},{"location":"notebooks/Workspaces/#workspaces","title":"Workspaces\u00b6","text":"<p>The REST API allows you to create and manage workspaces in GeoServer.</p> <p>Note:  You can find the official example at https://docs.geoserver.org/2.25.x/en/user/rest/workspaces.html</p>"},{"location":"notebooks/Workspaces/#setup","title":"Setup\u00b6","text":""},{"location":"notebooks/Workspaces/#imports","title":"Imports\u00b6","text":"<p>First, we need to import the necessary modules and classes.</p>"},{"location":"notebooks/Workspaces/#geoserver-connection","title":"GeoServer Connection\u00b6","text":"<p>Connect to the running GeoServer instance and create a workspace and a store.</p>"},{"location":"notebooks/Workspaces/#adding-a-new-workspace","title":"Adding a new workspace\u00b6","text":"<p>Creates a new workspace named <code>\"demo\"</code> using the <code>create_workspace</code> method.</p>"},{"location":"notebooks/Workspaces/#retrieving-workspace","title":"Retrieving workspace\u00b6","text":"<p>Retrieve information about a specific workspace. You can specify the response format as JSON or XML by setting the <code>format</code> parameter.</p>"}]}